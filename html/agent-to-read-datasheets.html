<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="2 Jan 2026">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="How to quickly put together a data extraction agent.">
<link rel="stylesheet" href="style.css">
<title>Agent To Read Electronic Datasheets</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Agents</div>
<h2>Agent To Read Electronic Datasheets</h2>
<div class="article-meta">Published 2 Jan 2026. Written by Jakob Kastelic.</div>
<p><img src="../images/pa.jpg" alt="" /></p>
<p>When an electronic design company accumulates large amounts of inventory, it can
become overwhelming for engineers to go through the thousands of parts to find
the one needed in a new design. Instead, they are likely to select a new part
from one of the distributors that have a better search engine. This leads to an
ever growing inventory: parts kept in stock and never used, a constant departure
from the ideal of having a “lean” operation.</p>
<p>Nowadays, with everyone creating their own “agent” for just about anything, I
wondered how hard it would be to create my own search engine. This article
represents a day of work, proving that structured data extraction from
semi-unstructured sources like datasheets has become almost a trivial problem.</p>
<p>I took the <a href="https://deepmind.google/models/gemma/gemma-3/">Gemma 3</a> model (12B
parameters, 3-bit quantization) from Google, ran it in the
<a href="https://github.com/ggml-org/llama.cpp">llama.cpp</a> inference framework, and fed
it the datasheet for an opamp. To extract the text from the PDFs, I used the
<a href="https://www.docling.ai/">Docling</a> Python library from IBM research. The output,
generated in about four minutes on a GPU with 8 GB of memory, will be in this
format for now:</p>
<pre><code class="language-json"><div class="codehilite"><pre><span></span><span class="nt">&quot;PSRR (Input offset voltage versus power supply)&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nt">&quot;min&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">65</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;typ&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;max&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">   </span><span class="nt">&quot;unit&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;dB&quot;</span>
<span class="w"> </span><span class="p">},</span>
</pre></div>
</code></pre>
<p>Let’s get started!</p>
<h3 id="running-the-model">Running the model</h3>
<p>Obtain and build llama.cpp:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ggerganov/llama.cpp
<span class="nb">cd</span><span class="w"> </span>llama.cpp
cmake<span class="w"> </span>-B<span class="w"> </span>build<span class="w"> </span>-S<span class="w"> </span>.<span class="w"> </span>-DGGML_CUDA<span class="o">=</span>ON
cmake<span class="w"> </span>--build<span class="w"> </span>build<span class="w"> </span>-j
</pre></div>
</code></pre>
<p>Obtain the <a href="https://huggingface.co/bartowski/google_gemma-3-12b-it-GGUF">Gemma
3</a> model.</p>
<p>Start the LLM server:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>llama-server<span class="w"> </span>-m<span class="w"> </span>~/temp/gemma-3-12b-it-UD-IQ3_XXS.gguf<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>--port<span class="w"> </span><span class="m">8080</span><span class="w"> </span>-c<span class="w"> </span><span class="m">4096</span><span class="w"> </span>-ngl<span class="w"> </span><span class="m">999</span>
</pre></div>
</code></pre>
<p>Open <code>localhost:8080</code> and feel free to chat with the model. How simple things
have become!</p>
<h3 id="get-datasheet-text">Get datasheet text</h3>
<p>Next, we need to convert the datasheets from the PDF format into plain text that
we can feed to the model. Assuming <code>docling</code> is installed (install it with Pip
if not), we can define the following function to convert the documents:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">docling.document_converter</span> <span class="kn">import</span> <span class="n">DocumentConverter</span>

<span class="k">def</span> <span class="nf">convert_pdf_to_markdown</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">):</span>
    <span class="n">pdf_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">)</span>
    <span class="n">converter</span> <span class="o">=</span> <span class="n">DocumentConverter</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">pdf_path</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">export_to_markdown</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>This yields the output in a Markdown format.</p>
<h3 id="define-agent-with-a-simple-prompt">Define agent with a simple prompt</h3>
<p>Here’s the best part: the “source code” for the agent is in plain English. Here
it is in its entirety:</p>
<pre><code><div class="codehilite"><pre><span></span>You are a datasheet specification extraction agent. Your
only job is to extract specifications.

OUTPUT FORMAT:
{
  &quot;Full parameter name (short name)&quot;: {
    &quot;min&quot;: number or null,
    &quot;typ&quot;: number or null,
    &quot;max&quot;: number or null,
    &quot;unit&quot;: &quot;string&quot;
  }
}

EXTRACTION RULES:
- Always include both the full and short spec name in the key.
- Full name goes first, and short name in brackets: &quot;Operating Temperature (T)&quot;
- If a typ value is a range like &quot;-11.5 to 14.5&quot;, split it: min=-11.5, max=14.5
- Convert scientific notation: &quot;10 12&quot; → 1e12
- Convert ± values into min/max fields
- Omit parameters with no numeric values (all null)
- Omit footnotes like (1) and (2)
- If no specifications exist, return: {}

CRITICAL OUTPUT RULES:
- Return ONLY valid JSON
- NO explanations
- NO descriptions
- NO phrases like &quot;this section&quot;, &quot;no specifications&quot;, &quot;I will skip&quot;
- NO text before or after the JSON
- NO markdown code blocks
- Just the raw JSON object
</pre></div>
</code></pre>
<p>The insistence on pure JSON is a hack to make it stop being too chatty. There’s
probably a more sophisticated way to do it, but for a first attempt it’ll do
just fine.</p>
<h3 id="chunking">“Chunking”</h3>
<p>The datasheet conversion from PDF includes lots of unnecessary text like
document version information, copyright, ordering information. For now, we’d
like to get just the electronic specifications. As a first approximation, assume
that the information is always present in tables only.</p>
<p>ChatGPT assures me that the following regex magic will extract tables from a
Markdown document:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">get_chunks</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of Markdown tables as strings from a file.&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;(?:^\|.*\|\s*\n)&quot;</span>           <span class="c1"># Header row</span>
        <span class="sa">r</span><span class="s2">&quot;(?:^\|[-:\s|]+\|\s*\n)&quot;</span>     <span class="c1"># Separator row</span>
        <span class="sa">r</span><span class="s2">&quot;(?:^\|.*\|\s*\n?)+&quot;</span><span class="p">,</span>        <span class="c1"># Body rows</span>
        <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span>
    <span class="p">)</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">table_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">]</span>
</pre></div>
</code></pre>
<h3 id="putting-it-together">Putting it together</h3>
<p>We have all the pieces now: text data in small pieces, a model, the prompt to
define an agent. Now just iterate over all the chunks as defined above, send
them to the model together with the prompt, and observe what comes out. To
automate the process from PDF to the final JSON, I used a Makefile defining the
recipes for the three steps of the transformation. All of this is too
straightforward to be worth including here.</p>
<p>For anyone interested, find the entire code presented above
<a href="https://github.com/js216/sfap">here</a>.</p>

</div>

<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>

</body>
</html>
