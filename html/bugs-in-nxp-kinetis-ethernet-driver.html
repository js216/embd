<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="10 Sep 2025">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content=">">
<link rel="stylesheet" href="style.css">
<title>Bugs in NXP Kinetis Ethernet Driver</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Embedded</div>
<h2>Bugs in NXP Kinetis Ethernet Driver</h2>
<div class="article-meta">Published 10 Sep 2025. By Jakob Kastelic.</div>
<p><img src="../images/lev63.jpg" alt=""></p>
<p>The SDK<sup class="footnote-ref"><a href="#fn-cdc89f27-sdk" id="fnref-cdc89f27-sdk">[1]</a></sup> drivers provided by NXP for use on the Kinetis K64 platform are
extensive, well-tested and ... not perfect. This article shows three bugs found
in the ethernet driver. Note that none of this is original content; I merely put
it together here for my future reference.</p>
<h3 id="forgetting-to-check-for-zero-length-buffers">Forgetting to check for zero-length buffers</h3>
<p>I have only seen this bug happen once in two years and have not found a way to
reproduce it at will. So the analysis below may or may not be correct.</p>
<p>The symptom was that the firmware froze upon triggering the assertion in
<code>lwip/port/enet_ethernetif_kinetis.c</code>:</p>
<blockquote>
<p>&ldquo;Buffer returned by <code>ENET_GetRxFrame()</code> doesn&rsquo;t match any RX buffer descriptor&rdquo;</p>
</blockquote>
<p>After some Googling I found <a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">this forum
thread,</a>
which suggests, in a roundabout way, that there is a missing check in
<code>fsl_enet.c</code>. We have to add following to <code>ENET_GetRxFrame()</code>:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">if</span> (curBuffDescrip<span class="o">-</span><span class="o">&gt;</span>length <span class="o">=</span><span class="o">=</span> 0U)
{
    <span class="cm">/* Set LAST bit manually to let following drop error frame
       operation drop this abnormal BD.
    */</span>
    curBuffDescrip<span class="o">-</span><span class="o">&gt;</span>control <span class="o">|</span><span class="o">=</span> ENET_BUFFDESCRIPTOR_RX_LAST_MASK;
    result <span class="o">=</span> kStatus_ENET_RxFrameError;
    <span class="k">break</span>;
}</code></pre></div>


<p>The NXP engineer on the forum explains: &ldquo;I didn&rsquo;t use this logic because I never
meet this corner case and consider it a redundant operation.&rdquo; I was curious if
this &ldquo;corner case&rdquo; every happens, so I added a breakpoint, which got triggered
after about two days of constant testing.</p>
<p>ChatGPT seems to think this check is necessary (but then again, I seem to be
able to convince it of just about anything I do or do not believe in):</p>
<blockquote>
<p>If you omit the check and DMA ever delivers a BD with <code>length == 0</code>: Your code
will think it’s still in the middle of assembling a frame. It will not see the
<code>LAST</code> bit yet, so it will happily advance to the next BD. That means the
logic walks into an inconsistent state: <code>rxBuffer</code> may point to nothing, your
<code>rxFrame</code> bookkeeping goes out of sync, and later you’ll crash on a buffer
underrun, invalid pointer, or corrupted frame queue.</p>
</blockquote>
<p>It remains to be seen if this check was behind my original crash, and if the
body of the if statement is appropriate to handle the condition of unexpected
zero-length buffer descriptor.</p>
<p><em>Credit: User pjanco first reported the error, while AbnerWang posted the
solution.</em>
<a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">[source]</a></p>
<h3 id="incorrect-memory-deallocation">Incorrect memory deallocation</h3>
<p>In <code>fsl_enet.c</code>, the function <code>ENET_GetRxFrame()</code> tries to deallocate the
pointer of the receive buffer:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">while</span> (index<span class="o">-</span><span class="o">-</span> <span class="o">!</span><span class="o">=</span> 0U)
{
    handle<span class="o">-</span><span class="o">&gt;</span><span class="nf">rxBuffFree</span>(base, <span class="o">&amp;</span>rxFrame<span class="o">-</span><span class="o">&gt;</span>rxBuffArray[index].buffer,
        handle<span class="o">-</span><span class="o">&gt;</span>userData, ringId);
}</code></pre></div>


<p>First need to unpack some definitions to understand what the above means.</p>
<ol>
<li>
<p>If we dig into the <code>rxBuffFree()</code> function, we discover it in the file
<code>lwip/port/enet_ethernetif_kinetis.c</code>. The buffer to be deallocated is passed
as a pointer <code>void * buffer</code>, and freed</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">int</span> idx <span class="o">=</span> ((rx_buffer_t <span class="o">*</span>)buffer) <span class="o">-</span> ethernetif<span class="o">-</span><span class="o">&gt;</span>RxDataBuff;
   ethernetif<span class="o">-</span><span class="o">&gt;</span>RxPbufs[idx].buffer_used <span class="o">=</span> false;</code></pre></div>


</li>
</ol>
<ol>
<li>
<p>Next, what are <code>rxFrame</code> and <code>rxBuffArray</code>? The first one is of type
<code>enet_rx_frame_struct_t</code>, which is defined in <code>fsl_enet.h</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> <span class="k">struct</span> _enet_rx_frame_struct
   {
       enet_buffer_struct_t <span class="o">*</span>rxBuffArray;
       ...
   } enet_rx_frame_struct_t;</code></pre></div>


<p>This allows us to see what is the type of <code>rxBuffArray</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> <span class="k">struct</span> _enet_buffer_struct
   {
       <span class="k">void</span> <span class="o">*</span>buffer;
       uint16_t length;
   } enet_buffer_struct_t;</code></pre></div>


</li>
</ol>
<ol>
<li>
<p>Finally, what is <code>ethernetif-&gt;RxDataBuff</code>? We find it declared in
<code>lwip/port/enet_ethernetif_kinetis.c</code> as the static array in the function
<code>ethernetif0_init()</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="nf">SDK_ALIGN</span>(<span class="k">static</span> rx_buffer_t rxDataBuff_0[ENET_RXBUFF_NUM],
       FSL_ENET_BUFF_ALIGNMENT);
   ethernetif_0.RxDataBuff <span class="o">=</span> <span class="o">&amp;</span>(rxDataBuff_0[<span class="m">0</span>]);</code></pre></div>


<p>More precisely, <code>RxDataBuff</code> is a pointer to the first element of this array.
This pointer therefore has the type <code>rx_buffer_t*</code>.</p>
<p>That type itself is declared at the top of the same file as an aligned
version of a <code>uint8_t</code> buffer:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> uint8_t rx_buffer_t[<span class="nf">SDK_SIZEALIGN</span>(ENET_RXBUFF_SIZE,
       FSL_ENET_BUFF_ALIGNMENT)];</code></pre></div>


</li>
</ol>
<p>Now we can take a step back and think whether the <code>idx</code> calculation would be
best done with the buffer itself, or a pointer to it. The calculation subtracts
the following:</p>
<ul>
<li>
<p><code>rxFrame-&gt;rxBuffArray[index].buffer</code>, of type <code>void*</code>, is a pointer to the
memory location that stores the ethernet frame.</p>
</li>
</ul>
<ul>
<li>
<p><code>ethernetif-&gt;RxDataBuff</code>, of type <code>rx_buffer_t*</code></p>
</li>
</ul>
<p>The corrected code should pass the buffer pointer stored in .buffer, not the
address of the .buffer field (omit the <code>&amp;</code>):</p>
<div class="codehilite"><pre><code class="language-c">handle<span class="o">-</span><span class="o">&gt;</span><span class="nf">rxBuffFree</span>(base, rxFrame<span class="o">-</span><span class="o">&gt;</span>rxBuffArray[index].buffer,
    handle<span class="o">-</span><span class="o">&gt;</span>userData, ringId);</code></pre></div>


<p><em>Credit: This bug was found by KC on 7/31/2024.</em></p>
<h3 id="buffers-not-zero-initialized">Buffers not zero-initialized</h3>
<p>Another bug in <code>ethernetif0_init()</code> in <code>enet_ethernetif_kinetis.c</code>: the ethernet
buffer descriptor structs are declared static:</p>
<div class="codehilite"><pre><code class="language-c"><span class="nf">AT_NONCACHEABLE_SECTION_ALIGN</span>(
    <span class="k">static</span> enet_rx_bd_struct_t rxBuffDescrip_0[ENET_RXBD_NUM],
    FSL_ENET_BUFF_ALIGNMENT);
<span class="nf">AT_NONCACHEABLE_SECTION_ALIGN</span>(
    <span class="k">static</span> enet_tx_bd_struct_t txBuffDescrip_0[ENET_TXBD_NUM],
    FSL_ENET_BUFF_ALIGNMENT);</code></pre></div>


<p>The assumption is that since they are declared <code>static</code>, the descriptors will be
zero-initialized at system startup. However, the macro
<code>AT_NONCACHEABLE_SECTION_ALIGN</code> potentially places these descriptor in a special
section that can bypass the zero-initialization, depending on the startup code
and linker script.</p>
<p>In that case, we need to manually zero out these buffers. I put the following at
the top of <code>ethernetif_enet_init()</code> in <code>enet_ethernetif_kinetis.c</code>:</p>
<div class="codehilite"><pre><code class="language-c"><span class="c1">// Buffer descriptors must be initialized to zero</span>
<span class="nf">memset</span>(<span class="o">&amp;</span>ethernetif<span class="o">-</span><span class="o">&gt;</span>RxBuffDescrip[<span class="m">0</span>], <span class="m">0x00</span>, ENET_RXBD_NUM<span class="o">*</span><span class="nf">sizeof</span>(ethernetif<span class="o">-</span><span class="o">&gt;</span>RxBuffDescrip[<span class="m">0</span>]));
<span class="nf">memset</span>(<span class="o">&amp;</span>ethernetif<span class="o">-</span><span class="o">&gt;</span>TxBuffDescrip[<span class="m">0</span>], <span class="m">0x00</span>, ENET_TXBD_NUM<span class="o">*</span><span class="nf">sizeof</span>(ethernetif<span class="o">-</span><span class="o">&gt;</span>TxBuffDescrip[<span class="m">0</span>]));</code></pre></div>


<p><em>Credit: This bug was also found by KC.</em></p>
<hr><section class="footnotes"><ol><li id="fn-cdc89f27-sdk" value="1">I am using SDK version 2.11.0 for the MK64FN1M0xxx12. <a href="#fnref-cdc89f27-sdk">↩</a></li></ol></section>
</div>
</body>
</html>
