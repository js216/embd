<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="9 Jan 2026">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Tracing a silent STM32MP135 Linux boot hang: kernel decompression, JTAG debugging, and the DDR wiring mistake that caused deterministic corruption.">
<link rel="stylesheet" href="style.css">
<title>Debugging STM32MP135 Kernel Decompression</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Linux</div>
<h2>Debugging STM32MP135 Kernel Decompression</h2>
<div class="article-meta">Published 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img src="../images/altair.jpg" alt="" /></p>
<p><em>This is Part 8 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>My <a href="https://github.com/js216/stm32mp135_test_board">STM32MP135 board</a> includes
DDR3L RAM and initial tests shows that I can fill it up with pseudo-random data
and read it back correctly. ST provides a DDR test
<a href="https://github.com/STMicroelectronics/STM32DDRFW-UTIL">utility</a> with a suite of
memory tests, all of which pass. I decided to take it a step further and test
the memory on a more intensive real-world task: “unzipping” a compressed file.</p>
<h3 id="summary">Summary</h3>
<p>The result of the decompression test was very bad: most of the file was
uncompressed correctly, with just a few bits always wrong, and just a few of
them only sometimes wrong. I spent two or three days tracing my way through the
“unzip” code, instruction by instruction, to try to catch where exactly it goes
wrong.</p>
<p>In the end, I made an embarrassing discovery: I have partially swapped byte
lanes. DDR3L on this SoC has two byte lanes, each consisting of {data, mask,
strobe}. I have connected the data bits correctly, but swapped the mask &amp; strobe
between the two bytes. (Six high speed traces, some on inner layers—there’s no
fixing that by hand.) Had I also swapped the data bits, everything would have
been fine; indeed, the eval board swaps all the wires, which led me astray.
(Partially.)</p>
<p>Sadly, AI was of no help in this instance. Given my DDR3L wiring, I can convince
it either way: the connections are good; the connections are not good. In the
end, only Rev B will tell for sure.</p>
<h3 id="problem-statement">Problem statement</h3>
<p>In this article we will proceed with debugging boot of the compressed Linux
kernel image (<code>zImage</code>) on a <a href="https://github.com/js216/stm32mp135_test_board">custom
board</a> populated with the
STM32MP135 SoC. The starting point will be the build that runs on the
evaluation board as described in the <a href="https://embd.cc/build-linux-for-stm32mp135-in-under-50-lines-of-makefile">previous
article</a>.</p>
<p>Despite booting just fine, the <code>zImage</code> gets stuck on boot on the custom board,
without any messages printed to the UART console. Following along with the
debugger shows that the decompressor code does run, but it’s not clear where
exactly it gets stuck.</p>
<h3 id="power-supply">Power supply</h3>
<p>It is possible that the burst of DDR activity during the high-speed
decompression draws more current than the 1.35V supply is able to provide,
despite the decoupling capacitance.</p>
<p>Indeed, on the scope I see a 30mV drop in the 1.35V supply voltage for about
500ms. However, if I raise the supply voltage by the 30mV, the boot still gets
stuck. This was with kernel being written to 0xC2008000 and the DTB to
0xC4008000, which means that relocation isn’t necessary. My interpretation is
that the scope trace shows that decompression takes about half a second.</p>
<p>Interestingly, if the kernel is written to 0xC0008000 and DTB to 0xC2008000, in
which case relocation is necessary, the 20mV supply drop is shorter, about
150ms, and is followed by 10ms of a bigger drop, 120mV. That drop is indeed
enough to disturb the decompression, since raising the supply voltage setpoint
to 1.38V makes the bigger voltage drop be followed by 500ms of the usual 30mV
drop. My interpretation: relocation takes 150ms, followed by 500ms of
decompression, but the power supply is not stiff enough for
relocation/decompression.</p>
<p>Soldering 1000uF electrolytic capacitors to the 1.25V and 1.35V rails, the
effect is that both relocation and decompression complete (according to the
scope trace, i.e., the 150ms and 500ms voltage drops are visible) with the two
rails at 1.35V, 1.30V, 1.25V, 1.20V, 1.15V, but not below that. Restoring the
supply setpoint to 1.35V, we see that the relocation and decompression complete
as expected.</p>
<p>In order to avoid wasting time with relocation, we will from now on load the
kernel to 0xC2000000 and the device tree to 0xC4000000. The scope trace of the
1.35V rail shows a small voltage drop for 500ms (decompression).</p>
<h3 id="uart-print-during-decompression">UART print during decompression</h3>
<p>It’s not reassuring that we get zero console output during decompression. Trying
to get at least some output, I added <code>CONFIG_DEBUG_LL=y</code> to the <code>.config</code> file
and accepted most of the default options suggested by make:</p>
<pre><code><div class="codehilite"><pre><span></span>Kernel low-level debugging functions (read help!) (DEBUG_LL) [Y/n/?] y
  Kernel low-level debugging port
  &gt; 1. Use STM32MP1 UART for low-level debug (STM32MP1_DEBUG_UART) (NEW)
    2. Kernel low-level debugging via EmbeddedICE DCC channel (DEBUG_ICEDCC) (NEW)
    3. Kernel low-level debug output via semihosting I/O (DEBUG_SEMIHOSTING) (NEW)
    4. Kernel low-level debugging via 8250 UART (DEBUG_LL_UART_8250) (NEW)
    5. Kernel low-level debugging via ARM Ltd PL01x Primecell UART (DEBUG_LL_UART_PL01X) (NEW)
  choice[1-5?]:
Enable flow control (CTS) for the debug UART (DEBUG_UART_FLOW_CONTROL) [N/y/?] (NEW)
Physical base address of debug UART (DEBUG_UART_PHYS) [0x40010000] (NEW)
Virtual base address of debug UART (DEBUG_UART_VIRT) [0xfe010000] (NEW)
Early printk (EARLY_PRINTK) [N/y/?] (NEW) y
Write the current PID to the CONTEXTIDR register (PID_IN_CONTEXTIDR) [N/y/?] n
</pre></div>
</code></pre>
<p>However, no output appeared on the UART. Loading <code>Image</code> (rather than <code>zImage</code>)
produces the early prints, but the decompression hang mystery persists.</p>
<h3 id="jtag">JTAG</h3>
<p>Note: follow along this section with the help of <code>linusw</code>’s article, <a href="https://people.kernel.org/linusw/how-the-arm32-linux-kernel-decompresses">“How the
ARM32 Linux kernel
decompresses”</a>.</p>
<p>Let’s try to follow along the decompression using a J-Link debug probe. First,
open the GDB server and connect to it:</p>
<pre><code><div class="codehilite"><pre><span></span>JLinkGDBServer.exe -device STM32MP135F -if swd -port 2330
arm-none-eabi-gdb.exe -q -x load.gdb
</pre></div>
</code></pre>
<p>Where the <code>load.gdb</code> script contains:</p>
<pre><code><div class="codehilite"><pre><span></span>file build/main.elf
add-symbol-file build/compressed 0xc2000000
target remote localhost:2330
monitor reset
monitor flash device=STM32MP135F
load build/main.elf
monitor go
break handoff.S:93
</pre></div>
</code></pre>
<p>Step instruction a few times till reaching just after the handoff code:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) bt
#0  0xc2000004 in _text () at arch/arm/boot/compressed/head.S:202
</pre></div>
</code></pre>
<p>This shows that execution has begun at the beginning of the decompressor, in
file <code>arch/arm/boot/compressed/head.S</code>, in the <code>start:</code> label. We can step
through the code lines (<code>n</code> command in gdb) until reaching the line <code>bne not_angel</code>, which we have to step into (<code>si</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) si
not_angel () at arch/arm/boot/compressed/head.S:245
245                     safe_svcmode_maskall r0
</pre></div>
</code></pre>
<p>Go forward (<code>n</code>) a few steps till reaching the C function
<code>fdt_check_mem_start()</code> (<code>arch/arm/boot/compressed/fdt_check_mem_start.c</code>), then
call <code>finish</code> to get out of it and continue stepping through the <code>not_angel</code>
section:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) finish
Run till exit from #0  fdt_check_mem_start (mem_start=1, fdt=0xc4000000) at
arch/arm/boot/compressed/fdt_check_mem_start.c:106
not_angel () at arch/arm/boot/compressed/head.S:312
312                     add     r4, r0, #TEXT_OFFSET
Value returned is $3 = 3221225472
(gdb) n
323                     mov     r0, pc
324                     cmp     r0, r4
325                     ldrcc   r0, .Lheadroom
326                     addcc   r0, r0, pc
327                     cmpcc   r4, r0
328                     orrcc   r4, r4, #1              @ remember we skipped cache_on
329                     blcs    cache_on
</pre></div>
</code></pre>
<p>Step into <code>cache_on</code> and later <code>call_cache_fn</code>, and go through the many lines
till reaching the return from <code>__armv7_mmu_cache_on:</code>. Thus we reach the
<code>restart:</code> section:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b 902
Breakpoint 3 at 0xc200055c: file arch/arm/boot/compressed/head.S, line 902.
(gdb) c
Continuing.

Breakpoint 3, __armv7_mmu_cache_on () at arch/arm/boot/compressed/head.S:902
902                     mcr     p15, 0, r0, c7, c5, 4   @ ISB
(gdb) n
903                     mov     pc, r12
(gdb) si
restart () at arch/arm/boot/compressed/head.S:331
331     restart:        adr     r0, LC1
</pre></div>
</code></pre>
<p>Continue stepping through until reaching the <code>wont_overwrite:</code> section, and
then <code>not_relocated:</code>, where we clear BSS. Step through that, and we reach the
beginning of the decompression proper: the <code>decompress_kernel()</code> function in
<code>arch/arm/boot/compressed/misc.c</code>. Interestingly, we step right past the
<code>putstr(&quot;Uncompressing Linux...&quot;);</code> line without seeing anything printed on the
UART console.</p>
<p>The function <code>decompress_kernel()</code> calls <code>do_decompress()</code>, which calls
<code>__decompress</code> which calls <code>__gunzip</code>. Calling <code>finish</code> on the latter exactly
correlates with the 500ms of the voltage drop observed on the 1.35V supply as
mentioned above. Now we’re back in the <code>decompress_kernel()</code> function, which
should print &quot; done, booting the kernel.\n&quot; (but doesn’t, since there’s
something wrong with my <code>putstr</code> function).</p>
<p>We return back to the <code>not_relocated:</code> section of the compressed <code>head.S</code> and
call <code>get_inflated_image_size</code> to find out how large the decompressed kernel
is:</p>
<pre><code><div class="codehilite"><pre><span></span>not_relocated () at arch/arm/boot/compressed/head.S:636
636                     get_inflated_image_size r1, r2, r3
638                     mov     r0, r4                  @ start of inflated image
639                     add     r1, r1, r0              @ end of inflated image
(gdb) p/x $r0
$3 = 0xc0008000
(gdb) p/x $r1
$4 = 0xc1241f48
(gdb)
</pre></div>
</code></pre>
<p>Subtracting the <code>r1</code> and <code>r0</code> values, we see that the uncompressed kernel is
exactly 19111752 bytes in size, which is identical to the size of the
<code>arch/arm/boot/Image</code> file. So far so good!</p>
<p>Next, the startup code cleans caches and turns them off again and jumps to
<code>__enter_kernel</code> just like we may do directly, had we loaded the uncompressed
image in memory with the bootloader. This places the pointer to the DTB into
<code>r2</code> and passes control to the kernel:</p>
<pre><code><div class="codehilite"><pre><span></span>__enter_kernel () at arch/arm/boot/compressed/head.S:1435
1435                    mov     r0, #0                  @ must be 0
1436                    mov     r1, r7                  @ restore architecture number
1437                    mov     r2, r8                  @ restore atags pointer
1438     ARM(           mov     pc, r4          )       @ call kernel
</pre></div>
</code></pre>
<p>Just before the jump to the kernel, we can check that the register values make
sense: <code>r0</code> and <code>r1</code> are zero, <code>r2</code> has the DTB address, and the decompressed
kernel will run from location <code>0xC0008000</code> (= <code>TEXT_OFFSET</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) p $r0
$5 = 0
(gdb) p $r1
$6 = 0
(gdb) p/x $r2
$8 = 0xc4000000
(gdb) p/x $r4
$9 = 0xc0008000
(gdb)
</pre></div>
</code></pre>
<p>One fateful step and we’re running in the uncompressed kernel proper. Let’s
load the symbols from the main kernel ELF file to see what’s going on:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) si
0xc0008000 in ?? ()
(gdb) add-symbol-file build/vmlinux 0xc0008000
add symbol table from file &quot;build/vmlinux&quot; at
        .text_addr = 0xc0008000
Reading symbols from build/vmlinux...
(gdb)
</pre></div>
</code></pre>
<p>Interesting, just one more step and the debugger stops as some much later point:</p>
<pre><code><div class="codehilite"><pre><span></span>gdb) si
0xc0114620 in perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10836
10836                   hwc-&gt;sample_period = event-&gt;attr.sample_period;
(gdb) bt
#0  0xc0114620 in perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10836
#1  perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10818
#2  cpu_clock_event_init (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10902
#3  0xc271e9f0 in ?? ()
</pre></div>
</code></pre>
<p>But if we <code>finish</code> running the <code>perf_swevent_init_hrtimer</code> function, then
somehow we end up back in <code>arch/arm/kernel/head.S</code>. Debugging from that point
onwards appears to have gone totally insane!</p>
<h3 id="decompressor-handoff-to-regular-kernel-code">Decompressor handoff to regular kernel code</h3>
<p>Let’s start again from scratch. Set a breakpoint at the point where the
uncompressed kernel is supposed to begin executing:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b *0xc0008000
Breakpoint 6 at 0xc0008000: file arch/arm/kernel/head.S, line 501.
(gdb) c
Continuing.

Breakpoint 6, stext () at arch/arm/kernel/head.S:501
501             mov     r0, r0
(gdb) p $pc
$11 = (void (*)()) 0xc0008000 &lt;stext&gt;
</pre></div>
</code></pre>
<p>This is strange: program counter is in the expected location, but we’re on line
501 into <code>head.S</code>, rather than closer to the beginning of the file. The reason
is that we have incorrectly instructed GDB that the entire <code>vmlinux</code> starts at
0xC0008000, instead of just the first section. We can fix it by clearing the
symbol file, re-loading the symbols at their natural link address, and
verifying everything makes sense:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) symbol-file
Error in re-setting breakpoint 1: No source file named handoff.S.
No symbol file now.
(gdb) file build/vmlinux
Reading symbols from build/vmlinux...
(gdb) p/x &amp;stext
$15 = 0xc0008000
(gdb) si
__hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
73              store_primary_cpu_mode  r4, r5
(gdb) finish
Run till exit from #0  __hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
stext () at arch/arm/kernel/head.S:105
105             safe_svcmode_maskall r9
</pre></div>
</code></pre>
<p>Now we’re simply running through the beginning of the normal kernel start in
section <code>ENTRY(stext)</code> in file <code>arch/arm/kernel/head.S</code>. By single stepping
through the code, we can find the exact section where things go badly wrong:</p>
<pre><code><div class="codehilite"><pre><span></span>stext () at arch/arm/kernel/head.S:162
162             badr    lr, 1f                          @ return (PIC) address
167             mov     r8, r4                          @ set TTBR1 to swapper_pg_dir
169             ldr     r12, [r10, #PROCINFO_INITFUNC]
170             add     r12, r12, r10
171             ret     r12

__v7_ca7mp_setup () at arch/arm/mm/proc-v7.S:302
302             do_invalidate_l1
0xc01197fc      302             do_invalidate_l1
0xc0119800      302             do_invalidate_l1
0xc0119804      302             do_invalidate_l1

v7_invalidate_l1 () at arch/arm/mm/cache-v7.S:40
40              mov     r0, #0
41              mcr     p15, 2, r0, c0, c0, 0   @ select L1 data cache in CSSELR
(gdb)
0x2fff2f08 in ?? ()
</pre></div>
</code></pre>
<p>We see that after the last <code>mcr</code> instruction, the code lands up in SYSRAM
instead of the DDR, from where we’ve been executing so far. That address
corresponds to the vectors as have been installed by the bootloader; in
particular, we have gotten into the dummy SVC handler.</p>
<p>Let’s examine the program instructions at the point just before where the
failure occurs:</p>
<pre><code><div class="codehilite"><pre><span></span>Breakpoint 7, v7_invalidate_l1 () at arch/arm/mm/cache-v7.S:40
40              mov     r0, #0
(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0x2f400f10      0xffffffff      0xee300f10
</pre></div>
</code></pre>
<p>Very interesting! The expected instruction, <code>0xe3a00000</code>, is followed by
<code>0x2f400f10</code> and <code>0xffffffff</code>. The first one is the “mystery” SVC call, and the second one
is simply undefined:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) set {int}0xc0000000 = 0x2f400f10
(gdb) x/i 0xc0000000
   0xc0000000:  svccs   0x00400f10
(gdb) set {int}0xc0000000 = 0xffffffff
(gdb) x/i 0xc0000000
   0xc0000000:                  @ &lt;UNDEFINED&gt; instruction: 0xffffffff
</pre></div>
</code></pre>
<p>For comparison, here’s the instructions we expect to find from the disassembly
of the ELF file:</p>
<pre><code><div class="codehilite"><pre><span></span>$ arm-linux-gnueabi-objdump -d linux/vmlinux | grep -A 4 &quot;v7_invalidate_l1&quot;
c0118b2c &lt;v7_invalidate_l1&gt;:
c0118b2c:       e3a00000        mov     r0, #0
c0118b30:       ee400f10        mcr     15, 2, r0, cr0, cr0, {0}
c0118b34:       f57ff06f        isb     sy
c0118b38:       ee300f10        mrc     15, 1, r0, cr0, cr0, {0}
</pre></div>
</code></pre>
<h3 id="ddr-corruption-pattern">DDR corruption pattern</h3>
<p>Let’s compare the binary pattern between the expected and actual instructions:</p>
<pre><code><div class="codehilite"><pre><span></span>Expected: 0xee400f10 = 0b11101110010000000000111100010000
Actual:   0x2f400f10 = 0b00101111010000000000111100010000
---------------------------------------------------------
Diff:       ^^           ^^     ^
</pre></div>
</code></pre>
<p>Three bits have been flipped in this instruction, changing it from <code>mcr</code> to
<code>svc</code>. This could be explained if DDR is miswired or misconfigured. However,
the pattern of data corruption is repeatable: reboot after reboot, the same
instruction gets corrupted in exactly the same way!</p>
<p>To prove that the DDR is capable of holding data at this address, we can write
it manually and step through the instructions without any weird jumps to
vectors:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0x2f400f10      0xffffffff      0xee300f10
(gdb) set {int}0xc0118b30 = 0xee400f10
(gdb) set {int}0xc0118b34 = 0xf57ff06f
(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0xee400f10      0xf57ff06f      0xee300f10
(gdb) si
41              mcr     p15, 2, r0, c0, c0, 0   @ select L1 data cache in CSSELR
42              isb
43              mrc     p15, 1, r0, c0, c0, 0   @ read cache geometry from CCSIDR
45              movw    r3, #0x3ff
</pre></div>
</code></pre>
<p>We can also load and run the decompressor as usual and set a breakpoint to
0xC0008000, where the uncompressed kernel is supposed to take over. Then, we
simply overwrite whatever the decompressor has written from gdb:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) restore build/Image binary 0xc0008000
Restoring binary file build/Image into memory (0xc0008000 to 0xc1241f48)
(gdb) c
</pre></div>
</code></pre>
<p>Nothing has been printed to the console, since apparently the decompressor
disabled the console, but if we stop the debugger (Ctrl-C), we see that the
kernel proceeded with the boot and finally came to a stop when mounting the
root filesystem (understandable, since we haven’t given it a rootfs yet):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) bt
#0  0xc0b87034 in __timer_delay (cycles=63999) at arch/arm/lib/delay.c:50
#1  0xc0bb2238 in panic (fmt=0xc0defa0c &quot;VFS: Unable to mount root fs on %s&quot;) at kernel/panic.c:451
#2  0xc1001878 in mount_block_root (name=0x51 &lt;error: Cannot access memory at address 0x51&gt;, name@entry=0xc0defaa0 &quot;/dev/root&quot;, flags=3900) at init/do_mounts.c:432
#3  0xc1001b50 in mount_root () at init/do_mounts.c:592
#4  0xc1001cc8 in prepare_namespace () at init/do_mounts.c:644
#5  0xc1001448 in kernel_init_freeable () at init/main.c:1644
#6  0xc0bc5f18 in kernel_init (unused=&lt;optimized out&gt;) at init/main.c:1519
#7  0xc0100148 in ret_from_fork () at arch/arm/kernel/entry-common.S:148
</pre></div>
</code></pre>
<h3 id="deterministic-ddr-corruption">Deterministic DDR corruption</h3>
<p>Let’s assume that the data corruption is deterministic (repeatable) because it
is caused by a voltage drop. Since the voltage drop corresponds to the CPU/DDR
activity, the same activity causes the same voltage drop, which causes the same
corruption.</p>
<p>Let’s check the same instruction at different supply voltages. At 1.35V, 1.30V,
1.25V, the corruption is:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0x00000000 0xee300f10
</pre></div>
</code></pre>
<p>At 1.20V, the pattern is more interesting: the third instruction gets corrupted
each time, but differently each reset:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xe464f8f6 0xee300f10
# or this one:
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xcbfd2cb6 0xee300f10
# or this one:
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xaefc67e9 0xee300f10
</pre></div>
</code></pre>
<p>Even more strange: restoring voltage back up to 1.35V, the third instruction
now gets corrupted differently every time, while the first and last are always
correct, and the second one is always corrupted the same way.</p>
<h3 id="check-sd-card-and-bootloader-copy-integrity">Check SD card and bootloader copy integrity</h3>
<p>One obvious way that data corruption could happen is the if the compressed
<code>zImage</code> was written wrong to the SD card, or if the bootloader writes it to
DDR wrong. First, we check how big the <code>zImage</code> is, and then ask the debugger
to dump the data from the DDR to a file, at the point just before the handoff
from the bootloader into the decompressor:</p>
<pre><code><div class="codehilite"><pre><span></span>$ ls -l linux/arch/arm/boot/zImage
-rwxr-xr-x 1 jk jk 7461288 Jan  7 11:09 linux/arch/arm/boot/zImage

Breakpoint 1, handoff_jump () at src/handoff.S:93
93         smc #0
(gdb) dump binary memory dump.bin 0xC2000000 0xC271d9a8
</pre></div>
</code></pre>
<p>We see that the original image is identical to the one we obtained from the
dump, so the SD card and bootloader writes are not corrupted:</p>
<pre><code><div class="codehilite"><pre><span></span>9040ec8b8da5e613aa6e56060cc0cacf6779eec670c3a4123177cd07aff63300  zImage
9040ec8b8da5e613aa6e56060cc0cacf6779eec670c3a4123177cd07aff63300  dump.bin
</pre></div>
</code></pre>
<h3 id="test-ddr-using-stm32ddrfw-util">Test DDR using STM32DDRFW-UTIL</h3>
<p>ST provides a <a href="https://github.com/STMicroelectronics/STM32DDRFW-UTIL">utility</a>
which they recommend to run as a part of any new PCB bring-up. I have done that
already and did not think much of it since all tests passed. Let’s take a
closer look.</p>
<p>My “version” of the utility can be found in
<a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/STM32DDRFW-UTIL">this</a>
repository. I made two small changes: instead of requiring the complicated
“Cube” software suite, there is a simple Makefile so that the whole utility can
be compiled easily with a single <code>make</code> invocation. Second, I have commented
out the three or so lines that initialize the STPMIC1, since my board does not
use that power controller.</p>
<p>Let’s load the utility through the debugger, since it is running already:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) file build/fwutil.elf
Reading symbols from build/fwutil.elf...
(gdb) load
Loading section .RESET, size 0xe000 lma 0x2ffe0000
Loading section .ARM, size 0x8 lma 0x2ffee000
Loading section .init_array, size 0x4 lma 0x2ffee008
Loading section .fini_array, size 0x4 lma 0x2ffee00c
Loading section .data, size 0x7fa lma 0x2ffee010
Start address 0x2ffe0000, load size 59402
Transfer rate: 260 KB/sec, 7425 bytes/write.
(gdb) c
Continuing.
</pre></div>
</code></pre>
<p>On the serial console, we are greeted with the expected prompt:</p>
<pre><code><div class="codehilite"><pre><span></span>=============== UTILITIES-DDR Tool ===============
Model: STM32MP13XX_DK
RAM: DDR3-1066 bin F 1x4Gb 533MHz v1.53
0:DDR_RESET
DDR&gt;
</pre></div>
</code></pre>
<p>As the utility readme instructs us, let us enter the <code>DDR_READY</code> step and then
execute all the tests:</p>
<pre><code><div class="codehilite"><pre><span></span>DDR&gt;step 3
step to 3:DDR_READY
1:DDR_CTRL_INIT_DONE
2:DDR_PHY_INIT_DONE
3:DDR_READY
DDR&gt;test 0
result 1:Test Simple DataBus = Passed
result 2:Test DataBusWalking0 = Passed
result 3:Test DataBusWalking1 = Passed
result 4:Test AddressBus = Passed
result 5:Test MemDevice = Passed
result 6:Test SimultaneousSwitchingOutput = Passed
result 7:Test Noise = Passed
result 8:Test NoiseBurst = Passed
result 9:Test Random = Passed
result 10:Test FrequencySelectivePattern = Passed
result 11:Test BlockSequential = Passed
result 12:Test Checkerboard = Passed
result 13:Test BitSpread = Passed
result 14:Test BitFlip = Passed
result 15:Test WalkingZeroes = Passed
result 16:Test WalkingOnes = Passed
Result: Pass [Test All]
</pre></div>
</code></pre>
<p>This takes about a second to complete, and on the scope trace monitoring the
1.35V supply we see a tiny (maybe 2-5mV) dip during this time.</p>
<p>After all the tests are done, we can use the <code>save</code> command to get the DDR
parameters from the utility. Here are the dynamic ones, reporting on the
status:</p>
<pre><code><div class="codehilite"><pre><span></span>/* ctl.dyn */
#define DDR_STAT 0x00000001
#define DDR_INIT0 0x4002004e
#define DDR_DFIMISC 0x00000001
#define DDR_DFISTAT 0x00000001
#define DDR_SWCTL 0x00000001
#define DDR_SWSTAT 0x00000001
#define DDR_PCTRL_0 0x00000001

/* phy.dyn */
#define DDR_PIR 0x00000000
#define DDR_PGSR 0x0000001f
#define DDR_ZQ0SR0 0x80021dee
#define DDR_ZQ0SR1 0x00000000
#define DDR_DX0GSR0 0x00008001
#define DDR_DX0GSR1 0x00000000
#define DDR_DX0DLLCR 0x40000000
#define DDR_DX0DQTR 0xffffffff
#define DDR_DX0DQSTR 0x3db02001
#define DDR_DX1GSR0 0x00008001
#define DDR_DX1GSR1 0x00000000
#define DDR_DX1DLLCR 0x40000000
#define DDR_DX1DQTR 0xffffffff
#define DDR_DX1DQSTR 0x3db02001
</pre></div>
</code></pre>
<p>All the other parameters returned from the utility are identical to the values
already used in the bootloader. Thus, I hope I can assume that the DDR
configuration in the bootloader is identical to the one used in the bootloader.</p>
<h3 id="when-does-data-get-corrupted">When does data get corrupted</h3>
<p>Above we have found that while decompression appears to finish successfully, it
in fact leaves behind lots of partially corrupted data. The uncompressed kernel
starts executing, only the trip into the SVC handler because of a corrupted
instruction. Now, let’s try to track down exactly when the data first gets
corrupted.</p>
<p>As seen above, in the current configuration, decompression takes place in the
<code>__gunzip</code> routine (<code>decompress_inflate.c</code>). The decompression is done by
<code>zlib_inflate()</code> (<code>lib/zlib_inflate/inflate.c</code>). First, clear the memory
location that we’re interested in observing:</p>
<pre><code><div class="codehilite"><pre><span></span>set {unsigned int}0xc0118b2c = 0x0
set {unsigned int}0xc0118b30 = 0x0
set {unsigned int}0xc0118b34 = 0x0
set {unsigned int}0xc0118b38 = 0x0
</pre></div>
</code></pre>
<p>Verify it has been cleared:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0x00000000      0x00000000      0x00000000      0x00000000
</pre></div>
</code></pre>
<p>Some interesting breakpoints:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b *0xc2001878
Breakpoint 20 at 0xc2001878: file arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c, line 63.
(gdb) b *0xc2001fa4
Breakpoint 34 at 0xc2001fa4: file arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c, line 582.
</pre></div>
</code></pre>
<p>As it turns out, the corruption appears after the second call to <code>inflate_fast</code>:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) c
Continuing.

Breakpoint 36, zlib_inflate (strm=0xc271ea44, strm@entry=0xc271e9c0, flush=1072676126, flush@entry=0) at arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c:582
582                     inflate_fast(strm, out);
(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0x00000000      0x00000000      0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 36, zlib_inflate (strm=0xc271ea44, strm@entry=0xc271e9c0, flush=1072590367, flush@entry=0) at arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c:582
582                     inflate_fast(strm, out);
(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0xe3a00000      0x2f400f10      0xffedecfd      0xee300f1
</pre></div>
</code></pre>
<p>While we press <code>c</code> (or <code>continue</code>) in GDB, <code>inflate_fast()</code> runs and very
briefly (about 3.5ms), a voltage drop of about 30–40mV is observed on the
1.35V supply. In the same period, <code>VREF_DDR0</code>, <code>VREF_DDR1</code>, and <code>VREF_DDR2</code>
droops are barely perceptible.</p>
<p>We can go a step further and set a watchpoint, so the debugger triggers on the
first access of the given memory location:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) watch *(uint32_t *)0xc0118b2c
Hardware watchpoint 38: *(uint32_t *)0xc0118b2c
</pre></div>
</code></pre>
<p>Set the memory locations to zero as before, and after the watchpoint triggers,
single step through the execution and each time check the memory. Skipping
ahead many such steps, we see how the value gets progressively filled in:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c:     0xe3a00000      0x00000000      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00000010      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00000f10      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00400f10      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x2f400f10      0x00000000      0x00000000
</pre></div>
</code></pre>
<p>We see how it fills up in steps of half byte: zero, <code>10</code>, <code>0f</code>, <code>40</code>, <code>2f</code>.
That final <code>2f</code> is erroneous; it should be <code>ee</code> as we have seen previously in
the disassembly of <code>vmlinux</code>.</p>
<p>The code loop that populates this word can be found in
<code>lib/zlib_inflate/inffast.c</code>, lines 119 through 308; in particular, the line
that wrote the incorrect <code>2f</code> is number 247, in the middle of this section:</p>
<pre><code><div class="codehilite"><pre><span></span>/* Align out addr */
if (!((long)(out - 1) &amp; 1)) {
   *out++ = *from++;
   len--;
}
</pre></div>
</code></pre>
<h3 id="key-insight-8-bit-corruption">Key insight: 8-bit corruption</h3>
<p>Let’s recap the situation so far. DDR appears to work as far as my own tests
are concerned: I can fill the memory with pseudo-random data and read it all
back correctly. The STM32DDRFW-UTIL tests all pass. The kernel runs if it’s
loaded into memory uncompressed, but the decompression fails. Remembering
further back, when writing the bootloader I had to force all DDR writes to be
32-bit aligned. All of this brings to mind the quote from <a href="https://jaycarlson.net/embedded-linux/">Jay
Carlson</a>:</p>
<blockquote>
<p>if your design <em>doesn’t</em> work, length-tuning is probably the <em>last</em> thing you
should be looking at. For starters, make sure you have all the pins connected
properly — even if the failures appear intermittent. For example, accidentally
swapping byte lane strobes / masks (like I’ve done) will cause 8-bit
operations to fail without affecting 32-bit operations. Since the bulk of RAM
accesses are 32-bit, things will appear to kinda-sorta work.</p>
</blockquote>
<p>Let’s take a good hard look at the connections on my custom board (<a href="https://github.com/js216/stm32mp135_test_board/blob/main/kicad/Rev_A_27may25/schematics.pdf">Rev
A</a>)
between the memory chip (<code>MT41K256M16TW-107:P TR</code>) and the SoC
(<code>STM32MP135FAE</code>):</p>
<table>
<thead>
<tr>
<th>DDR pin</th>
<th>DDR signal</th>
<th>SoC signal</th>
<th>SoC pin</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>M2</code></td>
<td><code>BA0</code></td>
<td><code>BA0</code></td>
<td><code>G17</code></td>
<td></td>
</tr>
<tr>
<td><code>N8</code></td>
<td><code>BA1</code></td>
<td><code>BA1</code></td>
<td><code>L16</code></td>
<td></td>
</tr>
<tr>
<td><code>M3</code></td>
<td><code>BA2</code></td>
<td><code>BA2</code></td>
<td><code>G13</code></td>
<td></td>
</tr>
<tr>
<td><code>N3</code></td>
<td><code>A0</code></td>
<td><code>A0</code></td>
<td><code>G16</code></td>
<td></td>
</tr>
<tr>
<td><code>P7</code></td>
<td><code>A1</code></td>
<td><code>A1</code></td>
<td><code>K15</code></td>
<td></td>
</tr>
<tr>
<td><code>P3</code></td>
<td><code>A2</code></td>
<td><code>A2</code></td>
<td><code>F17</code></td>
<td></td>
</tr>
<tr>
<td><code>N2</code></td>
<td><code>A3</code></td>
<td><code>A3</code></td>
<td><code>G15</code></td>
<td></td>
</tr>
<tr>
<td><code>P8</code></td>
<td><code>A4</code></td>
<td><code>A4</code></td>
<td><code>M14</code></td>
<td></td>
</tr>
<tr>
<td><code>P2</code></td>
<td><code>A5</code></td>
<td><code>A5</code></td>
<td><code>E16</code></td>
<td></td>
</tr>
<tr>
<td><code>R8</code></td>
<td><code>A6</code></td>
<td><code>A6</code></td>
<td><code>M17</code></td>
<td></td>
</tr>
<tr>
<td><code>R2</code></td>
<td><code>A7</code></td>
<td><code>A7</code></td>
<td><code>G14</code></td>
<td></td>
</tr>
<tr>
<td><code>T8</code></td>
<td><code>A8</code></td>
<td><code>A8</code></td>
<td><code>L15</code></td>
<td></td>
</tr>
<tr>
<td><code>R3</code></td>
<td><code>A9</code></td>
<td><code>A9</code></td>
<td><code>F16</code></td>
<td></td>
</tr>
<tr>
<td><code>L7</code></td>
<td><code>A10/AP</code></td>
<td><code>A10</code></td>
<td><code>J14</code></td>
<td></td>
</tr>
<tr>
<td><code>R7</code></td>
<td><code>A11</code></td>
<td><code>A11</code></td>
<td><code>K13</code></td>
<td></td>
</tr>
<tr>
<td><code>N7</code></td>
<td><code>A12/BC#</code></td>
<td><code>A12</code></td>
<td><code>K17</code></td>
<td></td>
</tr>
<tr>
<td><code>T3</code></td>
<td><code>A13</code></td>
<td><code>A13</code></td>
<td><code>F14</code></td>
<td></td>
</tr>
<tr>
<td><code>T7</code></td>
<td><code>A14</code></td>
<td><code>A14</code></td>
<td><code>L17</code></td>
<td></td>
</tr>
<tr>
<td><code>D3</code></td>
<td><code>UDM</code></td>
<td><code>DQM0</code></td>
<td><code>D15</code></td>
<td></td>
</tr>
<tr>
<td><code>E7</code></td>
<td><code>LDM</code></td>
<td><code>DQM1</code></td>
<td><code>N14</code></td>
<td></td>
</tr>
<tr>
<td><code>B7</code></td>
<td><code>UDQS#</code></td>
<td><code>DQS0N</code></td>
<td><code>C16</code></td>
<td></td>
</tr>
<tr>
<td><code>C7</code></td>
<td><code>UDQS</code></td>
<td><code>DQS0P</code></td>
<td><code>C17</code></td>
<td></td>
</tr>
<tr>
<td><code>G3</code></td>
<td><code>LDQS#</code></td>
<td><code>DQS1N</code></td>
<td><code>R16</code></td>
<td></td>
</tr>
<tr>
<td><code>F3</code></td>
<td><code>LDQS</code></td>
<td><code>DQS1P</code></td>
<td><code>R17</code></td>
<td></td>
</tr>
<tr>
<td><code>E3</code></td>
<td><code>DQ0</code></td>
<td><code>DQ4</code></td>
<td><code>B16</code></td>
<td></td>
</tr>
<tr>
<td><code>F7</code></td>
<td><code>DQ1</code></td>
<td><code>DQ2</code></td>
<td><code>C13</code></td>
<td></td>
</tr>
<tr>
<td><code>F2</code></td>
<td><code>DQ2</code></td>
<td><code>DQ0</code></td>
<td><code>B17</code></td>
<td></td>
</tr>
<tr>
<td><code>F8</code></td>
<td><code>DQ3</code></td>
<td><code>DQ5</code></td>
<td><code>D16</code></td>
<td></td>
</tr>
<tr>
<td><code>H3</code></td>
<td><code>DQ4</code></td>
<td><code>DQ3</code></td>
<td><code>D17</code></td>
<td></td>
</tr>
<tr>
<td><code>H8</code></td>
<td><code>DQ5</code></td>
<td><code>DQ7</code></td>
<td><code>E15</code></td>
<td></td>
</tr>
<tr>
<td><code>G2</code></td>
<td><code>DQ6</code></td>
<td><code>DQ1</code></td>
<td><code>C15</code></td>
<td></td>
</tr>
<tr>
<td><code>H7</code></td>
<td><code>DQ7</code></td>
<td><code>DQ6</code></td>
<td><code>E14</code></td>
<td></td>
</tr>
<tr>
<td><code>D7</code></td>
<td><code>DQ8</code></td>
<td><code>DQ8</code></td>
<td><code>N16</code></td>
<td></td>
</tr>
<tr>
<td><code>C3</code></td>
<td><code>DQ9</code></td>
<td><code>DQ9</code></td>
<td><code>P17</code></td>
<td></td>
</tr>
<tr>
<td><code>C8</code></td>
<td><code>DQ10</code></td>
<td><code>DQ10</code></td>
<td><code>N15</code></td>
<td></td>
</tr>
<tr>
<td><code>C2</code></td>
<td><code>DQ11</code></td>
<td><code>DQ15</code></td>
<td><code>T16</code></td>
<td></td>
</tr>
<tr>
<td><code>A7</code></td>
<td><code>DQ12</code></td>
<td><code>DQ11</code></td>
<td><code>P15</code></td>
<td></td>
</tr>
<tr>
<td><code>A2</code></td>
<td><code>DQ13</code></td>
<td><code>DQ12</code></td>
<td><code>R15</code></td>
<td></td>
</tr>
<tr>
<td><code>B8</code></td>
<td><code>DQ14</code></td>
<td><code>DQ13</code></td>
<td><code>P16</code></td>
<td></td>
</tr>
<tr>
<td><code>A3</code></td>
<td><code>DQ15</code></td>
<td><code>DQ14</code></td>
<td><code>T17</code></td>
<td></td>
</tr>
<tr>
<td><code>K3</code></td>
<td><code>CASN</code></td>
<td><code>CASN</code></td>
<td><code>J15</code></td>
<td></td>
</tr>
<tr>
<td><code>K9</code></td>
<td><code>CKE</code></td>
<td><code>CKE</code></td>
<td><code>K14</code></td>
<td>10k pulldown</td>
</tr>
<tr>
<td><code>K7</code></td>
<td><code>CK#</code></td>
<td><code>CLKN</code></td>
<td><code>J17</code></td>
<td>100R to CK at DDR</td>
</tr>
<tr>
<td><code>J7</code></td>
<td><code>CK</code></td>
<td><code>CLKP</code></td>
<td><code>J16</code></td>
<td></td>
</tr>
<tr>
<td><code>L2</code></td>
<td><code>CS#</code></td>
<td><code>CSN</code></td>
<td><code>H16</code></td>
<td></td>
</tr>
<tr>
<td><code>K1</code></td>
<td><code>ODT</code></td>
<td><code>ODT</code></td>
<td><code>H15</code></td>
<td></td>
</tr>
<tr>
<td><code>J3</code></td>
<td><code>RAS#</code></td>
<td><code>RASN</code></td>
<td><code>H17</code></td>
<td></td>
</tr>
<tr>
<td><code>T2</code></td>
<td><code>RESET#</code></td>
<td><code>RESETN</code></td>
<td><code>E17</code></td>
<td>10k pulldown</td>
</tr>
<tr>
<td><code>L3</code></td>
<td><code>WE#</code></td>
<td><code>WEN</code></td>
<td><code>H13</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>Let’s check carefully what the DDR datasheet considers “upper” vs “lower”:</p>
<blockquote>
<p><code>DQ[7:0]</code> Lower byte of bidirectional data bus for the x16 configuration.</p>
<p><code>DQ[15:8]</code> Upper byte of bidirectional data bus for the x16 configuration.</p>
</blockquote>
<p>In other words, we should have mapped <code>DQ[7:0]</code> together with the DDR signals
<code>LDM</code> and <code>LDQS</code>, while the upper byte <code>DQ[15:8]</code> should have been placed
together with <code>UDM</code> and <code>USDQS</code>. Looking at the table above, we see that the
mask/strobe signals are swapped:</p>
<pre><code>DDR:UDM → SoC:DQM0
DDR:LDM → SoC:DQM1
</code></pre>
<p>But the data bits are not swapped, so this is incorrect:</p>
<pre><code>DDR:DQ[7:0]  → SoC[7:0]  (scrambled)
DDR:DQ[15:8] → SoC[15:8] (scrambled)
</code></pre>
<p>My confusion can be traced back to the eval board design, which similarly swaps
the mask/strobe wires, except they also (correctly) swap the two <code>DQ</code> lanes. AI
seems to be of little use: I can easy convince them either way regarding the
correctness of my “semi-byte swap”.</p>
<h3 id="simple-software-test-for-ddr-correctness">Simple software test for DDR correctness</h3>
<p>We saw above that the official ST DDR utility did not detect any problems with
my incorrectly-wired DDR. After some prompting, Gemini 3 gave me the following
test:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ddr_align_test</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg3</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg1</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg2</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sctlr</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 1. READ SCTLR</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mrc p15, 0, %0, c1, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;=r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 2. DISABLE CACHE (Bit 2) AND MMU (Bit 0)</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sctlr_disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sctlr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mcr p15, 0, %0, c1, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr_disabled</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;isb sy&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Instruction sync barrier</span>

<span class="w">    </span><span class="n">my_printf</span><span class="p">(</span><span class="s">&quot;!!! CACHE DISABLED !!! Testing raw hardware wires...</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">p8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xc0001000</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Perform a partial write</span>
<span class="w">    </span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">;</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;dsb sy&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Force pin toggle</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_printf</span><span class="p">(</span><span class="s">&quot;FAILURE DETECTED: Byte 0 is 0x%02x (expected 0xAA)</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_printf</span><span class="p">(</span><span class="s">&quot;SUCCESS: Byte 0 worked without cache.</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 3. RE-ENABLE CACHE</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;mcr p15, 0, %0, c1, c0, 0&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">&quot;isb sy&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>On the evaluation board, the printout is:</p>
<pre><code><div class="codehilite"><pre><span></span>Eval board: !!! CACHE DISABLED !!! Testing raw hardware wires... 
SUCCESS: Byte 0 worked without cache.
</pre></div>
</code></pre>
<p>On my board:</p>
<pre><code><div class="codehilite"><pre><span></span>!!! CACHE DISABLED !!! Testing raw hardware wires...
FAILURE DETECTED: Byte 0 is 0x55 (expected 0xAA)
</pre></div>
</code></pre>
<h3 id="next-steps">Next steps</h3>
<p>While the explanation in the previous section (swapped byte lanes) seems
plausible enough to stop debugging at this point and wait for “Rev B”, in the
process I noted other possible avenues to explore:</p>
<ul>
<li>Lower slew rate / drive strength or increase output impedance, to reduce
crosstalk</li>
<li>Disable data masking entirely, if DDR PHY supports it</li>
<li>Disable cache during decompression?</li>
<li>Try out slower slew-rate settings and increasing output impedance for DDR
controller</li>
<li>Lower DDR frequency and see if the corruption pattern is the same, worse,
better?</li>
<li>Experiment: Run bootloader, Run FWUTIL, Do NOT reset, Jump directly into Linux</li>
<li>Add more capacitance to the VREF nodes (1uF in parallel with the current
0.1uF)</li>
<li>Try to read out from DDR PHY registers the per-byte DQS delays, and per-bit DQ
delays, and compare with PCB geometry</li>
<li>Repeat training again and again and see if there’s any variations (can I
detect training failures?)</li>
<li>Read out write levelling and DQS delay (read leveling) calibration results</li>
<li>My usual CPU-based DDR tests do not uncover a single bit flip, while the
heavily cached kernel decompressor shows huge corruption in the decompressed
output. How to reproduce that in my own code? Could the caches be
misconfigured, so they are somehow inappropriate for my PCB while being fine
on the eval board? Maybe caches don’t do the same kind of training that DDR
does.</li>
</ul>
<h3 id="lsb-swizzling">LSB swizzling</h3>
<p>Just because we found one issue with my connections, it does not mean we have
found all of them. From the <a href="https://jaycarlson.net/embedded-linux/">same</a>
article by Jay Carlson:</p>
<blockquote>
<p>Because DDR memory doesn’t care about the order of the bits getting stored,
you can swap individual bits — except the least-significant one if you’re
using write-leveling — in each byte lane with no issues.</p>
</blockquote>
<p>I have not been able to find any evidence of the LSB swapping restriction in ST
literature (datasheet, reference manual, app notes). Indeed, one app note<sup class="footnote-ref"><a href="#b2182266-fn1" id="b2182266-fnref1">[1]</a></sup>
just says that the DDR3L connection features “two swappable bytes, and swappable
bits in the same byte”.</p>
<p>However, the <code>MT41K</code> DDR3L datasheet includes a section on Write Leveling which
explains what’s up:</p>
<blockquote>
<p>For better signal integrity, DDR3 SDRAM memory modules have adopted fly-by
topology for the commands, addresses, control signals, and clocks. Write
leveling is a scheme for the memory controller to adjust or de-skew the DQS
strobe (DQS, DQS#) to CK relationship at the DRAM with a simple feedback
feature provided by the DRAM.  Write leveling is generally used as part of the
initialization process, if required. For normal DRAM operation, this feature
must be disabled. […]</p>
<p>When write leveling is enabled, the rising edge of DQS samples CK, and the
prime DQ outputs the sampled CK’s status. The prime DQ for a x4 or x8
configuration is DQ0 with all other DQ (DQ[7:1]) driving LOW. The prime DQ for
a x16 configuration is DQ0 for the lower byte and DQ8 for the upper byte.</p>
</blockquote>
<p>So, just in case, we should make sure not to “swizzle” the two LSBs in each
byte.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
  <li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
  <li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
  <li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
  <li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
  <li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
  <li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
  <li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
  <li><em>8. This article</em></li>
</ul>
</div>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="b2182266-fn1" class="footnote-item"><p>Application note AN5692: DDR memory routing guidelines for STM32MP13x
product lines. January 2023. <a href="#b2182266-fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div>

<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>

</body>
</html>
