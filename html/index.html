<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="scary-things-first">Scary Things First</a></h2>
<div class="article-meta">Published 21 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/go.jpg"/></p>
<p>This morning it occurred to me that I’m really not looking forward to going to
the office, for I’ll have to continue doing something that I spent two days on
already, and it’s still not working. I can easily think of many other such
things that I’d rather not do, and as it happens each of them comes with a
“positive”, or attractive aspect (written in brackets):</p>
<ul>
<li>Going out to meet someone, despite being tired after work (but enjoying the
company of a really nice person with a different perspective on life)</li>
<li>Having to separate from loved ones when time comes (but being happy to
be with them for now)</li>
<li>Dying (but being being alive)</li>
</ul>
<p>These are generalized examples; my real list is longer and more specific, but I
won’t bore you with the details since anyone can easily write down their own,
personally relevant version.</p>
<p>The point of these contrasts is not so much that the “bad” part of the stick is
to be borne because the “good” part is worth so much more. The point is not even
to try and forget about the bad part by various means (distraction, expression,
repression, suppression), even though that’s what I end up doing most of the
time. The point is to try and see them as a single “yin-yang” unit: black in
white, white in black.</p>
<p>These contrasts are inevitable, so why waste time fighting them, denying their
existence? Relax into the reality, let go of the fear and dread by feeling it
directly until your brain gets tired of it. I’m not saying, “stop fearing the
inevitable”, as the fear itself is in fact part of the inevitable. The lake
would not try to hide its waves when a stone is thrown into it; its waves
radiate outwards until they stop. In fact they never really stop, so the lake
does not reject them.</p>
<p>Somewhere in the Tao Te Ching it is said that the great power of water (wearing
down mountains, etc.) is because it’s not loath to take the lowest, humblest
part, where no one wants to be. Elsewhere there’s the image of the malformed
tree surviving, while the straight, useful ones are cut down for the carpenter.
I wonder if peace can be had in the face of the above mentioned “dreadful”
future situations by sinking, in each of them, to the most dreadful point.
Assume the most broken, useless mental state: be angry and sad, afraid and
trembling, and watch things come and go. Strength in weakness?</p>
<p>On a practical note: each day, do the “dreadful” thing first to avoid wasting
too much time and effort doing pointless other things. Looking back, avoidance
behaviors are often much more exhausting than what they supposedly protect me
from. Or, in someone’s wise words: “Procrastination is not worth the time it
takes.”</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="lcd-ctp-on-baremetal-stm32mp135">LCD/CTP on Bare-Metal STM32MP135</a></h2>
<div class="article-meta">Published 19 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/lcd.jpg"/></p>
<p>In this writeup we’ll go through the steps needed to bring up the LCD/CTP
peripheral on the <a href="https://github.com/js216/stm32mp135_test_board">custom STM32MP135
board</a>.</p>
<h3 id="connections">Connections</h3>
<p>I am using the Rocktech <code>RK050HR01-CT</code> LCD display, connecting to the
<code>STM32MP135FAE</code> SoC, as follows:</p>
<table>
<thead>
<tr>
<th>LCD pin</th>
<th>LCD signal</th>
<th>SoC signal</th>
<th>SoC pin</th>
<th>Alt. Fn.</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 2</td>
<td><code>VLED+/-</code></td>
<td><code>PB15/TIM1_CH3N</code></td>
<td><code>B12</code></td>
<td>AF1</td>
</tr>
<tr>
<td>8</td>
<td><code>R3</code></td>
<td><code>PB12/LCD_R3</code></td>
<td><code>D9</code></td>
<td>AF13</td>
</tr>
<tr>
<td>9</td>
<td><code>R4</code></td>
<td><code>PE3/LCD_R4</code></td>
<td><code>D13</code></td>
<td>AF13</td>
</tr>
<tr>
<td>10</td>
<td><code>R5</code></td>
<td><code>PF5/LCD_R5</code></td>
<td><code>B2</code></td>
<td>AF14</td>
</tr>
<tr>
<td>11</td>
<td><code>R6</code></td>
<td><code>PF0/LCD_R6</code></td>
<td><code>C13</code></td>
<td>AF13</td>
</tr>
<tr>
<td>12</td>
<td><code>R7</code></td>
<td><code>PF6/LCD_R7</code></td>
<td><code>G2</code></td>
<td>AF13</td>
</tr>
<tr>
<td>15</td>
<td><code>G2</code></td>
<td><code>PF7/LCD_G2</code></td>
<td><code>M1</code></td>
<td>AF14</td>
</tr>
<tr>
<td>16</td>
<td><code>G3</code></td>
<td><code>PE6/LCD_G3</code></td>
<td><code>N1</code></td>
<td>AF14</td>
</tr>
<tr>
<td>17</td>
<td><code>G4</code></td>
<td><code>PG5/LCD_G4</code></td>
<td><code>F2</code></td>
<td>AF11</td>
</tr>
<tr>
<td>18</td>
<td><code>G5</code></td>
<td><code>PG0/LCD_G5</code></td>
<td><code>D7</code></td>
<td>AF14</td>
</tr>
<tr>
<td>19</td>
<td><code>G6</code></td>
<td><code>PA12/LCD_G6</code></td>
<td><code>E3</code></td>
<td>AF14</td>
</tr>
<tr>
<td>20</td>
<td><code>G7</code></td>
<td><code>PA15/LCD_G7</code></td>
<td><code>E6</code></td>
<td>AF11</td>
</tr>
<tr>
<td>24</td>
<td><code>B3</code></td>
<td><code>PG15/LCD_B3</code></td>
<td><code>G4</code></td>
<td>AF14</td>
</tr>
<tr>
<td>25</td>
<td><code>B4</code></td>
<td><code>PB2/LCD_B4</code></td>
<td><code>H4</code></td>
<td>AF14</td>
</tr>
<tr>
<td>26</td>
<td><code>B5</code></td>
<td><code>PH9/LCD_B5</code></td>
<td><code>A9</code></td>
<td>AF9</td>
</tr>
<tr>
<td>27</td>
<td><code>B6</code></td>
<td><code>PF4/LCD_B6</code></td>
<td><code>L2</code></td>
<td>AF13</td>
</tr>
<tr>
<td>28</td>
<td><code>B7</code></td>
<td><code>PB6/LCD_B7</code></td>
<td><code>C1</code></td>
<td>AF14</td>
</tr>
<tr>
<td>30</td>
<td><code>DCLK</code></td>
<td><code>PD9/LCD_CLK</code></td>
<td><code>E8</code></td>
<td>AF13</td>
</tr>
<tr>
<td>31</td>
<td><code>DISP</code></td>
<td><code>PG7</code></td>
<td><code>C9</code></td>
<td>—</td>
</tr>
<tr>
<td>32</td>
<td><code>HSYNC</code></td>
<td><code>PE1/LCD_HSYNC</code></td>
<td><code>B5</code></td>
<td>AF9</td>
</tr>
<tr>
<td>33</td>
<td><code>VSYNC</code></td>
<td><code>PE12/LCD_VSYNC</code></td>
<td><code>B4</code></td>
<td>AF9</td>
</tr>
<tr>
<td>34</td>
<td><code>DE</code></td>
<td><code>PG6/LCD_DE</code></td>
<td><code>A14</code></td>
<td>AF13</td>
</tr>
</tbody>
</table>
<h3 id="backlight">Backlight</h3>
<p>The easiest thing to check is the display backlight, since it’s just a single
GPIO pin to turn on/off, or a simple PWM to control the brightness via the duty
cycle.</p>
<p>In our case, the backlight pin is connected to <code>TIM1_CH3N</code>, which is alternate
function 1:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GPIO_InitTypeDef</span><span class="w"> </span><span class="n">gpio</span><span class="p">;</span>
<span class="n">gpio</span><span class="p">.</span><span class="n">Pin</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_PIN_15</span><span class="p">;</span>
<span class="n">gpio</span><span class="p">.</span><span class="n">Mode</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_MODE_AF_PP</span><span class="p">;</span>
<span class="n">gpio</span><span class="p">.</span><span class="n">Pull</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_NOPULL</span><span class="p">;</span>
<span class="n">gpio</span><span class="p">.</span><span class="n">Speed</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_SPEED_FREQ_LOW</span><span class="p">;</span>
<span class="n">gpio</span><span class="p">.</span><span class="n">Alternate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GPIO_AF1_TIM1</span><span class="p">;</span>
<span class="n">HAL_GPIO_Init</span><span class="p">(</span><span class="n">GPIOB</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">gpio</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>ChatGPT can write the PWM configuration:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">__HAL_RCC_TIM1_CLK_ENABLE</span><span class="p">();</span>

<span class="n">htim1</span><span class="p">.</span><span class="n">Instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIM1</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">Prescaler</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="mi">99U</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">CounterMode</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_COUNTERMODE_UP</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">Period</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mi">999U</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">ClockDivision</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_CLOCKDIVISION_DIV1</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">RepetitionCounter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">AutoReloadPreload</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_AUTORELOAD_PRELOAD_DISABLE</span><span class="p">;</span>
<span class="n">HAL_TIM_PWM_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim1</span><span class="p">);</span>

<span class="n">TIM_OC_InitTypeDef</span><span class="w"> </span><span class="n">oc</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCMode</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCMODE_PWM1</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">Pulse</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">500U</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCPolarity</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCPOLARITY_HIGH</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCNPolarity</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCNPOLARITY_HIGH</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCIdleState</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCIDLESTATE_RESET</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCNIdleState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCNIDLESTATE_RESET</span><span class="p">;</span>
<span class="n">oc</span><span class="p">.</span><span class="n">OCFastMode</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">TIM_OCFAST_DISABLE</span><span class="p">;</span>

<span class="n">HAL_TIM_PWM_ConfigChannel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">oc</span><span class="p">,</span><span class="w"> </span><span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
<span class="n">HAL_TIMEx_PWMN_Start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim1</span><span class="p">,</span><span class="w"> </span><span class="n">TIM_CHANNEL_3</span><span class="p">);</span>
<span class="n">htim1</span><span class="p">.</span><span class="n">Instance</span><span class="o">-&gt;</span><span class="n">BDTR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">TIM_BDTR_MOE</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>The only “tricky” part, or the part that AI got wrong, was that we have to use
<code>HAL_TIMEx_PWMN_Start()</code> instead of <code>HAL_TIM_PWM_Start()</code>, since we’re dealing
with the complementary output. With that fixed, the brightness pin showed a
clean square wave output, with duty cycle adjustable in units of <code>percent</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">__HAL_TIM_SET_COMPARE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htim1</span><span class="p">,</span><span class="w"> </span><span class="n">TIM_CHANNEL_3</span><span class="p">,</span><span class="w"> </span>
<span class="w">      </span><span class="p">(</span><span class="n">htim1</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">Period</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1U</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">percent</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100U</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Unfortunately, the PCB reversed all pins and the connector is single sided, so
we cannot directly check if the above works on the actual display or not.
Nonetheless, we can see a nice 2.088893 kHz square wave with 50 duty cycle, and
we can tune it from 0% to 100%.</p>
<h3 id="ctp-connections">CTP connections</h3>
<p>The Rocktech <code>RK050HR01-CT</code> LCD display includes a capacitive touchpad (CTP),
connecting to the <code>STM32MP135FAE</code> SoC, as follows:</p>
<table>
<thead>
<tr>
<th>CPT pin</th>
<th>CPT signal</th>
<th>SoC signal</th>
<th>SoC pin</th>
<th>Alt. Fn.</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>SCL</code></td>
<td><code>PH13/I2C5_SCL</code></td>
<td><code>A10</code></td>
<td>AF4</td>
</tr>
<tr>
<td>8</td>
<td><code>SDA</code></td>
<td><code>PF3/I2C5_SDA</code></td>
<td><code>B10</code></td>
<td>AF4</td>
</tr>
<tr>
<td>4</td>
<td><code>RST</code></td>
<td><code>PB7</code></td>
<td><code>A4</code></td>
<td>—</td>
</tr>
<tr>
<td>5</td>
<td><code>INT</code></td>
<td><code>PH12</code></td>
<td><code>C2</code></td>
<td>—</td>
</tr>
</tbody>
</table>
<p>Luckily the 6-pin CTP connector, albeit wired in reverse, has contacts on both
top and bottom sides, so we can simply flip the ribbon cable. With entirely
usual I2C configuration it simply works. Check out the final result
<a href="https://github.com/js216/stm32mp135-bootloader/blob/main/src/ctp.c">here</a>.</p>
<p>My GT911 driver is just under 300 lines of code; it’s very interesting that it
takes ST almost 3,000 (yes, it has more features … Whatever, I don’t need
them!)</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>stm32cubemp13-v1-2-0/STM32Cube_FW_MP13_V1.2.0/Drivers/BSP/Components/gt911$<span class="w"> </span>cloc<span class="w"> </span>.
<span class="w">      </span><span class="m">12</span><span class="w"> </span>text<span class="w"> </span>files.
<span class="w">      </span><span class="m">12</span><span class="w"> </span>unique<span class="w"> </span>files.
<span class="w">       </span><span class="m">1</span><span class="w"> </span>file<span class="w"> </span>ignored.

github.com/AlDanial/cloc<span class="w"> </span>v<span class="w"> </span><span class="m">1</span>.90<span class="w">  </span><span class="nv">T</span><span class="o">=</span><span class="m">0</span>.10<span class="w"> </span>s<span class="w"> </span><span class="o">(</span><span class="m">109</span>.2<span class="w"> </span>files/s,<span class="w"> </span><span class="m">48189</span>.3<span class="w"> </span>lines/s<span class="o">)</span>
-------------------------------------------------------------------------------
Language<span class="w">                     </span>files<span class="w">          </span>blank<span class="w">        </span>comment<span class="w">           </span>code
-------------------------------------------------------------------------------
CSS<span class="w">                              </span><span class="m">1</span><span class="w">            </span><span class="m">209</span><span class="w">             </span><span class="m">56</span><span class="w">           </span><span class="m">1446</span>
C<span class="w">                                </span><span class="m">2</span><span class="w">            </span><span class="m">223</span><span class="w">            </span><span class="m">636</span><span class="w">            </span><span class="m">940</span>
C/C++<span class="w"> </span>Header<span class="w">                     </span><span class="m">3</span><span class="w">            </span><span class="m">159</span><span class="w">            </span><span class="m">614</span><span class="w">            </span><span class="m">421</span>
Markdown<span class="w">                         </span><span class="m">2</span><span class="w">             </span><span class="m">24</span><span class="w">              </span><span class="m">0</span><span class="w">             </span><span class="m">62</span>
HTML<span class="w">                             </span><span class="m">1</span><span class="w">              </span><span class="m">0</span><span class="w">              </span><span class="m">3</span><span class="w">             </span><span class="m">56</span>
SVG<span class="w">                              </span><span class="m">2</span><span class="w">              </span><span class="m">0</span><span class="w">              </span><span class="m">0</span><span class="w">              </span><span class="m">4</span>
-------------------------------------------------------------------------------
SUM:<span class="w">                            </span><span class="m">11</span><span class="w">            </span><span class="m">615</span><span class="w">           </span><span class="m">1309</span><span class="w">           </span><span class="m">2929</span>
-------------------------------------------------------------------------------
</pre></div>
</code></pre>
<p>My example code prints out the touch coordinates whenever the touch interrupt
fires. Not much more to do, since the CTP will be used within some application
which will implement more advanced features. The only reason to include this in
the bootloader code is to verify that the I2C connection works.</p>
<h3 id="lcd">LCD</h3>
<p>The custom board is wired backwards, but we can verify that the code is correct
on the eval board. Besides forgetting to turn the <code>LCD_DISP</code> signal on, it all
worked. You set up a framebuffer somewhere (I just used the beginning of the DDR
memory), and write bits there, and magically the picture appears on the display.
For example, to display solid colors:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">lcd_fb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">DRAM_MEM_BASE</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">RK043FN48H_HEIGHT</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">RK043FN48H_WIDTH</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">p</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">RK043FN48H_WIDTH</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3U</span><span class="p">;</span>
<span class="w">      </span><span class="n">lcd_fb</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// blue</span>
<span class="w">      </span><span class="n">lcd_fb</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">;</span><span class="w"> </span><span class="c1">// green</span>
<span class="w">      </span><span class="n">lcd_fb</span><span class="p">[</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="c1">// red</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* make sure CPU writes reach DDR before LTDC reads */</span>
<span class="n">L1C_CleanDCacheAll</span><span class="p">();</span>
</pre></div>
</code></pre>
<h3 id="40-pin-adapter">40-pin adapter</h3>
<p>Making use of an adapter from the 40-pin FFC ribbon cable to jumper wires, we
can verify the signals also on the custom board. We see:</p>
<pre><code>R[3:7] signal when screen set to red, otherwise low
G[3:7] signal when screen set to green, otherwise low
B[3:7] signal when screen set to blue, otherwise low
DCLK:  10 MHz
DISP:  3.3V
HSYNC: 17.6688 kHz, 92.76% duty cycle
VSYNC: 61.779 Hz, 96.5% duty cycle
DE:    16.7--16.9 kHz, ~84% duty cycle
</code></pre>
<p>We can see the brightness change when adjusting the duty cycle of the backlight.</p>
<p>Left ~2/3 of the screen shows white vertical stripes, the exact pattern of these
stripes depending on what “color” the screen is set to. The right ~1/3 of the
screen is black. This is to be expected, since we’re using the same settings for
both displays. Here’s the settings which work fine on the eval board:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="cp">#define LCD_WIDTH  480U </span><span class="c1">// LCD PIXEL WIDTH</span>
<span class="cp">#define LCD_HEIGHT 272U </span><span class="c1">// LCD PIXEL HEIGHT</span>
<span class="cp">#define LCD_HSYNC  41U  </span><span class="c1">// Horizontal synchronization</span>
<span class="cp">#define LCD_HBP    13U  </span><span class="c1">// Horizontal back porch</span>
<span class="cp">#define LCD_HFP    32U  </span><span class="c1">// Horizontal front porch</span>
<span class="cp">#define LCD_VSYNC  10U  </span><span class="c1">// Vertical synchronization</span>
<span class="cp">#define LCD_VBP    2U   </span><span class="c1">// Vertical back porch</span>
<span class="cp">#define LCD_VFP    2U   </span><span class="c1">// Vertical front porch</span>
</pre></div>
</code></pre>
<p>The custom board uses a different display, so let’s try different settings:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="cp">#define LCD_WIDTH   800U</span>
<span class="cp">#define LCD_HEIGHT  480U</span>
<span class="cp">#define LCD_HSYNC   1U</span>
<span class="cp">#define LCD_HBP     8U</span>
<span class="cp">#define LCD_HFP     8U</span>
<span class="cp">#define LCD_VSYNC   1U</span>
<span class="cp">#define LCD_VBP     16U</span>
<span class="cp">#define LCD_VFP     16U</span>
</pre></div>
</code></pre>
<p>Now the screen is totally white, regardless of which color we send it. We notice
that the LCD datasheet specifies a minimum clock frequency of 10 MHz. Note that
on the STM32MP135, the LCD clock comes from <code>PLL4Q</code>. Raising the <code>DCLK</code> to 24
MHz, the screen works! We get to see all the colors. The <code>PLL4</code> configuration
that works for me is</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLState</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">RCC_PLL_ON</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLSource</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RCC_PLL4SOURCE_HSE</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLM</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLN</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLP</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLQ</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLR</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLRGE</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">RCC_PLL4IFRANGE_1</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLFRACV</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">rcc_oscinitstructure</span><span class="p">.</span><span class="n">PLL4</span><span class="p">.</span><span class="n">PLLMODE</span><span class="w">   </span><span class="o">=</span>
<span class="n">RCC_PLL_INTEGER</span><span class="p">;</span>
</pre></div>
</code></pre>
<h3 id="usb-stops-working">USB stops working</h3>
<p>Unfortunately, just as the LCD becomes configured correctly and is able to
display the solid red, green, or blue colors, I noticed that the USB MSC
interface disappeared. If I comment out the LCD init code, so it does not run,
then USB comes back. How could they possibly interact?</p>
<p>Even more interesting, the USB stops working only if <em>both</em> of the following
functions are called: <code>lcd_backlight_init()</code>, which configures the backlight
brightness PWM, and <code>lcd_panel_init()</code>, which does panel timing and pin
configuration.</p>
<p>As it turns out, my 3.3V supply was set with a 0.1A current limit. Having
enabled so many peripherals, the current draw can be a bit higher now.
Increasing the current limit up to 0.2A, and everything works fine. In the
steady state, after init is complete, the board draws just under 0.1A from the
3.3V supply. (For the record, I’m drawing about 0.26A from the combined 1.25V /
1.35V supply.)</p>
<h3 id="conclusion">Conclusion</h3>
<p>Bringing up the LCD on the custom board ultimately came down to matching the
panel’s exact timing and, critically, running the pixel clock within the range
specified by the datasheet. Once the LTDC geometry and <code>PLL4Q</code> frequency were
correct, the display worked immediately, confirming that the signal wiring and
framebuffer logic were sound.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="masks-are-replacable">Masks Are Replaceable</a></h2>
<div class="article-meta">Published 17 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/cor.jpg"/></p>
<p>There are some animals, as well as most plants, that can grow back a lost limb.
Humans are like that in relation to the mask we wear. As soon as we take off a
mask, we begin to grow another one.</p>
<p>When refusing to play a role, one is merely playing a different role.
Nevertheless, this means that one is not stuck with the same role forever; it’s
only a matter of reading a new job description, learning the new skills
required, and assuming the new behaviors.</p>
<p>Identity is a tool, not a prison.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="debugging-stm32mp135-kernel-decompression">Debugging STM32MP135 Kernel Decompression</a></h2>
<div class="article-meta">Published 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/altair.jpg"/></p>
<p><em>This is Part 8 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>My <a href="https://github.com/js216/stm32mp135_test_board">STM32MP135 board</a> includes
DDR3L RAM and initial tests shows that I can fill it up with pseudo-random data
and read it back correctly. ST provides a DDR test
<a href="https://github.com/STMicroelectronics/STM32DDRFW-UTIL">utility</a> with a suite of
memory tests, all of which pass. I decided to take it a step further and test
the memory on a more intensive real-world task: “unzipping” a compressed file.</p>
<h3 id="summary">Summary</h3>
<p>The result of the decompression test was very bad: most of the file was
uncompressed correctly, with just a few bits always wrong, and just a few of
them only sometimes wrong. I spent two or three days tracing my way through the
“unzip” code, instruction by instruction, to try to catch where exactly it goes
wrong.</p>
<p>In the end, I made an embarrassing discovery: I have partially swapped byte
lanes. DDR3L on this SoC has two byte lanes, each consisting of {data, mask,
strobe}. I have connected the data bits correctly, but swapped the mask &amp; strobe
between the two bytes. (Six high speed traces, some on inner layers—there’s no
fixing that by hand.) Had I also swapped the data bits, everything would have
been fine; indeed, the eval board swaps all the wires, which led me astray.
(Partially.)</p>
<p>Sadly, AI was of no help in this instance. Given my DDR3L wiring, I can convince
it either way: the connections are good; the connections are not good. In the
end, only Rev B will tell for sure.</p>
<h3 id="problem-statement">Problem statement</h3>
<p>In this article we will proceed with debugging boot of the compressed Linux
kernel image (<code>zImage</code>) on a <a href="https://github.com/js216/stm32mp135_test_board">custom
board</a> populated with the
STM32MP135 SoC. The starting point will be the build that runs on the
evaluation board as described in the <a href="https://embd.cc/build-linux-for-stm32mp135-in-under-50-lines-of-makefile">previous
article</a>.</p>
<p>Despite booting just fine, the <code>zImage</code> gets stuck on boot on the custom board,
without any messages printed to the UART console. Following along with the
debugger shows that the decompressor code does run, but it’s not clear where
exactly it gets stuck.</p>
<h3 id="power-supply">Power supply</h3>
<p>It is possible that the burst of DDR activity during the high-speed
decompression draws more current than the 1.35V supply is able to provide,
despite the decoupling capacitance.</p>
<p>Indeed, on the scope I see a 30mV drop in the 1.35V supply voltage for about
500ms. However, if I raise the supply voltage by the 30mV, the boot still gets
stuck. This was with kernel being written to 0xC2008000 and the DTB to
0xC4008000, which means that relocation isn’t necessary. My interpretation is
that the scope trace shows that decompression takes about half a second.</p>
<p>Interestingly, if the kernel is written to 0xC0008000 and DTB to 0xC2008000, in
which case relocation is necessary, the 20mV supply drop is shorter, about
150ms, and is followed by 10ms of a bigger drop, 120mV. That drop is indeed
enough to disturb the decompression, since raising the supply voltage setpoint
to 1.38V makes the bigger voltage drop be followed by 500ms of the usual 30mV
drop. My interpretation: relocation takes 150ms, followed by 500ms of
decompression, but the power supply is not stiff enough for
relocation/decompression.</p>
<p>Soldering 1000uF electrolytic capacitors to the 1.25V and 1.35V rails, the
effect is that both relocation and decompression complete (according to the
scope trace, i.e., the 150ms and 500ms voltage drops are visible) with the two
rails at 1.35V, 1.30V, 1.25V, 1.20V, 1.15V, but not below that. Restoring the
supply setpoint to 1.35V, we see that the relocation and decompression complete
as expected.</p>
<p>In order to avoid wasting time with relocation, we will from now on load the
kernel to 0xC2000000 and the device tree to 0xC4000000. The scope trace of the
1.35V rail shows a small voltage drop for 500ms (decompression).</p>
<h3 id="uart-print-during-decompression">UART print during decompression</h3>
<p>It’s not reassuring that we get zero console output during decompression. Trying
to get at least some output, I added <code>CONFIG_DEBUG_LL=y</code> to the <code>.config</code> file
and accepted most of the default options suggested by make:</p>
<pre><code><div class="codehilite"><pre><span></span>Kernel low-level debugging functions (read help!) (DEBUG_LL) [Y/n/?] y
  Kernel low-level debugging port
  &gt; 1. Use STM32MP1 UART for low-level debug (STM32MP1_DEBUG_UART) (NEW)
    2. Kernel low-level debugging via EmbeddedICE DCC channel (DEBUG_ICEDCC) (NEW)
    3. Kernel low-level debug output via semihosting I/O (DEBUG_SEMIHOSTING) (NEW)
    4. Kernel low-level debugging via 8250 UART (DEBUG_LL_UART_8250) (NEW)
    5. Kernel low-level debugging via ARM Ltd PL01x Primecell UART (DEBUG_LL_UART_PL01X) (NEW)
  choice[1-5?]:
Enable flow control (CTS) for the debug UART (DEBUG_UART_FLOW_CONTROL) [N/y/?] (NEW)
Physical base address of debug UART (DEBUG_UART_PHYS) [0x40010000] (NEW)
Virtual base address of debug UART (DEBUG_UART_VIRT) [0xfe010000] (NEW)
Early printk (EARLY_PRINTK) [N/y/?] (NEW) y
Write the current PID to the CONTEXTIDR register (PID_IN_CONTEXTIDR) [N/y/?] n
</pre></div>
</code></pre>
<p>However, no output appeared on the UART. Loading <code>Image</code> (rather than <code>zImage</code>)
produces the early prints, but the decompression hang mystery persists.</p>
<h3 id="jtag">JTAG</h3>
<p>Note: follow along this section with the help of <code>linusw</code>’s article, <a href="https://people.kernel.org/linusw/how-the-arm32-linux-kernel-decompresses">“How the
ARM32 Linux kernel
decompresses”</a>.</p>
<p>Let’s try to follow along the decompression using a J-Link debug probe. First,
open the GDB server and connect to it:</p>
<pre><code><div class="codehilite"><pre><span></span>JLinkGDBServer.exe -device STM32MP135F -if swd -port 2330
arm-none-eabi-gdb.exe -q -x load.gdb
</pre></div>
</code></pre>
<p>Where the <code>load.gdb</code> script contains:</p>
<pre><code><div class="codehilite"><pre><span></span>file build/main.elf
add-symbol-file build/compressed 0xc2000000
target remote localhost:2330
monitor reset
monitor flash device=STM32MP135F
load build/main.elf
monitor go
break handoff.S:93
</pre></div>
</code></pre>
<p>Step instruction a few times till reaching just after the handoff code:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) bt
#0  0xc2000004 in _text () at arch/arm/boot/compressed/head.S:202
</pre></div>
</code></pre>
<p>This shows that execution has begun at the beginning of the decompressor, in
file <code>arch/arm/boot/compressed/head.S</code>, in the <code>start:</code> label. We can step
through the code lines (<code>n</code> command in gdb) until reaching the line <code>bne not_angel</code>, which we have to step into (<code>si</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) si
not_angel () at arch/arm/boot/compressed/head.S:245
245                     safe_svcmode_maskall r0
</pre></div>
</code></pre>
<p>Go forward (<code>n</code>) a few steps till reaching the C function
<code>fdt_check_mem_start()</code> (<code>arch/arm/boot/compressed/fdt_check_mem_start.c</code>), then
call <code>finish</code> to get out of it and continue stepping through the <code>not_angel</code>
section:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) finish
Run till exit from #0  fdt_check_mem_start (mem_start=1, fdt=0xc4000000) at
arch/arm/boot/compressed/fdt_check_mem_start.c:106
not_angel () at arch/arm/boot/compressed/head.S:312
312                     add     r4, r0, #TEXT_OFFSET
Value returned is $3 = 3221225472
(gdb) n
323                     mov     r0, pc
324                     cmp     r0, r4
325                     ldrcc   r0, .Lheadroom
326                     addcc   r0, r0, pc
327                     cmpcc   r4, r0
328                     orrcc   r4, r4, #1              @ remember we skipped cache_on
329                     blcs    cache_on
</pre></div>
</code></pre>
<p>Step into <code>cache_on</code> and later <code>call_cache_fn</code>, and go through the many lines
till reaching the return from <code>__armv7_mmu_cache_on:</code>. Thus we reach the
<code>restart:</code> section:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b 902
Breakpoint 3 at 0xc200055c: file arch/arm/boot/compressed/head.S, line 902.
(gdb) c
Continuing.

Breakpoint 3, __armv7_mmu_cache_on () at arch/arm/boot/compressed/head.S:902
902                     mcr     p15, 0, r0, c7, c5, 4   @ ISB
(gdb) n
903                     mov     pc, r12
(gdb) si
restart () at arch/arm/boot/compressed/head.S:331
331     restart:        adr     r0, LC1
</pre></div>
</code></pre>
<p>Continue stepping through until reaching the <code>wont_overwrite:</code> section, and
then <code>not_relocated:</code>, where we clear BSS. Step through that, and we reach the
beginning of the decompression proper: the <code>decompress_kernel()</code> function in
<code>arch/arm/boot/compressed/misc.c</code>. Interestingly, we step right past the
<code>putstr("Uncompressing Linux...");</code> line without seeing anything printed on the
UART console.</p>
<p>The function <code>decompress_kernel()</code> calls <code>do_decompress()</code>, which calls
<code>__decompress</code> which calls <code>__gunzip</code>. Calling <code>finish</code> on the latter exactly
correlates with the 500ms of the voltage drop observed on the 1.35V supply as
mentioned above. Now we’re back in the <code>decompress_kernel()</code> function, which
should print " done, booting the kernel.\n" (but doesn’t, since there’s
something wrong with my <code>putstr</code> function).</p>
<p>We return back to the <code>not_relocated:</code> section of the compressed <code>head.S</code> and
call <code>get_inflated_image_size</code> to find out how large the decompressed kernel
is:</p>
<pre><code><div class="codehilite"><pre><span></span>not_relocated () at arch/arm/boot/compressed/head.S:636
636                     get_inflated_image_size r1, r2, r3
638                     mov     r0, r4                  @ start of inflated image
639                     add     r1, r1, r0              @ end of inflated image
(gdb) p/x $r0
$3 = 0xc0008000
(gdb) p/x $r1
$4 = 0xc1241f48
(gdb)
</pre></div>
</code></pre>
<p>Subtracting the <code>r1</code> and <code>r0</code> values, we see that the uncompressed kernel is
exactly 19111752 bytes in size, which is identical to the size of the
<code>arch/arm/boot/Image</code> file. So far so good!</p>
<p>Next, the startup code cleans caches and turns them off again and jumps to
<code>__enter_kernel</code> just like we may do directly, had we loaded the uncompressed
image in memory with the bootloader. This places the pointer to the DTB into
<code>r2</code> and passes control to the kernel:</p>
<pre><code><div class="codehilite"><pre><span></span>__enter_kernel () at arch/arm/boot/compressed/head.S:1435
1435                    mov     r0, #0                  @ must be 0
1436                    mov     r1, r7                  @ restore architecture number
1437                    mov     r2, r8                  @ restore atags pointer
1438     ARM(           mov     pc, r4          )       @ call kernel
</pre></div>
</code></pre>
<p>Just before the jump to the kernel, we can check that the register values make
sense: <code>r0</code> and <code>r1</code> are zero, <code>r2</code> has the DTB address, and the decompressed
kernel will run from location <code>0xC0008000</code> (= <code>TEXT_OFFSET</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) p $r0
$5 = 0
(gdb) p $r1
$6 = 0
(gdb) p/x $r2
$8 = 0xc4000000
(gdb) p/x $r4
$9 = 0xc0008000
(gdb)
</pre></div>
</code></pre>
<p>One fateful step and we’re running in the uncompressed kernel proper. Let’s
load the symbols from the main kernel ELF file to see what’s going on:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) si
0xc0008000 in ?? ()
(gdb) add-symbol-file build/vmlinux 0xc0008000
add symbol table from file "build/vmlinux" at
        .text_addr = 0xc0008000
Reading symbols from build/vmlinux...
(gdb)
</pre></div>
</code></pre>
<p>Interesting, just one more step and the debugger stops as some much later point:</p>
<pre><code><div class="codehilite"><pre><span></span>gdb) si
0xc0114620 in perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10836
10836                   hwc-&gt;sample_period = event-&gt;attr.sample_period;
(gdb) bt
#0  0xc0114620 in perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10836
#1  perf_swevent_init_hrtimer (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10818
#2  cpu_clock_event_init (event=0xc0008000 &lt;stext&gt;) at kernel/events/core.c:10902
#3  0xc271e9f0 in ?? ()
</pre></div>
</code></pre>
<p>But if we <code>finish</code> running the <code>perf_swevent_init_hrtimer</code> function, then
somehow we end up back in <code>arch/arm/kernel/head.S</code>. Debugging from that point
onwards appears to have gone totally insane!</p>
<h3 id="decompressor-handoff-to-regular-kernel-code">Decompressor handoff to regular kernel code</h3>
<p>Let’s start again from scratch. Set a breakpoint at the point where the
uncompressed kernel is supposed to begin executing:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b *0xc0008000
Breakpoint 6 at 0xc0008000: file arch/arm/kernel/head.S, line 501.
(gdb) c
Continuing.

Breakpoint 6, stext () at arch/arm/kernel/head.S:501
501             mov     r0, r0
(gdb) p $pc
$11 = (void (*)()) 0xc0008000 &lt;stext&gt;
</pre></div>
</code></pre>
<p>This is strange: program counter is in the expected location, but we’re on line
501 into <code>head.S</code>, rather than closer to the beginning of the file. The reason
is that we have incorrectly instructed GDB that the entire <code>vmlinux</code> starts at
0xC0008000, instead of just the first section. We can fix it by clearing the
symbol file, re-loading the symbols at their natural link address, and
verifying everything makes sense:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) symbol-file
Error in re-setting breakpoint 1: No source file named handoff.S.
No symbol file now.
(gdb) file build/vmlinux
Reading symbols from build/vmlinux...
(gdb) p/x &amp;stext
$15 = 0xc0008000
(gdb) si
__hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
73              store_primary_cpu_mode  r4, r5
(gdb) finish
Run till exit from #0  __hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
stext () at arch/arm/kernel/head.S:105
105             safe_svcmode_maskall r9
</pre></div>
</code></pre>
<p>Now we’re simply running through the beginning of the normal kernel start in
section <code>ENTRY(stext)</code> in file <code>arch/arm/kernel/head.S</code>. By single stepping
through the code, we can find the exact section where things go badly wrong:</p>
<pre><code><div class="codehilite"><pre><span></span>stext () at arch/arm/kernel/head.S:162
162             badr    lr, 1f                          @ return (PIC) address
167             mov     r8, r4                          @ set TTBR1 to swapper_pg_dir
169             ldr     r12, [r10, #PROCINFO_INITFUNC]
170             add     r12, r12, r10
171             ret     r12

__v7_ca7mp_setup () at arch/arm/mm/proc-v7.S:302
302             do_invalidate_l1
0xc01197fc      302             do_invalidate_l1
0xc0119800      302             do_invalidate_l1
0xc0119804      302             do_invalidate_l1

v7_invalidate_l1 () at arch/arm/mm/cache-v7.S:40
40              mov     r0, #0
41              mcr     p15, 2, r0, c0, c0, 0   @ select L1 data cache in CSSELR
(gdb)
0x2fff2f08 in ?? ()
</pre></div>
</code></pre>
<p>We see that after the last <code>mcr</code> instruction, the code lands up in SYSRAM
instead of the DDR, from where we’ve been executing so far. That address
corresponds to the vectors as have been installed by the bootloader; in
particular, we have gotten into the dummy SVC handler.</p>
<p>Let’s examine the program instructions at the point just before where the
failure occurs:</p>
<pre><code><div class="codehilite"><pre><span></span>Breakpoint 7, v7_invalidate_l1 () at arch/arm/mm/cache-v7.S:40
40              mov     r0, #0
(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0x2f400f10      0xffffffff      0xee300f10
</pre></div>
</code></pre>
<p>Very interesting! The expected instruction, <code>0xe3a00000</code>, is followed by
<code>0x2f400f10</code> and <code>0xffffffff</code>. The first one is the “mystery” SVC call, and the second one
is simply undefined:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) set {int}0xc0000000 = 0x2f400f10
(gdb) x/i 0xc0000000
   0xc0000000:  svccs   0x00400f10
(gdb) set {int}0xc0000000 = 0xffffffff
(gdb) x/i 0xc0000000
   0xc0000000:                  @ &lt;UNDEFINED&gt; instruction: 0xffffffff
</pre></div>
</code></pre>
<p>For comparison, here’s the instructions we expect to find from the disassembly
of the ELF file:</p>
<pre><code><div class="codehilite"><pre><span></span>$ arm-linux-gnueabi-objdump -d linux/vmlinux | grep -A 4 "v7_invalidate_l1"
c0118b2c &lt;v7_invalidate_l1&gt;:
c0118b2c:       e3a00000        mov     r0, #0
c0118b30:       ee400f10        mcr     15, 2, r0, cr0, cr0, {0}
c0118b34:       f57ff06f        isb     sy
c0118b38:       ee300f10        mrc     15, 1, r0, cr0, cr0, {0}
</pre></div>
</code></pre>
<h3 id="ddr-corruption-pattern">DDR corruption pattern</h3>
<p>Let’s compare the binary pattern between the expected and actual instructions:</p>
<pre><code><div class="codehilite"><pre><span></span>Expected: 0xee400f10 = 0b11101110010000000000111100010000
Actual:   0x2f400f10 = 0b00101111010000000000111100010000
---------------------------------------------------------
Diff:       ^^           ^^     ^
</pre></div>
</code></pre>
<p>Three bits have been flipped in this instruction, changing it from <code>mcr</code> to
<code>svc</code>. This could be explained if DDR is miswired or misconfigured. However,
the pattern of data corruption is repeatable: reboot after reboot, the same
instruction gets corrupted in exactly the same way!</p>
<p>To prove that the DDR is capable of holding data at this address, we can write
it manually and step through the instructions without any weird jumps to
vectors:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0x2f400f10      0xffffffff      0xee300f10
(gdb) set {int}0xc0118b30 = 0xee400f10
(gdb) set {int}0xc0118b34 = 0xf57ff06f
(gdb) x/4x $pc
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000      0xee400f10      0xf57ff06f      0xee300f10
(gdb) si
41              mcr     p15, 2, r0, c0, c0, 0   @ select L1 data cache in CSSELR
42              isb
43              mrc     p15, 1, r0, c0, c0, 0   @ read cache geometry from CCSIDR
45              movw    r3, #0x3ff
</pre></div>
</code></pre>
<p>We can also load and run the decompressor as usual and set a breakpoint to
0xC0008000, where the uncompressed kernel is supposed to take over. Then, we
simply overwrite whatever the decompressor has written from gdb:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) restore build/Image binary 0xc0008000
Restoring binary file build/Image into memory (0xc0008000 to 0xc1241f48)
(gdb) c
</pre></div>
</code></pre>
<p>Nothing has been printed to the console, since apparently the decompressor
disabled the console, but if we stop the debugger (Ctrl-C), we see that the
kernel proceeded with the boot and finally came to a stop when mounting the
root filesystem (understandable, since we haven’t given it a rootfs yet):</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) bt
#0  0xc0b87034 in __timer_delay (cycles=63999) at arch/arm/lib/delay.c:50
#1  0xc0bb2238 in panic (fmt=0xc0defa0c "VFS: Unable to mount root fs on %s") at kernel/panic.c:451
#2  0xc1001878 in mount_block_root (name=0x51 &lt;error: Cannot access memory at address 0x51&gt;, name@entry=0xc0defaa0 "/dev/root", flags=3900) at init/do_mounts.c:432
#3  0xc1001b50 in mount_root () at init/do_mounts.c:592
#4  0xc1001cc8 in prepare_namespace () at init/do_mounts.c:644
#5  0xc1001448 in kernel_init_freeable () at init/main.c:1644
#6  0xc0bc5f18 in kernel_init (unused=&lt;optimized out&gt;) at init/main.c:1519
#7  0xc0100148 in ret_from_fork () at arch/arm/kernel/entry-common.S:148
</pre></div>
</code></pre>
<h3 id="deterministic-ddr-corruption">Deterministic DDR corruption</h3>
<p>Let’s assume that the data corruption is deterministic (repeatable) because it
is caused by a voltage drop. Since the voltage drop corresponds to the CPU/DDR
activity, the same activity causes the same voltage drop, which causes the same
corruption.</p>
<p>Let’s check the same instruction at different supply voltages. At 1.35V, 1.30V,
1.25V, the corruption is:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0x00000000 0xee300f10
</pre></div>
</code></pre>
<p>At 1.20V, the pattern is more interesting: the third instruction gets corrupted
each time, but differently each reset:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xe464f8f6 0xee300f10
# or this one:
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xcbfd2cb6 0xee300f10
# or this one:
0xc0118b2c &lt;v7_invalidate_l1&gt;:  0xe3a00000 0x2f400f10 0xaefc67e9 0xee300f10
</pre></div>
</code></pre>
<p>Even more strange: restoring voltage back up to 1.35V, the third instruction
now gets corrupted differently every time, while the first and last are always
correct, and the second one is always corrupted the same way.</p>
<h3 id="check-sd-card-and-bootloader-copy-integrity">Check SD card and bootloader copy integrity</h3>
<p>One obvious way that data corruption could happen is the if the compressed
<code>zImage</code> was written wrong to the SD card, or if the bootloader writes it to
DDR wrong. First, we check how big the <code>zImage</code> is, and then ask the debugger
to dump the data from the DDR to a file, at the point just before the handoff
from the bootloader into the decompressor:</p>
<pre><code><div class="codehilite"><pre><span></span>$ ls -l linux/arch/arm/boot/zImage
-rwxr-xr-x 1 jk jk 7461288 Jan  7 11:09 linux/arch/arm/boot/zImage

Breakpoint 1, handoff_jump () at src/handoff.S:93
93         smc #0
(gdb) dump binary memory dump.bin 0xC2000000 0xC271d9a8
</pre></div>
</code></pre>
<p>We see that the original image is identical to the one we obtained from the
dump, so the SD card and bootloader writes are not corrupted:</p>
<pre><code><div class="codehilite"><pre><span></span>9040ec8b8da5e613aa6e56060cc0cacf6779eec670c3a4123177cd07aff63300  zImage
9040ec8b8da5e613aa6e56060cc0cacf6779eec670c3a4123177cd07aff63300  dump.bin
</pre></div>
</code></pre>
<h3 id="test-ddr-using-stm32ddrfw-util">Test DDR using STM32DDRFW-UTIL</h3>
<p>ST provides a <a href="https://github.com/STMicroelectronics/STM32DDRFW-UTIL">utility</a>
which they recommend to run as a part of any new PCB bring-up. I have done that
already and did not think much of it since all tests passed. Let’s take a
closer look.</p>
<p>My “version” of the utility can be found in
<a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/STM32DDRFW-UTIL">this</a>
repository. I made two small changes: instead of requiring the complicated
“Cube” software suite, there is a simple Makefile so that the whole utility can
be compiled easily with a single <code>make</code> invocation. Second, I have commented
out the three or so lines that initialize the STPMIC1, since my board does not
use that power controller.</p>
<p>Let’s load the utility through the debugger, since it is running already:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) file build/fwutil.elf
Reading symbols from build/fwutil.elf...
(gdb) load
Loading section .RESET, size 0xe000 lma 0x2ffe0000
Loading section .ARM, size 0x8 lma 0x2ffee000
Loading section .init_array, size 0x4 lma 0x2ffee008
Loading section .fini_array, size 0x4 lma 0x2ffee00c
Loading section .data, size 0x7fa lma 0x2ffee010
Start address 0x2ffe0000, load size 59402
Transfer rate: 260 KB/sec, 7425 bytes/write.
(gdb) c
Continuing.
</pre></div>
</code></pre>
<p>On the serial console, we are greeted with the expected prompt:</p>
<pre><code><div class="codehilite"><pre><span></span>=============== UTILITIES-DDR Tool ===============
Model: STM32MP13XX_DK
RAM: DDR3-1066 bin F 1x4Gb 533MHz v1.53
0:DDR_RESET
DDR&gt;
</pre></div>
</code></pre>
<p>As the utility readme instructs us, let us enter the <code>DDR_READY</code> step and then
execute all the tests:</p>
<pre><code><div class="codehilite"><pre><span></span>DDR&gt;step 3
step to 3:DDR_READY
1:DDR_CTRL_INIT_DONE
2:DDR_PHY_INIT_DONE
3:DDR_READY
DDR&gt;test 0
result 1:Test Simple DataBus = Passed
result 2:Test DataBusWalking0 = Passed
result 3:Test DataBusWalking1 = Passed
result 4:Test AddressBus = Passed
result 5:Test MemDevice = Passed
result 6:Test SimultaneousSwitchingOutput = Passed
result 7:Test Noise = Passed
result 8:Test NoiseBurst = Passed
result 9:Test Random = Passed
result 10:Test FrequencySelectivePattern = Passed
result 11:Test BlockSequential = Passed
result 12:Test Checkerboard = Passed
result 13:Test BitSpread = Passed
result 14:Test BitFlip = Passed
result 15:Test WalkingZeroes = Passed
result 16:Test WalkingOnes = Passed
Result: Pass [Test All]
</pre></div>
</code></pre>
<p>This takes about a second to complete, and on the scope trace monitoring the
1.35V supply we see a tiny (maybe 2-5mV) dip during this time.</p>
<p>After all the tests are done, we can use the <code>save</code> command to get the DDR
parameters from the utility. Here are the dynamic ones, reporting on the
status:</p>
<pre><code><div class="codehilite"><pre><span></span>/* ctl.dyn */
#define DDR_STAT 0x00000001
#define DDR_INIT0 0x4002004e
#define DDR_DFIMISC 0x00000001
#define DDR_DFISTAT 0x00000001
#define DDR_SWCTL 0x00000001
#define DDR_SWSTAT 0x00000001
#define DDR_PCTRL_0 0x00000001

/* phy.dyn */
#define DDR_PIR 0x00000000
#define DDR_PGSR 0x0000001f
#define DDR_ZQ0SR0 0x80021dee
#define DDR_ZQ0SR1 0x00000000
#define DDR_DX0GSR0 0x00008001
#define DDR_DX0GSR1 0x00000000
#define DDR_DX0DLLCR 0x40000000
#define DDR_DX0DQTR 0xffffffff
#define DDR_DX0DQSTR 0x3db02001
#define DDR_DX1GSR0 0x00008001
#define DDR_DX1GSR1 0x00000000
#define DDR_DX1DLLCR 0x40000000
#define DDR_DX1DQTR 0xffffffff
#define DDR_DX1DQSTR 0x3db02001
</pre></div>
</code></pre>
<p>All the other parameters returned from the utility are identical to the values
already used in the bootloader. Thus, I hope I can assume that the DDR
configuration in the bootloader is identical to the one used in the bootloader.</p>
<h3 id="when-does-data-get-corrupted">When does data get corrupted</h3>
<p>Above we have found that while decompression appears to finish successfully, it
in fact leaves behind lots of partially corrupted data. The uncompressed kernel
starts executing, only the trip into the SVC handler because of a corrupted
instruction. Now, let’s try to track down exactly when the data first gets
corrupted.</p>
<p>As seen above, in the current configuration, decompression takes place in the
<code>__gunzip</code> routine (<code>decompress_inflate.c</code>). The decompression is done by
<code>zlib_inflate()</code> (<code>lib/zlib_inflate/inflate.c</code>). First, clear the memory
location that we’re interested in observing:</p>
<pre><code><div class="codehilite"><pre><span></span>set {unsigned int}0xc0118b2c = 0x0
set {unsigned int}0xc0118b30 = 0x0
set {unsigned int}0xc0118b34 = 0x0
set {unsigned int}0xc0118b38 = 0x0
</pre></div>
</code></pre>
<p>Verify it has been cleared:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0x00000000      0x00000000      0x00000000      0x00000000
</pre></div>
</code></pre>
<p>Some interesting breakpoints:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) b *0xc2001878
Breakpoint 20 at 0xc2001878: file arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c, line 63.
(gdb) b *0xc2001fa4
Breakpoint 34 at 0xc2001fa4: file arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c, line 582.
</pre></div>
</code></pre>
<p>As it turns out, the corruption appears after the second call to <code>inflate_fast</code>:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) c
Continuing.

Breakpoint 36, zlib_inflate (strm=0xc271ea44, strm@entry=0xc271e9c0, flush=1072676126, flush@entry=0) at arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c:582
582                     inflate_fast(strm, out);
(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0x00000000      0x00000000      0x00000000      0x00000000
(gdb) c
Continuing.

Breakpoint 36, zlib_inflate (strm=0xc271ea44, strm@entry=0xc271e9c0, flush=1072590367, flush@entry=0) at arch/arm/boot/compressed/../../../../lib/zlib_inflate/inflate.c:582
582                     inflate_fast(strm, out);
(gdb) x/4x 0xc0118b2c
0xc0118b2c:     0xe3a00000      0x2f400f10      0xffedecfd      0xee300f1
</pre></div>
</code></pre>
<p>While we press <code>c</code> (or <code>continue</code>) in GDB, <code>inflate_fast()</code> runs and very
briefly (about 3.5ms), a voltage drop of about 30–40mV is observed on the
1.35V supply. In the same period, <code>VREF_DDR0</code>, <code>VREF_DDR1</code>, and <code>VREF_DDR2</code>
droops are barely perceptible.</p>
<p>We can go a step further and set a watchpoint, so the debugger triggers on the
first access of the given memory location:</p>
<pre><code><div class="codehilite"><pre><span></span>(gdb) watch *(uint32_t *)0xc0118b2c
Hardware watchpoint 38: *(uint32_t *)0xc0118b2c
</pre></div>
</code></pre>
<p>Set the memory locations to zero as before, and after the watchpoint triggers,
single step through the execution and each time check the memory. Skipping
ahead many such steps, we see how the value gets progressively filled in:</p>
<pre><code><div class="codehilite"><pre><span></span>0xc0118b2c:     0xe3a00000      0x00000000      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00000010      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00000f10      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x00400f10      0x00000000      0x00000000
0xc0118b2c:     0xe3a00000      0x2f400f10      0x00000000      0x00000000
</pre></div>
</code></pre>
<p>We see how it fills up in steps of half byte: zero, <code>10</code>, <code>0f</code>, <code>40</code>, <code>2f</code>.
That final <code>2f</code> is erroneous; it should be <code>ee</code> as we have seen previously in
the disassembly of <code>vmlinux</code>.</p>
<p>The code loop that populates this word can be found in
<code>lib/zlib_inflate/inffast.c</code>, lines 119 through 308; in particular, the line
that wrote the incorrect <code>2f</code> is number 247, in the middle of this section:</p>
<pre><code><div class="codehilite"><pre><span></span>/* Align out addr */
if (!((long)(out - 1) &amp; 1)) {
   *out++ = *from++;
   len--;
}
</pre></div>
</code></pre>
<h3 id="key-insight-8-bit-corruption">Key insight: 8-bit corruption</h3>
<p>Let’s recap the situation so far. DDR appears to work as far as my own tests
are concerned: I can fill the memory with pseudo-random data and read it all
back correctly. The STM32DDRFW-UTIL tests all pass. The kernel runs if it’s
loaded into memory uncompressed, but the decompression fails. Remembering
further back, when writing the bootloader I had to force all DDR writes to be
32-bit aligned. All of this brings to mind the quote from <a href="https://jaycarlson.net/embedded-linux/">Jay
Carlson</a>:</p>
<blockquote>
<p>if your design <em>doesn’t</em> work, length-tuning is probably the <em>last</em> thing you
should be looking at. For starters, make sure you have all the pins connected
properly — even if the failures appear intermittent. For example, accidentally
swapping byte lane strobes / masks (like I’ve done) will cause 8-bit
operations to fail without affecting 32-bit operations. Since the bulk of RAM
accesses are 32-bit, things will appear to kinda-sorta work.</p>
</blockquote>
<p>Let’s take a good hard look at the connections on my custom board (<a href="https://github.com/js216/stm32mp135_test_board/blob/main/kicad/Rev_A_27may25/schematics.pdf">Rev
A</a>)
between the memory chip (<code>MT41K256M16TW-107:P TR</code>) and the SoC
(<code>STM32MP135FAE</code>):</p>
<table>
<thead>
<tr>
<th>DDR pin</th>
<th>DDR signal</th>
<th>SoC signal</th>
<th>SoC pin</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>M2</code></td>
<td><code>BA0</code></td>
<td><code>BA0</code></td>
<td><code>G17</code></td>
<td></td>
</tr>
<tr>
<td><code>N8</code></td>
<td><code>BA1</code></td>
<td><code>BA1</code></td>
<td><code>L16</code></td>
<td></td>
</tr>
<tr>
<td><code>M3</code></td>
<td><code>BA2</code></td>
<td><code>BA2</code></td>
<td><code>G13</code></td>
<td></td>
</tr>
<tr>
<td><code>N3</code></td>
<td><code>A0</code></td>
<td><code>A0</code></td>
<td><code>G16</code></td>
<td></td>
</tr>
<tr>
<td><code>P7</code></td>
<td><code>A1</code></td>
<td><code>A1</code></td>
<td><code>K15</code></td>
<td></td>
</tr>
<tr>
<td><code>P3</code></td>
<td><code>A2</code></td>
<td><code>A2</code></td>
<td><code>F17</code></td>
<td></td>
</tr>
<tr>
<td><code>N2</code></td>
<td><code>A3</code></td>
<td><code>A3</code></td>
<td><code>G15</code></td>
<td></td>
</tr>
<tr>
<td><code>P8</code></td>
<td><code>A4</code></td>
<td><code>A4</code></td>
<td><code>M14</code></td>
<td></td>
</tr>
<tr>
<td><code>P2</code></td>
<td><code>A5</code></td>
<td><code>A5</code></td>
<td><code>E16</code></td>
<td></td>
</tr>
<tr>
<td><code>R8</code></td>
<td><code>A6</code></td>
<td><code>A6</code></td>
<td><code>M17</code></td>
<td></td>
</tr>
<tr>
<td><code>R2</code></td>
<td><code>A7</code></td>
<td><code>A7</code></td>
<td><code>G14</code></td>
<td></td>
</tr>
<tr>
<td><code>T8</code></td>
<td><code>A8</code></td>
<td><code>A8</code></td>
<td><code>L15</code></td>
<td></td>
</tr>
<tr>
<td><code>R3</code></td>
<td><code>A9</code></td>
<td><code>A9</code></td>
<td><code>F16</code></td>
<td></td>
</tr>
<tr>
<td><code>L7</code></td>
<td><code>A10/AP</code></td>
<td><code>A10</code></td>
<td><code>J14</code></td>
<td></td>
</tr>
<tr>
<td><code>R7</code></td>
<td><code>A11</code></td>
<td><code>A11</code></td>
<td><code>K13</code></td>
<td></td>
</tr>
<tr>
<td><code>N7</code></td>
<td><code>A12/BC#</code></td>
<td><code>A12</code></td>
<td><code>K17</code></td>
<td></td>
</tr>
<tr>
<td><code>T3</code></td>
<td><code>A13</code></td>
<td><code>A13</code></td>
<td><code>F14</code></td>
<td></td>
</tr>
<tr>
<td><code>T7</code></td>
<td><code>A14</code></td>
<td><code>A14</code></td>
<td><code>L17</code></td>
<td></td>
</tr>
<tr>
<td><code>D3</code></td>
<td><code>UDM</code></td>
<td><code>DQM0</code></td>
<td><code>D15</code></td>
<td></td>
</tr>
<tr>
<td><code>E7</code></td>
<td><code>LDM</code></td>
<td><code>DQM1</code></td>
<td><code>N14</code></td>
<td></td>
</tr>
<tr>
<td><code>B7</code></td>
<td><code>UDQS#</code></td>
<td><code>DQS0N</code></td>
<td><code>C16</code></td>
<td></td>
</tr>
<tr>
<td><code>C7</code></td>
<td><code>UDQS</code></td>
<td><code>DQS0P</code></td>
<td><code>C17</code></td>
<td></td>
</tr>
<tr>
<td><code>G3</code></td>
<td><code>LDQS#</code></td>
<td><code>DQS1N</code></td>
<td><code>R16</code></td>
<td></td>
</tr>
<tr>
<td><code>F3</code></td>
<td><code>LDQS</code></td>
<td><code>DQS1P</code></td>
<td><code>R17</code></td>
<td></td>
</tr>
<tr>
<td><code>E3</code></td>
<td><code>DQ0</code></td>
<td><code>DQ4</code></td>
<td><code>B16</code></td>
<td></td>
</tr>
<tr>
<td><code>F7</code></td>
<td><code>DQ1</code></td>
<td><code>DQ2</code></td>
<td><code>C13</code></td>
<td></td>
</tr>
<tr>
<td><code>F2</code></td>
<td><code>DQ2</code></td>
<td><code>DQ0</code></td>
<td><code>B17</code></td>
<td></td>
</tr>
<tr>
<td><code>F8</code></td>
<td><code>DQ3</code></td>
<td><code>DQ5</code></td>
<td><code>D16</code></td>
<td></td>
</tr>
<tr>
<td><code>H3</code></td>
<td><code>DQ4</code></td>
<td><code>DQ3</code></td>
<td><code>D17</code></td>
<td></td>
</tr>
<tr>
<td><code>H8</code></td>
<td><code>DQ5</code></td>
<td><code>DQ7</code></td>
<td><code>E15</code></td>
<td></td>
</tr>
<tr>
<td><code>G2</code></td>
<td><code>DQ6</code></td>
<td><code>DQ1</code></td>
<td><code>C15</code></td>
<td></td>
</tr>
<tr>
<td><code>H7</code></td>
<td><code>DQ7</code></td>
<td><code>DQ6</code></td>
<td><code>E14</code></td>
<td></td>
</tr>
<tr>
<td><code>D7</code></td>
<td><code>DQ8</code></td>
<td><code>DQ8</code></td>
<td><code>N16</code></td>
<td></td>
</tr>
<tr>
<td><code>C3</code></td>
<td><code>DQ9</code></td>
<td><code>DQ9</code></td>
<td><code>P17</code></td>
<td></td>
</tr>
<tr>
<td><code>C8</code></td>
<td><code>DQ10</code></td>
<td><code>DQ10</code></td>
<td><code>N15</code></td>
<td></td>
</tr>
<tr>
<td><code>C2</code></td>
<td><code>DQ11</code></td>
<td><code>DQ15</code></td>
<td><code>T16</code></td>
<td></td>
</tr>
<tr>
<td><code>A7</code></td>
<td><code>DQ12</code></td>
<td><code>DQ11</code></td>
<td><code>P15</code></td>
<td></td>
</tr>
<tr>
<td><code>A2</code></td>
<td><code>DQ13</code></td>
<td><code>DQ12</code></td>
<td><code>R15</code></td>
<td></td>
</tr>
<tr>
<td><code>B8</code></td>
<td><code>DQ14</code></td>
<td><code>DQ13</code></td>
<td><code>P16</code></td>
<td></td>
</tr>
<tr>
<td><code>A3</code></td>
<td><code>DQ15</code></td>
<td><code>DQ14</code></td>
<td><code>T17</code></td>
<td></td>
</tr>
<tr>
<td><code>K3</code></td>
<td><code>CASN</code></td>
<td><code>CASN</code></td>
<td><code>J15</code></td>
<td></td>
</tr>
<tr>
<td><code>K9</code></td>
<td><code>CKE</code></td>
<td><code>CKE</code></td>
<td><code>K14</code></td>
<td>10k pulldown</td>
</tr>
<tr>
<td><code>K7</code></td>
<td><code>CK#</code></td>
<td><code>CLKN</code></td>
<td><code>J17</code></td>
<td>100R to CK at DDR</td>
</tr>
<tr>
<td><code>J7</code></td>
<td><code>CK</code></td>
<td><code>CLKP</code></td>
<td><code>J16</code></td>
<td></td>
</tr>
<tr>
<td><code>L2</code></td>
<td><code>CS#</code></td>
<td><code>CSN</code></td>
<td><code>H16</code></td>
<td></td>
</tr>
<tr>
<td><code>K1</code></td>
<td><code>ODT</code></td>
<td><code>ODT</code></td>
<td><code>H15</code></td>
<td></td>
</tr>
<tr>
<td><code>J3</code></td>
<td><code>RAS#</code></td>
<td><code>RASN</code></td>
<td><code>H17</code></td>
<td></td>
</tr>
<tr>
<td><code>T2</code></td>
<td><code>RESET#</code></td>
<td><code>RESETN</code></td>
<td><code>E17</code></td>
<td>10k pulldown</td>
</tr>
<tr>
<td><code>L3</code></td>
<td><code>WE#</code></td>
<td><code>WEN</code></td>
<td><code>H13</code></td>
<td></td>
</tr>
</tbody>
</table>
<p>Let’s check carefully what the DDR datasheet considers “upper” vs “lower”:</p>
<blockquote>
<p><code>DQ[7:0]</code> Lower byte of bidirectional data bus for the x16 configuration.</p>
<p><code>DQ[15:8]</code> Upper byte of bidirectional data bus for the x16 configuration.</p>
</blockquote>
<p>In other words, we should have mapped <code>DQ[7:0]</code> together with the DDR signals
<code>LDM</code> and <code>LDQS</code>, while the upper byte <code>DQ[15:8]</code> should have been placed
together with <code>UDM</code> and <code>USDQS</code>. Looking at the table above, we see that the
mask/strobe signals are swapped:</p>
<pre><code>DDR:UDM → SoC:DQM0
DDR:LDM → SoC:DQM1
</code></pre>
<p>But the data bits are not swapped, so this is incorrect:</p>
<pre><code>DDR:DQ[7:0]  → SoC[7:0]  (scrambled)
DDR:DQ[15:8] → SoC[15:8] (scrambled)
</code></pre>
<p>My confusion can be traced back to the eval board design, which similarly swaps
the mask/strobe wires, except they also (correctly) swap the two <code>DQ</code> lanes. AI
seems to be of little use: I can easy convince them either way regarding the
correctness of my “semi-byte swap”.</p>
<h3 id="simple-software-test-for-ddr-correctness">Simple software test for DDR correctness</h3>
<p>We saw above that the official ST DDR utility did not detect any problems with
my incorrectly-wired DDR. After some prompting, Gemini 3 gave me the following
test:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ddr_align_test</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg3</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg1</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg2</span><span class="p">;</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">arg3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sctlr</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 1. READ SCTLR</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mrc p15, 0, %0, c1, c0, 0"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"=r"</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 2. DISABLE CACHE (Bit 2) AND MMU (Bit 0)</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sctlr_disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sctlr</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mcr p15, 0, %0, c1, c0, 0"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"r"</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr_disabled</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"isb sy"</span><span class="p">);</span><span class="w"> </span><span class="c1">// Instruction sync barrier</span>

<span class="w">    </span><span class="n">my_printf</span><span class="p">(</span><span class="s">"!!! CACHE DISABLED !!! Testing raw hardware wires...</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>

<span class="w">    </span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">p8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mh">0xc0001000</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Perform a partial write</span>
<span class="w">    </span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">;</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"dsb sy"</span><span class="p">);</span><span class="w"> </span><span class="c1">// Force pin toggle</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xAA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_printf</span><span class="p">(</span><span class="s">"FAILURE DETECTED: Byte 0 is 0x%02x (expected 0xAA)</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">p8</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">my_printf</span><span class="p">(</span><span class="s">"SUCCESS: Byte 0 worked without cache.</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 3. RE-ENABLE CACHE</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mcr p15, 0, %0, c1, c0, 0"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"r"</span><span class="w"> </span><span class="p">(</span><span class="n">sctlr</span><span class="p">));</span>
<span class="w">    </span><span class="n">__asm__</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"isb sy"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>On the evaluation board, the printout is:</p>
<pre><code><div class="codehilite"><pre><span></span>Eval board: !!! CACHE DISABLED !!! Testing raw hardware wires... 
SUCCESS: Byte 0 worked without cache.
</pre></div>
</code></pre>
<p>On my board:</p>
<pre><code><div class="codehilite"><pre><span></span>!!! CACHE DISABLED !!! Testing raw hardware wires...
FAILURE DETECTED: Byte 0 is 0x55 (expected 0xAA)
</pre></div>
</code></pre>
<h3 id="next-steps">Next steps</h3>
<p>While the explanation in the previous section (swapped byte lanes) seems
plausible enough to stop debugging at this point and wait for “Rev B”, in the
process I noted other possible avenues to explore:</p>
<ul>
<li>Lower slew rate / drive strength or increase output impedance, to reduce
crosstalk</li>
<li>Disable data masking entirely, if DDR PHY supports it</li>
<li>Disable cache during decompression?</li>
<li>Try out slower slew-rate settings and increasing output impedance for DDR
controller</li>
<li>Lower DDR frequency and see if the corruption pattern is the same, worse,
better?</li>
<li>Experiment: Run bootloader, Run FWUTIL, Do NOT reset, Jump directly into Linux</li>
<li>Add more capacitance to the VREF nodes (1uF in parallel with the current
0.1uF)</li>
<li>Try to read out from DDR PHY registers the per-byte DQS delays, and per-bit DQ
delays, and compare with PCB geometry</li>
<li>Repeat training again and again and see if there’s any variations (can I
detect training failures?)</li>
<li>Read out write levelling and DQS delay (read leveling) calibration results</li>
<li>My usual CPU-based DDR tests do not uncover a single bit flip, while the
heavily cached kernel decompressor shows huge corruption in the decompressed
output. How to reproduce that in my own code? Could the caches be
misconfigured, so they are somehow inappropriate for my PCB while being fine
on the eval board? Maybe caches don’t do the same kind of training that DDR
does.</li>
</ul>
<h3 id="lsb-swizzling">LSB swizzling</h3>
<p>Just because we found one issue with my connections, it does not mean we have
found all of them. From the <a href="https://jaycarlson.net/embedded-linux/">same</a>
article by Jay Carlson:</p>
<blockquote>
<p>Because DDR memory doesn’t care about the order of the bits getting stored,
you can swap individual bits — except the least-significant one if you’re
using write-leveling — in each byte lane with no issues.</p>
</blockquote>
<p>I have not been able to find any evidence of the LSB swapping restriction in ST
literature (datasheet, reference manual, app notes). Indeed, one app note<sup class="footnote-ref"><a href="#b2182266-fn1" id="b2182266-fnref1">[1]</a></sup>
just says that the DDR3L connection features “two swappable bytes, and swappable
bits in the same byte”.</p>
<p>However, the <code>MT41K</code> DDR3L datasheet includes a section on Write Leveling which
explains what’s up:</p>
<blockquote>
<p>For better signal integrity, DDR3 SDRAM memory modules have adopted fly-by
topology for the commands, addresses, control signals, and clocks. Write
leveling is a scheme for the memory controller to adjust or de-skew the DQS
strobe (DQS, DQS#) to CK relationship at the DRAM with a simple feedback
feature provided by the DRAM.  Write leveling is generally used as part of the
initialization process, if required. For normal DRAM operation, this feature
must be disabled. […]</p>
<p>When write leveling is enabled, the rising edge of DQS samples CK, and the
prime DQ outputs the sampled CK’s status. The prime DQ for a x4 or x8
configuration is DQ0 with all other DQ (DQ[7:1]) driving LOW. The prime DQ for
a x16 configuration is DQ0 for the lower byte and DQ8 for the upper byte.</p>
</blockquote>
<p>So, just in case, we should make sure not to “swizzle” the two LSBs in each
byte.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><em>8. This article</em></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="b2182266-fn1"><p>Application note AN5692: DDR memory routing guidelines for STM32MP13x
product lines. January 2023. <a class="footnote-backref" href="#b2182266-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Agents</div>
<h2><a href="llm-problems-observed-in-humans">LLM problems observed in humans</a></h2>
<div class="article-meta">Published 7 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/brain.jpg"/></p>
<p>While some are still discussing why computers will never be able to pass the
Turing test, I find myself repeatedly facing the idea that as the models improve
and humans don’t, the bar for the test gets raised and eventually humans won’t
pass the test themselves. Here’s a list of what used to be LLM failure modes but
that are now more commonly observed when talking to people.</p>
<h3 id="dont-know-when-to-stop-generating">Don’t know when to stop generating</h3>
<p>This has always been an issue in conversations: you ask a seemingly small and
limited question, and in return have to listen to what seems like hours of
incoherent rambling. Despite exhausting their knowledge of the topic, people
will keep on talking about stuff you have no interest in. I find myself
searching for the “stop generating” button, only to remember that all I can do
is drop hints, or rudely walk away.</p>
<h3 id="small-context-window">Small context window</h3>
<p>The best thing about a good deep conversation is when the other person gets you:
you explain a complicated situation you find yourself in, and find some
resonance in their replies. That, at least, is what happens when chatting with
the recent large models. But when subjecting the limited human mind to the same
prompt—a rather long one—again and again the information in the prompt
somehow gets lost, their focus drifts away, and you have to repeat crucial
facts. In such a case, my gut reaction is to see if there’s a way to pay to
upgrade to a bigger model, only to remember that there’s no upgrading of the
human brain. At most what you can do is give them a good night’s sleep and then
they may possibly switch from the “Fast” to the “Thinking” mode, but that’s not
guaranteed with all people.</p>
<h3 id="too-narrow-training-set">Too narrow training set</h3>
<p>I’ve got a lot of interests and on any given day, I may be excited to discuss
various topics, from kernels to music to cultures and religions. I know I can
put together a prompt to give any of today’s leading models and am essentially
guaranteed a fresh perspective on the topic of interest. But let me pose the
same prompt to people and more often then not the reply will be a polite nod
accompanied by clear signs of their thinking something else entirely, or maybe
just a summary of the prompt itself, or vague general statements about how
things should be. In fact, so rare it is to find someone who knows what I mean
that it feels like a magic moment. With the proliferation of genuinely good
models—well educated, as it were—finding a conversational partner with a
good foundation of shared knowledge has become trivial with AI. This does not
bode well for my interest in meeting new people.</p>
<h3 id="repeating-the-same-mistakes">Repeating the same mistakes</h3>
<p>Models with a small context window, or a small number of parameters, seem to
have a hard time learning from their mistakes. This should not be a problem for
humans: we have a long term memory span measured in decades, with emotional
reinforcement of the most crucial memories. And yet, it happens all too often
that I must point out the same logical fallacy again and again in the same
conversation! Surely, I think, if I point out the mistake in the reasoning, this
will count as an important correction that the brain should immediately make use
of? As it turns out, there seems to be some kind of a fundamental limitation on
how quickly the neural connections can get rewired. Chatting with recent models,
who can make use the extra information immediately, has deteriorated my patience
regarding having to repeat myself.</p>
<h3 id="failure-to-generalize">Failure to generalize</h3>
<p>By this point, it’s possible to explain what happens in a given situation, and
watch the model apply the lessons learned to a similar situation. Not so with
humans. When I point out that the same principles would apply elsewhere, their
response will be somewhere along the spectrum of total bafflement on the one end
and on the other, a face-saving explanation that the comparison doesn’t apply
“because it’s different”. Indeed the whole point of comparisons is to apply same
principles in different situations, so why the excuse? I’ve learned to take up
such discussions with AI and not trouble people with them.</p>
<h3 id="failure-to-apply-to-specific-situation">Failure to apply to specific situation</h3>
<p>This is the opposite issue: given a principle stated in general terms, the
person will not be able to apply it in a specific situation. Indeed, I’ve had a
lifetime of observing this very failure mode in myself: given the laws of
physics, which are typically “obvious” and easy to understand, I find it very
difficult to calculate how long before the next eclipse. More and more, rather
than think these things through myself, I’d just send a quick prompt to the most
recent big model, and receive a good answer in seconds. In other words, models
threaten to sever me not only from other flawed humans, but from my own “slow”
thinking as well!</p>
<h3 id="persistent-hallucination">Persistent hallucination</h3>
<p>Understood in the medical sense, hallucination refers to when something appears
to be real even as you know very well it isn’t. Having no direct insight into
the “inner mental life” of models, we claim that every false fact they spit out
is a form of hallucination. The meaning of the word is shifting from the medical
sense towards the direction of “just being wrong, and persistently so”. This has
plagued human speech for centuries. As a convenient example, look up some heated
debate between proponents of science and those of religion. (As if the two need
be in conflict!) When a model exhibits hallucination, often providing more
context and evidence will dispel it, but the same trick does not appear to work
so well on humans.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Where to go from here? One conclusion is that LLMs are damaging the connection
people feel with each other, much like a decade before social networks
threatened to destroy it by replacing it with a shallower, simulated versions.
Another interpretation would be to conclude cynically that it’s time humans get
either enhanced or replaced by a more powerful form of intelligence. I’d say
we’re not there yet entirely, but that some of the replacement has been effected
already: I’ll never again ask a human to write a computer program shorter than
about a thousand lines, since an LLM will do it better.</p>
<p>Indeed, why am I even writing this? I asked GPT-5 for additional failure modes
and found more additional examples than I could hope to get from a human:</p>
<blockquote>
<p>Beyond the failure modes already discussed, humans also exhibit analogues of
several newer LLM pathologies: conversations often suffer from <strong>instruction
drift,</strong> where the original goal quietly decays as social momentum takes over;
<strong>mode collapse,</strong> in which people fall back on a small set of safe clichés
and conversational templates; and <strong>reward hacking,</strong> where social approval or
harmony is optimized at the expense of truth or usefulness. Humans frequently
<strong>overfit the prompt,</strong> responding to the literal wording rather than the
underlying intent, and display <strong>safety overrefusal,</strong> declining to engage
with reasonable questions to avoid social or reputational risk. Reasoning is
also marked by <strong>inconsistency across turns,</strong> with contradictions going
unnoticed, and by <strong>temperature instability,</strong> where fatigue, emotion, or
audience dramatically alters the quality and style of thought from one moment
to the next.</p>
</blockquote>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page2.html">← Older articles</a></div>
        <div></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
