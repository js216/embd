<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="15 Sep 2025">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Step-by-step guide to booting Linux directly as BL33 with Arm Trusted Firmware (TF-A) on QEMU, bypassing U-Boot. Learn how to adjust Buildroot, modify the DTB and initramfs, and integrate the process into your own board files.">
<link rel="stylesheet" href="style.css">
<title>Linux as TF-A BL33 on Qemu (No U-Boot)</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Linux</div>
<h2>Linux as TF-A BL33 on Qemu (No U-Boot)</h2>
<div class="article-meta">Published 15 Sep 2025, modified 18 Sep 2025. Written by Jakob Kastelic.</div>
<p><img src="../images/pdp1.jpg" alt="" /></p>
<p><em>This is Part 4 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>With Qemu, anyone can customize the Linux boot process and run it without the
need for custom hardware. In this article, we will adapt a Buildroot defconfig
to make TF-A boot Linux and OP-TEE directly without U-Boot.</p>
<p>This approach was suggested by A. Vandecappelle on the Buildroot mailing
list<sup class="footnote-ref"><a href="#f2300b13-fn1" id="f2300b13-fnref1">[1]</a></sup>. He was correct to point out that it would be
interesting to see a Qemu simulation of the “Falcon mode” boot process:</p>
<blockquote>
<p>Perhaps it would also be a good idea to add a variant of the qemu defconfigs
that tests this option. We can use the <code>qemu_arm_vexpress_tz_defconfig</code>, drop
U-Boot from it, and switch to booting to Linux directly from TF-A.</p>
</blockquote>
<p>First, we will look at the “normal” boot process with U-Boot to understand how
to remove it. Then, we will provide tutorial-style steps to remove U-Boot from
the boot process. Then, we suggest with how to integrate this into Buildroot. We
conclude with a discussion of alternative approaches.</p>
<h3 id="normal-boot-process">“Normal” boot process</h3>
<p>In the <code>qemu_arm_vexpress_tz_defconfig</code> defconfig, Qemu is instructed to load
Arm Trusted Firmware (TF-A) as “<code>bios</code>”. Qemu auto-generates a Device Tree Blob
(DTB) and loads it in memory at the start of RAM. As the Qemu
documentation<sup class="footnote-ref"><a href="#f2300b13-fn2" id="f2300b13-fnref2">[2]</a></sup> explains:</p>
<blockquote>
<ul>
<li>
<p>For guests using the Linux kernel boot protocol (this means any non-ELF file
passed to the QEMU <code>-kernel</code> option) the address of the DTB is passed in a
register (<code>r2</code> for 32-bit guests, or <code>x0</code> for 64-bit guests)</p>
</li>
<li>
<p>For guests booting as “bare-metal” (any other kind of boot), the DTB is at
the start of RAM (0x4000_0000)</p>
</li>
</ul>
</blockquote>
<p>In our case, TF-A is booted in the “bare-metal” mode. We can see in file
<code>plat/qemu/qemu/include/platform_def.h</code> that this is so:</p>
<pre><code><div class="codehilite"><pre><span></span>#define PLAT_QEMU_DT_BASE           NS_DRAM0_BASE
</pre></div>
</code></pre>
<p>TF-A patches the Qemu-provided DTB by inserting the information about the
reserved memory addresses used by the secure OS (OP-TEE), as well as the
protocol (PSCI) that Linux is to use to communicate with OP-TEE. Then, it passes
control to U-Boot.</p>
<p>U-Boot only task in this configuration, as far as I can tell, is to load the
initial compressed filesystem image into some range of memory addresses, then
patch the DTB with these addresses. Then, it passes control to the Linux kernel.</p>
<p>Linux reads the DTB, either from the address given in register r2 or perhaps
from the pre-defined memory location (not sure). Then, it reads the
<code>initrd-start</code> location from the <code>chosen</code> node, decompresses the filesystem,
locates the init process, and runs it.</p>
<p>Thus to remove U-Boot, we just have to load the initramfs ourselves, and add its
address to the DTB. Of course, we must also tell TF-A to not load the U-Boot and
instead run Linux directly. In the following section, we explain how to do that.</p>
<h3 id="falcon-mode-tutorial">Falcon-mode tutorial</h3>
<ol>
<li>
<p>Obtain Buildroot and check out and build the defconfig that we’re starting
from:</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone https://gitlab.com/buildroot.org/buildroot.git --depth=1
$ make qemu_arm_vexpress_tz_defconfig
$ make
</pre></div>
</code></pre>
<p>This builds everything and gives the script <code>start_qemu.sh</code> (under
<code>output/images</code>) with the suggested Qemu command line.</p>
</li>
<li>
<p>Extract the DTB by modifying the Qemu command as follows (note the
<code>dumpdtb=qemu.dtb</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>$ qemu-system-arm -machine virt,dumpdtb=qemu.dtb -cpu cortex-a15
</pre></div>
</code></pre>
</li>
<li>
<p>Uncompile the DTB into the source format so we can edit it:</p>
<pre><code><div class="codehilite"><pre><span></span>$ dtc -I dtb -O dts qemu.dtb &gt; new.dts
</pre></div>
</code></pre>
<p>Open <code>new.dts</code> in a text editor and modify the <code>chosen</code> node as follows,
adding the location of the initramfs (initrd):</p>
<pre><code><div class="codehilite"><pre><span></span>chosen {
	linux,initrd-end = &lt;0x00 0x7666e09d&gt;;
	linux,initrd-start = &lt;0x00 0x76000040&gt;;
	bootargs = &quot;test console=ttyAMA0,115200 earlyprintk=serial,ttyAMA0,115200&quot;;
	stdout-path = &quot;/pl011@9000000&quot;;
};
</pre></div>
</code></pre>
<p>Compile it back into the DTB format:</p>
<pre><code><div class="codehilite"><pre><span></span>dtc -I dts -O dtb new.dts &gt; new.dtb
</pre></div>
</code></pre>
</li>
<li>
<p>Open <code>make menuconfig</code> and navigate to <code>Bootloaders ---&gt; Arm Trusted Firmware (ATF)</code>. Switch the BL33 to <code>None</code>, and add the following Additional ATF build
variables:</p>
<pre><code><div class="codehilite"><pre><span></span>BL33=$(BINARIES_DIR)/zImage
</pre></div>
</code></pre>
<p>Exit and save new configuration and rebuild:</p>
<pre><code><div class="codehilite"><pre><span></span>$ make arm-trusted-firmware-rebuild
$ make
</pre></div>
</code></pre>
<p>Check that <code>output/images</code> contains updated <code>fip.bin</code>, which should be about
5 or 6M in size since it contains the whole kernel rather than just U-Boot.</p>
</li>
<li>
<p>Run Qemu with the following commands:</p>
<pre><code><div class="codehilite"><pre><span></span>$ cd output/images
$ exec qemu-system-arm -machine virt -dtb art.dtb -device \
     loader,file=rootfs.cpio.gz,addr=0x76000040 -machine secure=on -cpu \
     cortex-a15 -smp 1 -s -m 1024 -d unimp -netdev user,id=vmnic -device \
     virtio-net-device,netdev=vmnic -nographic \
     -semihosting-config enable=on,target=native -bios flash.bin
</pre></div>
</code></pre>
<p>This is of course just the old command from <code>start-qemu.sh</code>, with the DTB and
initramfs added. With some luck, you should see messages from TF-A directly
transitioning into the ones from the kernel, with no U-Boot in between:</p>
<pre><code><div class="codehilite"><pre><span></span>NOTICE:  Booting Trusted Firmware
NOTICE:  BL1: v2.7(release):v2.7
NOTICE:  BL1: Built : 20:55:52, Sep 12 2025
NOTICE:  BL1: Booting BL2
NOTICE:  BL2: v2.7(release):v2.7
NOTICE:  BL2: Built : 20:55:52, Sep 12 2025
NOTICE:  BL1: Booting BL32
Booting Linux on physical CPU 0x0
Linux version 6.12.27 (jk@Lutien) (arm-buildroot-linux-gnueabihf-gcc.br_real (Buildroot -g5b6b80bf) 14.3.0, GNU ld (GNU Binutils) 2.43.1) #2 SMP Fri Sep 12 20:03:32 PDT 2025
CPU: ARMv7 Processor [414fc0f0] revision 0 (ARMv7), cr=10c5387d
CPU: div instructions available: patching division code
CPU: PIPT / VIPT nonaliasing data cache, PIPT instruction cache
OF: fdt: Machine model: linux,dummy-virt
OF: fdt: Ignoring memory range 0x40000000 - 0x60000000
</pre></div>
</code></pre>
</li>
</ol>
<h3 id="tf-a-support-for-linux-as-bl33">TF-A support for Linux as BL33</h3>
<p>We saw above that TF-A is happy to boot Linux directly so long as we just point
it to a kernel image for the BL33 executable. It turns out that there we can
find limited support for this use case already in the TF-A source tree via the
<code>ARM_LINUX_KERNEL_AS_BL33</code> flag.</p>
<p>The flag is specific to a few platforms. For AArch64 on Qemu, the documentation
(<code>docs/plat/qemu.rst</code>, as well as <code>docs/plat/arm/arm-build-options.rst</code>)
explains that the flag makes TF-A pass the Qemu-generated DTB to the kernel via
the <code>x0</code> register. We see the implementation of it in
<code>plat/qemu/common/qemu_bl2_setup.c</code> (and very similar lines in
<code>plat/arm/common/arm_bl31_setup.c</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>#if ARM_LINUX_KERNEL_AS_BL33
		/*
		 * According to the file ``Documentation/arm64/booting.txt`` of
		 * the Linux kernel tree, Linux expects the physical address of
		 * the device tree blob (DTB) in x0, while x1-x3 are reserved
		 * for future use and must be 0.
		 */
		bl_mem_params-&gt;ep_info.args.arg0 =
			(u_register_t)ARM_PRELOADED_DTB_BASE;
		bl_mem_params-&gt;ep_info.args.arg1 = 0U;
		bl_mem_params-&gt;ep_info.args.arg2 = 0U;
		bl_mem_params-&gt;ep_info.args.arg3 = 0U;
</pre></div>
</code></pre>
<p>On AArch32, the flag as currently implemented is intended for operation with
<code>SP_MIN</code>. This is clear from the documentation: “for AArch32 <code>RESET_TO_SP_MIN</code>
must be 1 when using” the <code>ARM_LINUX_KERNEL_AS_BL33</code> flag
(<code>docs/plat/arm/arm-build-options.rst</code>). The <code>plat/arm/common/arm_common.mk</code>
Makefile enforces this.</p>
<p>Unfortunately this limits the potential use cases of <code>ARM_LINUX_KERNEL_AS_BL33</code>
to AArch64, or else to AArch32 with <code>SP_MIN</code> enabled. The Buildroot defconfig we
have adapted in the previous section uses OP-TEE instead of <code>SP_MIN</code>, and it is
also possible to use no BL32 at all.</p>
<h3 id="patching-initramfs-address">Patching initramfs address</h3>
<p>In the tutorial above, we dumped the Qemu DTB and modified it just to add two
lines into the <code>chosen</code> node. The same can be done by TF-A.</p>
<p>The file <code>plat/qemu/common/qemu_bl2_setup.c</code> defines the function <code>update_dt()</code>
which is used for precisely this purpose, updating the DTB with some extra
board-specific details. (In the defconfig, it inserts PSCI nodes.)</p>
<p>We can insert the two <code>chosen</code> lines in the middle of <code>update_dt()</code>:</p>
<pre><code><div class="codehilite"><pre><span></span>fdt_setprop_u64(fdt, fdt_path_offset(fdt, &quot;/chosen&quot;),
        &quot;linux,initrd-start&quot;, 0x76000040);
fdt_setprop_u64(fdt, fdt_path_offset(fdt, &quot;/chosen&quot;),
        &quot;linux,initrd-end&quot;,   0x7666e09d);
</pre></div>
</code></pre>
<p>On recompile, there is no need to manually modify the DTB anymore.</p>
<p>The disadvantage of this approach is that we have to patch TF-A, making our
defconfig fragile against future changes in TF-A. It would be better to include
that DTB compilation as a post-build script in Buildroot.</p>
<h3 id="discussion">Discussion</h3>
<p>Is it practical to assume that the initramfs will be loaded in memory before
TF-A even starts executing? Of course not. But on a real embedded platform, such
as the setup from the <a href="stm32mp135-without-u-boot">previous article</a>, the root
filesystem is the SD card or some other non-volatile storage. There appears to
be no good reason to use U-Boot since TF-A can read from these just fine. If, on
the other hand, your setup requires some complicated configuration of the root
filesystem, possibly involving Ethernet, then U-Boot may well be a good choice.
Still, I believe that the best tool for the job is the simplest one that works
reliably.</p>
<p>It is also not reasonable to assume that the DTB would be loaded in memory
before TF-A even begins execution. After all, as the only bootloader, it is its
job to load it and point the kernel to where it loaded it. As P. Maydell
explains on the qemu-discuss mailing list<sup class="footnote-ref"><a href="#f2300b13-fn3" id="f2300b13-fnref3">[3]</a></sup>, providing the <code>-dtb</code> option to
Qemu “overrides the autogenerated file. But generally you shouldn’t do that.”
Instead, the Qemu user should provide the DTB, if emulating real hardware, or
else to have the Qemu</p>
<blockquote>
<p>autogenerate the DTB matching whatever it does, like the virt board. This is
the unusual case – virt only does this because it is a purely “virtual” board
that doesn’t match any real physical hardware and which changes depending on
what the user asked for.</p>
</blockquote>
<p>For example, on STM32MP1, the TF-A <code>fiptool</code> is used to package the DTB in a
form that TF-A is able to load it in memory using the <code>BL33_CFG</code> flag, as we
have used in <a href="stm32mp135-without-u-boot">previous article</a>.</p>
<p>There may be other ways to load the DTB and initramfs in Qemu, but the one
presented in our tutorial above appears to be the easiest. We could, for
example, modify Qemu to allow using the <code>-initrd</code> command line flag without the
<code>-kernel</code> flag, and emit the DTB with the appropriate address. Or, we could
teach TF-A how to read the initramfs file via the semihosting or virtio
protocols, load it into memory, and modify the DTB accordingly.</p>
<p>However, the tutorial method above works without modifying Qemu or TF-A code. It
uses an explicit DTB, as one is likely to do on a physical embedded target.
Since it passes the initramfs using an explicit command line option, it avoids
hard-coding it into any compiled code.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>17/9/2025: first submission of the Qemu defconfig
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786597.html">(link)</a></p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
  <li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
  <li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
  <li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
  <li><em>4. This article</em></li>
  <li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
  <li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
  <li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
  <li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="f2300b13-fn1" class="footnote-item"><p>Buildroot mailing list, Fri May 16 2025 message:
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-May/778563.html">boot/arm-trusted-firmware: optional Linux as
BL33</a>
(cited on 09/15/2025) <a href="#f2300b13-fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="f2300b13-fn2" class="footnote-item"><p>Qemu: <a href="https://www.qemu.org/docs/master/system/arm/virt.html#hardware-configuration-information-for-bare-metal-programming">‘virt’ generic virtual
platform</a>
(cited 09/15/2025). <a href="#f2300b13-fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="f2300b13-fn3" class="footnote-item"><p>qemu-discuss mailing list, Thu 4 Aug 2022 message: <a href="https://lists.gnu.org/archive/html/qemu-discuss/2022-08/msg00007.html">Re: how to prevent automatic
dtb
load?</a>
(cited 09/15/2025) <a href="#f2300b13-fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div>

<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>

</body>
</html>
