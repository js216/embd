<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">Build Linux for STM32MP135 in under 50 Lines of Makefile</a></h2>
<div class="article-meta">Published 6 Jan 2026, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/rain.jpg"/></p>
<p><em>This is Part 7 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In the <a href="https://embd.cc/linux-bringup-on-custom-stm32mp135-board">previous
article</a> we took a
<a href="https://github.com/js216/stm32mp135_test_board">custom STM32MP135 board</a> from a
simple LED blink to passing the kernel early boot stage, printing the “Booting
Linux” message. Now, it’s time to finish the kernel initialization all the way
up to running our first process: the <code>init</code> process.</p>
<p>We’ll do it in two steps. First, we make it run on the official <a href="https://www.st.com/en/evaluation-tools/stm32mp135f-dk.html">evaluation
board</a> for the SoC.
In a future article, we will consider what needs to be changed in order to make
this work on a <a href="https://github.com/js216/stm32mp135_test_board">custom board</a>.</p>
<h3 id="boot-linux-on-eval-board">Boot Linux on eval board</h3>
<p>First, we need to obtain and build the bootloader. Note that we need to enable
the STPMIC1, since it is used on the eval board:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>git@github.com:js216/stm32mp135-bootloader.git
<span class="nb">cd</span><span class="w"> </span>stm32mp135-bootloader
make<span class="w"> </span><span class="nv">CFLAGS_EXTRA</span><span class="o">=</span>-DUSE_STPMIC1x<span class="o">=</span><span class="m">1</span>
<span class="nb">cd</span><span class="w"> </span>..
</pre></div>
</code></pre>
<p>Next, we obtain the Linux kernel from the ST repository (contains a few
non-standard ST-provided drivers):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/STMicroelectronics/linux.git
git<span class="w"> </span>checkout<span class="w"> </span>v6.1-stm32mp-r1.1
</pre></div>
</code></pre>
<p>Let’s apply some patches (mainly to allow non-secure boot without
<a href="https://embd.cc/stm32mp135-without-u-boot">U-Boot</a>,
<a href="https://embd.cc/stm32mp135-without-optee">OPTEE</a>, or
<a href="https://embd.cc/linux-bringup-on-custom-stm32mp135-board">TF-A</a>), and copy over
the Device Tree Source (DTS), and the kernel configuration:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>git@github.com:js216/stm32mp135_test_board.git

<span class="nb">cd</span><span class="w"> </span>linux
git<span class="w"> </span>linux<span class="w"> </span>apply<span class="w"> </span>../configs/evb/patches/linux/*.patch
<span class="nb">cd</span><span class="w"> </span>..

cp<span class="w"> </span>config/evb/linux.config<span class="w"> </span>linux/.config
cp<span class="w"> </span>config/evb/board.dts<span class="w"> </span>linux/arch/arm/boot/dts/
</pre></div>
</code></pre>
<p>Now we can build the Device Tree Blob (DTB) and the kernel itself:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="nb">cd</span><span class="w"> </span>linux
make<span class="w"> </span><span class="nv">ARCH</span><span class="o">=</span>arm<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf-<span class="w"> </span>board.dtb
make<span class="w"> </span><span class="nv">ARCH</span><span class="o">=</span>arm<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-linux-gnueabihf-<span class="w"> </span>zImage
<span class="nb">cd</span><span class="w"> </span>..
</pre></div>
</code></pre>
<p>Next, we need an init script. (Of course, you can also run the kernel without
it, but be prepared for a kernel panic at the end of the boot, telling you the
init is missing.) An init script can be essentially any program, even a “Hello,
world!”, but if the init program quits, the kernel enters a panic again.</p>
<p>I asked AI to write a minimal init, without any C standard library dependencies
(find the result
<a href="https://github.com/js216/stm32mp135_test_board/blob/main/configs/evb/init.c">here</a>).
Let’s compile it, making sure to tell the compiler to not link any extra code
with it:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>arm-linux-gnueabihf-gcc<span class="w"> </span>-Os<span class="w"> </span>-nostdlib<span class="w"> </span>-static<span class="w"> </span>-fno-builtin<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>-Wl,--gc-sections<span class="w"> </span>config/init.c<span class="w"> </span>-o<span class="w"> </span>build/init
</pre></div>
</code></pre>
<p>Now that we have an init program, we need a root filesystem to put it on:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>build/rootfs.dir/sbin
cp<span class="w"> </span>build/init<span class="w"> </span>build/rootfs.dir/sbin/init
dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/dev/zero<span class="w"> </span><span class="nv">of</span><span class="o">=</span>build/rootfs<span class="w"> </span><span class="nv">bs</span><span class="o">=</span>1M<span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">10</span>
mke2fs<span class="w"> </span>-t<span class="w"> </span>ext4<span class="w"> </span>-F<span class="w"> </span>-d<span class="w"> </span>build/rootfs.dir<span class="w"> </span>build/rootfs
</pre></div>
</code></pre>
<p>Finally, we collect all the pieces together with a simple Python script included
in the bootloader distribution:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>python3<span class="w"> </span>bootloader/scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>bootloader/build/main.stm32<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>linux/arch/arm/boot/dts/board.dtb<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>linux/arch/arm/boot/zImage<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>--partition<span class="w"> </span>build/rootfs
</pre></div>
</code></pre>
<p>Write this image to the SD card and start the system, and prepare to be greeted
by the very useless shell implemented in the minimal
<a href="https://github.com/js216/stm32mp135_test_board/blob/main/configs/evb/init.c">init program</a>):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="o">[</span><span class="w">    </span><span class="m">1</span>.940577<span class="o">]</span><span class="w"> </span>Run<span class="w"> </span>/sbin/init<span class="w"> </span>as<span class="w"> </span>init<span class="w"> </span>process
Hello,<span class="w"> </span>world!
$<span class="w"> </span>ls
ls:<span class="w"> </span><span class="nb">command</span><span class="w"> </span>not<span class="w"> </span>found
$<span class="w"> </span>Hey!
Hey!:<span class="w"> </span><span class="nb">command</span><span class="w"> </span>not<span class="w"> </span>found
</pre></div>
</code></pre>
<p>That’s it!</p>
<h3 id="the-makefile">The Makefile</h3>
<p>Here’s the full 49 lines:</p>
<pre><code class="language-makefile"><div class="codehilite"><pre><span></span><span class="nv">CONFIG_DIR</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>configs/custom
<span class="nv">CROSS_COMPILE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>arm-linux-gnueabihf-
<span class="nv">LINUX_OPTS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">ARCH</span><span class="o">=</span>arm<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span><span class="k">$(</span>CROSS_COMPILE<span class="k">)</span>

<span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="n">boot</span> <span class="n">config</span> <span class="n">dtb</span> <span class="n">kernel</span> <span class="n">init</span> <span class="n">root</span> <span class="n">sd</span>

<span class="nf">boot</span><span class="o">:</span>
<span class="w">	</span><span class="k">$(</span>MAKE<span class="k">)</span><span class="w"> </span>-C<span class="w"> </span>bootloader<span class="w"> </span>-j<span class="k">$(</span>shell<span class="w"> </span>nproc<span class="k">)</span><span class="w"> </span><span class="nv">CFLAGS_EXTRA</span><span class="o">=</span>-DUSE_STPMIC1x<span class="o">=</span><span class="m">1</span>

<span class="nf">patch</span><span class="o">:</span>
<span class="w">	</span><span class="k">for</span><span class="w"> </span>p<span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">$(</span>CONFIG_DIR<span class="k">)</span>/patches/linux/*.patch<span class="p">;</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="se">\</span>
<span class="cp">		if git -C linux apply --check ../$$p; then \</span>
<span class="cp">			git -C linux apply ../$$p; \</span>
<span class="cp">		fi \</span>
<span class="cp">	done</span>

<span class="nf">config</span><span class="o">:</span>
<span class="w">	</span>cp<span class="w"> </span><span class="k">$(</span>CONFIG_DIR<span class="k">)</span>/linux.config<span class="w"> </span>linux/.config

<span class="nf">dtb</span><span class="o">:</span>
<span class="w">	</span>cp<span class="w"> </span><span class="k">$(</span>CONFIG_DIR<span class="k">)</span>/board.dts<span class="w"> </span>linux/arch/arm/boot/dts/
<span class="w">	</span><span class="k">$(</span>MAKE<span class="k">)</span><span class="w"> </span>-C<span class="w"> </span>linux<span class="w"> </span><span class="k">$(</span>LINUX_OPTS<span class="k">)</span><span class="w"> </span>board.dtb

<span class="nf">kernel</span><span class="o">:</span>
<span class="w">	</span><span class="k">$(</span>MAKE<span class="k">)</span><span class="w"> </span>-C<span class="w"> </span>linux<span class="w"> </span><span class="k">$(</span>LINUX_OPTS<span class="k">)</span><span class="w"> </span>-j<span class="k">$(</span>shell<span class="w"> </span>nproc<span class="k">)</span><span class="w"> </span>zImage

<span class="nf">init</span><span class="o">:</span>
<span class="w">	</span>mkdir<span class="w"> </span>-p<span class="w"> </span>build
<span class="w">	</span><span class="k">$(</span>CROSS_COMPILE<span class="k">)</span>gcc<span class="w"> </span>-Os<span class="w"> </span>-nostdlib<span class="w"> </span>-static<span class="w"> </span>-fno-builtin<span class="w"> </span><span class="se">\</span>
<span class="w">		</span>-Wl,--gc-sections<span class="w"> </span><span class="k">$(</span>CONFIG_DIR<span class="k">)</span>/init.c<span class="w"> </span>-o<span class="w"> </span>build/init

<span class="nf">root</span><span class="o">:</span>
<span class="w">	</span>rm<span class="w"> </span>-rf<span class="w"> </span>build/rootfs.dir
<span class="w">	</span>mkdir<span class="w"> </span>-p<span class="w"> </span>build/rootfs.dir/sbin
<span class="w">	</span>cp<span class="w"> </span>build/init<span class="w"> </span>build/rootfs.dir/sbin/init
<span class="w">	</span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/dev/zero<span class="w"> </span><span class="nv">of</span><span class="o">=</span>build/rootfs<span class="w"> </span><span class="nv">bs</span><span class="o">=</span>1M<span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">10</span>
<span class="w">	</span>mke2fs<span class="w"> </span>-t<span class="w"> </span>ext4<span class="w"> </span>-F<span class="w"> </span>-d<span class="w"> </span>build/rootfs.dir<span class="w"> </span>build/rootfs

<span class="nf">sd</span><span class="o">:</span>
<span class="w">	</span>python3<span class="w"> </span>bootloader/scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span><span class="se">\</span>
<span class="w">		</span>bootloader/build/main.stm32
<span class="w">		</span>linux/arch/arm/boot/dts/board.dtb<span class="w"> </span><span class="se">\</span>
<span class="w">		</span>linux/arch/arm/boot/zImage<span class="w"> </span><span class="se">\</span>
<span class="w">		</span>--partition<span class="w"> </span>build/rootfs

<span class="nf">clean</span><span class="o">:</span>
<span class="w">	</span><span class="k">$(</span>MAKE<span class="k">)</span><span class="w"> </span>-C<span class="w"> </span>linux<span class="w"> </span><span class="k">$(</span>LINUX_OPTS<span class="k">)</span><span class="w"> </span>clean
<span class="w">	</span><span class="k">$(</span>MAKE<span class="k">)</span><span class="w"> </span>-C<span class="w"> </span>bootloader<span class="w"> </span>clean
<span class="w">	</span>rm<span class="w"> </span>-rf<span class="w"> </span>build
</pre></div>
</code></pre>
<h3 id="discussion">Discussion</h3>
<p>The Makefile that reproduces the steps above is less than 50 lines long and
creates a minimal, bootable SD card image in a very straightforward way: build
the kernel, the DTB, and a userspace program (init), and package everything into
a single SD card image. The next simplest thing to accomplish the same result is
the “lightweight” <a href="https://buildroot.org/">Buildroot</a>, which needs nearly 100k
lines of make. What could possibly be happening in all that code!?</p>
<p>The sentiment
has been captured by the Reddit user <code>triffid_hunter</code> in a recent
<a href="https://www.reddit.com/r/embedded/comments/1pqg3ty/embedded_systems_are_really_hard_to_learn">comment</a>:</p>
<blockquote>
<p>I find that the hardest part about embedded is the horrendously obtuse
manufacturer-provided toolchains.</p>
<p>If I can find a way to ditch them and switch to gcc+Makefile+basic C
libraries, that’s the first thing I’ll do.</p>
</blockquote>
<p>Buildroot is a relatively clean solution to the problem of supporting a huge
number of packages on a wide variety of boards, but most of that complexity is
not needed for a single-board project. (Yocto is an even more complex system,
which we won’t cover here—its simplicity for the user comes at the cost of
massive implementation complexity.) From my point of view, all these hundreds of
thousands of lines of code are simply “accidental complexity” as articulated by
ESR:</p>
<blockquote>
<p>Accidental complexity happens because someone didn’t find the simplest way to
implement a specified set of features. Accidental complexity can be
eliminated by good design, or good redesign.<sup class="footnote-ref"><a href="#d343fcde-fn1" id="d343fcde-fnref1">[1]</a></sup></p>
</blockquote>
<p>The “root cause” of the highly complex toolchains has been identified by
Anna-Lena Marx (inovex GmbH) in a talk<sup class="footnote-ref"><a href="#d343fcde-fn2" id="d343fcde-fnref2">[2]</a></sup> last year: the goals of SoC
vendors and product manufacturers are not aligned. The SoC vendor wants to show
off all the features of their devices, and they want a Board Support Package
(BSP) that supports several, even all, of the devices in their portfolio. They
want a “turnkey solution” that allows an engineer to go from nothing to a
full-featured demo in ten minutes.</p>
<p>In contrast, a product manufacturer who wants to use embedded Linux in their
application-specific product wants a minimal software stack, as close as
possible to the upstream stable versions in order to be stable, secure, &amp;
maintainable. It’s the difference between merely using the system, and owning
it.</p>
<p>From the product side, I can concur that the SoC BSPs can be a nightmare to work
with! They are simple to get started with, being a packaged “turnkey solution”,
but require a massive amount of work to unpeel all the abstraction layers that
the SoC vendor found necessary to support their entire ecosystem of devices. ST,
being perhaps the most “hacker friendly” vendor, likely has the cleanest, most
“upstreamed” offering, and still there’s loads of cruft that must be removed
before getting to something workable.</p>
<p>I would like a world where SoC vendors ship their product with simple,
straightforward <em>documentation</em>, rather than monolithic code examples. Give me
the smallest possible building blocks and tell me how to connect them together
to accomplish something, rather than give the huge all-in-one example code that
can take many tens of hours to pull apart and reassemble. In other words, I
expect a Linux distribution to approach to the ideal of <a href="https://embd.cc/unix-contributions">Unix
philosophy</a> much more closely, all the more
so in an embedded, resource-constrained, highly reliable application.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><em>7. This article</em></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="d343fcde-fn1"><p>Eric S. Raymond: The Art of Unix Programming. Addison-Wesley, 2004. <a class="footnote-backref" href="#d343fcde-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="d343fcde-fn2"><p>Anna-Lena Marx (inovex GmbH): <em>Your Vendor’s BSP Is Probably Not Built
for Product Longevity</em>. Yocto Project Summit, December 2025. Quoted on
1/5/2026 from <a href="https://marx.engineer/content/talks/2025_Yocto-Summit_Your-Vendors-BSP-Is-Probably-Not-Built-For-Product-Longevity.pdf">this URL</a> <a class="footnote-backref" href="#d343fcde-fnref2">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="let-reality-update-you">Let Reality Update You</a></h2>
<div class="article-meta">Published 5 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/arc.jpg"/></p>
<p>Reality always makes sense because it is reality. When our ideas of it do not
correspond to it, it’s the ideas that are suspect.</p>
<p>Insofar as our understanding involves a mapping of the fluid reality to fixed
ideas, we will always end up confused when refusing to let go of fixed ideas
that have lost their relevance.</p>
<p>Staying flexible in thought is a form of mental hygiene.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Agents</div>
<h2><a href="agent-to-read-datasheets">Agent To Read Electronic Datasheets</a></h2>
<div class="article-meta">Published 2 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/pa.jpg"/></p>
<p>When an electronic design company accumulates large amounts of inventory, it can
become overwhelming for engineers to go through the thousands of parts to find
the one needed in a new design. Instead, they are likely to select a new part
from one of the distributors that have a better search engine. This leads to an
ever growing inventory: parts kept in stock and never used, a constant departure
from the ideal of having a “lean” operation.</p>
<p>Nowadays, with everyone creating their own “agent” for just about anything, I
wondered how hard it would be to create my own search engine. This article
represents a day of work, proving that structured data extraction from
semi-unstructured sources like datasheets has become almost a trivial problem.</p>
<p>I took the <a href="https://deepmind.google/models/gemma/gemma-3/">Gemma 3</a> model (12B
parameters, 3-bit quantization) from Google, ran it in the
<a href="https://github.com/ggml-org/llama.cpp">llama.cpp</a> inference framework, and fed
it the datasheet for an opamp. To extract the text from the PDFs, I used the
<a href="https://www.docling.ai/">Docling</a> Python library from IBM research. The output,
generated in about four minutes on a GPU with 8 GB of memory, will be in this
format for now:</p>
<pre><code class="language-json"><div class="codehilite"><pre><span></span><span class="nt">"PSRR (Input offset voltage versus power supply)"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nt">"min"</span><span class="p">:</span><span class="w"> </span><span class="mi">65</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"typ"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"max"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"unit"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dB"</span>
<span class="w"> </span><span class="p">},</span>
</pre></div>
</code></pre>
<p>Let’s get started!</p>
<h3 id="running-the-model">Running the model</h3>
<p>Obtain and build llama.cpp:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ggerganov/llama.cpp
<span class="nb">cd</span><span class="w"> </span>llama.cpp
cmake<span class="w"> </span>-B<span class="w"> </span>build<span class="w"> </span>-S<span class="w"> </span>.<span class="w"> </span>-DGGML_CUDA<span class="o">=</span>ON
cmake<span class="w"> </span>--build<span class="w"> </span>build<span class="w"> </span>-j
</pre></div>
</code></pre>
<p>Obtain the <a href="https://huggingface.co/bartowski/google_gemma-3-12b-it-GGUF">Gemma
3</a> model.</p>
<p>Start the LLM server:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>llama-server<span class="w"> </span>-m<span class="w"> </span>~/temp/gemma-3-12b-it-UD-IQ3_XXS.gguf<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>--port<span class="w"> </span><span class="m">8080</span><span class="w"> </span>-c<span class="w"> </span><span class="m">4096</span><span class="w"> </span>-ngl<span class="w"> </span><span class="m">999</span>
</pre></div>
</code></pre>
<p>Open <code>localhost:8080</code> and feel free to chat with the model. How simple things
have become!</p>
<h3 id="get-datasheet-text">Get datasheet text</h3>
<p>Next, we need to convert the datasheets from the PDF format into plain text that
we can feed to the model. Assuming <code>docling</code> is installed (install it with Pip
if not), we can define the following function to convert the documents:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">docling.document_converter</span> <span class="kn">import</span> <span class="n">DocumentConverter</span>

<span class="k">def</span> <span class="nf">convert_pdf_to_markdown</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">):</span>
    <span class="n">pdf_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">)</span>
    <span class="n">converter</span> <span class="o">=</span> <span class="n">DocumentConverter</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">pdf_path</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">export_to_markdown</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>This yields the output in a Markdown format.</p>
<h3 id="define-agent-with-a-simple-prompt">Define agent with a simple prompt</h3>
<p>Here’s the best part: the “source code” for the agent is in plain English. Here
it is in its entirety:</p>
<pre><code><div class="codehilite"><pre><span></span>You are a datasheet specification extraction agent. Your
only job is to extract specifications.

OUTPUT FORMAT:
{
  "Full parameter name (short name)": {
    "min": number or null,
    "typ": number or null,
    "max": number or null,
    "unit": "string"
  }
}

EXTRACTION RULES:
- Always include both the full and short spec name in the key.
- Full name goes first, and short name in brackets: "Operating Temperature (T)"
- If a typ value is a range like "-11.5 to 14.5", split it: min=-11.5, max=14.5
- Convert scientific notation: "10 12" → 1e12
- Convert ± values into min/max fields
- Omit parameters with no numeric values (all null)
- Omit footnotes like (1) and (2)
- If no specifications exist, return: {}

CRITICAL OUTPUT RULES:
- Return ONLY valid JSON
- NO explanations
- NO descriptions
- NO phrases like "this section", "no specifications", "I will skip"
- NO text before or after the JSON
- NO markdown code blocks
- Just the raw JSON object
</pre></div>
</code></pre>
<p>The insistence on pure JSON is a hack to make it stop being too chatty. There’s
probably a more sophisticated way to do it, but for a first attempt it’ll do
just fine.</p>
<h3 id="chunking">“Chunking”</h3>
<p>The datasheet conversion from PDF includes lots of unnecessary text like
document version information, copyright, ordering information. For now, we’d
like to get just the electronic specifications. As a first approximation, assume
that the information is always present in tables only.</p>
<p>ChatGPT assures me that the following regex magic will extract tables from a
Markdown document:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">get_chunks</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Return a list of Markdown tables as strings from a file."""</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">"(?:^\|.*\|\s*\n)"</span>           <span class="c1"># Header row</span>
        <span class="sa">r</span><span class="s2">"(?:^\|[-:\s|]+\|\s*\n)"</span>     <span class="c1"># Separator row</span>
        <span class="sa">r</span><span class="s2">"(?:^\|.*\|\s*\n?)+"</span><span class="p">,</span>        <span class="c1"># Body rows</span>
        <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span>
    <span class="p">)</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">table_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">]</span>
</pre></div>
</code></pre>
<h3 id="putting-it-together">Putting it together</h3>
<p>We have all the pieces now: text data in small pieces, a model, the prompt to
define an agent. Now just iterate over all the chunks as defined above, send
them to the model together with the prompt, and observe what comes out. To
automate the process from PDF to the final JSON, I used a Makefile defining the
recipes for the three steps of the transformation. All of this is too
straightforward to be worth including here.</p>
<p>For anyone interested, find the entire code presented above
<a href="https://github.com/js216/sfap">here</a>.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Self-Change</div>
<h2><a href="emptiness-constraint-actually-doing-things">On Emptiness, Constraint, and Doing Things</a></h2>
<div class="article-meta">Published 23 Dec 2025. Written by Jakob Kastelic and GPT-5.</div>
<p><img alt="" src="../images/roy.jpg"/></p>
<p>There’s a <a href="https://embd.cc/limitation-is-freedom">recurring</a> paradox in life:
when forced into constraint—normally in the office—it’s easy to get a
surprising amount of work done. When free—at home, with a desk full of
possibilities—I do almost nothing. Probably most people have felt this:
paralyzed by options, not liberated by freedom.</p>
<p>In the office, there’s a clear system. Hours, tasks, deadlines. None of these
promise joy or meaning. You just show up, pick the thing that needs to be done,
and do it. Often it’s boring, sometimes hard, sometimes fun—but mostly it’s
ordinary execution. And it gets done, the meaning/joy shows up later, if it
does. In other words, meaning is retrospective, not prospective.</p>
<h3 id="the-problem">The Problem</h3>
<p>At home, when anyone could be the architect of their own life—at least in
theory—everything feels like a potential project rather than a commitment.
There’s a long list of things to do someday. You start something, lose
interest, start something else, lose interest there too. The pile grows. The
mind feels like a full cup, overflowing, useless as a vessel since it has no
volume available. I had a lot of energy running toward the possibility of
things, and none toward actually doing any of them.</p>
<p>There are all these things to do, but when the time came, I would just scroll
through random websites and stuff.  Not for lack of desire but because every
possibility was simultaneously “urgent” and none had any context, boundary, or
commitment. I was waiting for the meaning to arrive—expecting to feel it
first, and act second. A kind of dopamine-before-action loop that never
materializes, because dopamine isn’t a starting signal; it’s a reward signal
after progress has been made.</p>
<p>I recently realized this was not a motivational problem but a structural one.
The <code>ideas.txt</code> file, where the latest projects and ideas get stored, was
effectively a home version of what at work would be called <code>unnecessary.txt</code>: a
repository of work items that don’t currently need attention (see <a href="https://embd.cc/yes-no-productivity">this
article</a> for more on this approach). But
because at home all of those things are regarded as “alive”, they were
cluttering the “mental desk”, competing for attention and claiming emotional
validity. This is exactly how productivity systems fail: they mistake interest
with execution rights. You think something is alive because you wrote it down.
That creates mental load.</p>
<p>So I enforced a constraint.</p>
<h3 id="a-solution-one-hobby-at-a-time">A Solution: One Hobby at a Time</h3>
<p>I adapted this: Only one productive leisure project gets execution rights at a
time. The rest become cold archive—“not right now, maybe later.” They live in
<code>ideas.txt</code>, not in the working memory.</p>
<p>This is not suppression of curiosity. It’s admission control, a bit like the WIP
limits (the kanban-style work in progress caps, see below) that enforce unity of
purpose and prevent jamming the “system” with too many requirements.</p>
<p>The curious thing: once all the other activities besides the “One Hobby” became
off-limits to tracking and obligation, they lost their psychological “landmine”
quality. They became playful again, instead of competing for real estate in the
head. Then they were constantly evaluated, compared, prioritized—a swarm of
partial commitments without form or finish.</p>
<h3 id="productive-vs-restorative-leisure">Productive vs Restorative Leisure</h3>
<p>That distinction matters.</p>
<p>Productive Leisure is an activity that:</p>
<ul>
<li>can be tracked for progress,</li>
<li>has future implications or expectations,</li>
<li>competes for mental slots,</li>
<li>produces artifacts, skill growth, or structured outcomes.</li>
</ul>
<p>These are the things that can fill up the mind if left unconstrained.</p>
<p>In contrast, restorative Leisure is play without future stakes:</p>
<ul>
<li>no tracking,</li>
<li>no backlog,</li>
<li>no scorecards,</li>
<li>activities done for their own sake.</li>
</ul>
<p>Once Productive Leisure items were formally demoted to “cold archive unless
active,” many of them felt like Restorative Leisure: something you might do
because it’s pleasant, not something you have to do to avoid guilt or loss.</p>
<p>This distinction mirrors the essence of constraint in productivity: by making
clear what counts and what doesn’t, you reduce the cognitive load of
decision-making and let intentional action happen.</p>
<h3 id="kanban">Kanban</h3>
<p>Kanban, in its original form at Toyota, was a simple, physical system for
managing production flow on the factory floor using cards that each represented
permission to produce or move a specific part. Rather than relying on schedules,
forecasts, or manager oversight, kanban used these tangible cards to regulate
when work could start and when it could move forward. The system naturally
enforced limits on how much unfinished work could exist at any moment.</p>
<p>The key irony is that the system makes work more productive by <em>preventing</em>
work, that is, an excess of work. Each step in the production line is governed
by a small number of physical kanban cards, and a task cannot move forward
unless a card is available. It recognizes that no worker or process has infinite
capacity and it helps no one to pretend otherwise. Bottlenecks become visible
immediately, there is no illusion of productivity or busy-work, queues cannot
silently grow, and problems are forced to surface where they actually occur.</p>
<p>Fewer parallel tasks means less context switching, faster feedback, and higher
quality, since defects were discovered close to their source. Crucially, kanban
does not rely on motivation, discipline, or managerial pressure; it embedded
restraint directly into the environment. The tokens made overcommitment
impossible, and in doing so created the emptiness in which steady, reliable work
could actually happen.</p>
<h3 id="taoist-emptiness-and-functional-capacity">Taoist Emptiness and Functional Capacity</h3>
<p>I was struck by how this aligned with a very old idea: the usefulness of
emptiness:</p>
<blockquote>
<p>I do my utmost to attain emptiness; I hold firmly to stillness. The myriad
creatures all rise together And I watch their return. [Tao Te Ching, 16]</p>
<p>The way never acts yet nothing is left undone. [37]</p>
<p>The Master does nothing, yet he leaves nothing undone. The ordinary man is
always doing things, yet many more are left to be done. [38]</p>
</blockquote>
<p>The Taoists observed that a cup is useful because it is empty; a room is useful
because it has space. When something gets completely full, it loses its
usefulness. The same applied to the “mental desk”: when it was totally full of
half-alive things, it became rigid, dead, and useless.</p>
<p>In this emptiness—not the absence of goals, but the absence of competing
commitments—things can actually happen. You don’t wait for meaning; you let
meaning emerge from action.</p>
<p>“The Way does nothing, yet leaves nothing undone.” Action arises unforced when
the system isn’t cluttered with demands, comparisons, and anticipation.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The system distilled down to a simple invariant:</p>
<ul>
<li>Only one productive leisure activity is alive in the present.</li>
<li>Everything else is archived.</li>
<li>Restorative activities are permissionless.</li>
<li>Progress, not aspiration, drives meaning.</li>
</ul>
<p>In other words, <em>interest does not grant execution rights</em>. Execution rights
must be scarce, just like kanban tokens. When they are, things get done; when
they’re abundant, nothing happens.</p>
<p>In this system, willpower or motivation became almost irrelevant. When the mind
is freed from the need to do “everything”, the intention can take over. This
kind of intentional action, in my experience, only works when there’s very few
intentions to compete with each other.</p>
<p>Emptiness isn’t the absence of desires. It’s the absence of conflicting claims
on your attention. Start there, and you can actually practice something.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="linux-bringup-on-custom-stm32mp135-board">Linux Bring-Up on a Custom STM32MP135 Board</a></h2>
<div class="article-meta">Published 22 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/vt.jpg"/></p>
<p><em>This is Part 6 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>This is a record of steps I took to successfully get Linux past the early boot
stage on my custom board using the STM32MP135 SoC. (Schematics, PCB design
files, and code available in this
<a href="https://github.com/js216/stm32mp135_test_board">repository</a>.) The write-up is
in approximate chronological order, written as I go through the debugging steps.</p>
<h3 id="blink">Blink</h3>
<p>I had previously put together a simple bare-metal
<a href="https://github.com/js216/mp135_boot/tree/main/blink_noide">program</a> that runs
on the STM32MP135 evaluation board and just blinks the LED. To work on the
custom board, I needed only to remove anything to do with the STPMIC1 and LSE
clock (the low-speed external 32.768 kHz clock), since I did not place these
parts on my board. The <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/blink">resulting
code</a>
is pretty simple modulo complexity inherited from the ST drivers.</p>
<p>To download the code, I talked directly to the ROM bootloader on the SoC. See
<a href="boot-stm32mp135-over-uart-with-python">this article</a> for details.</p>
<h3 id="ddr">DDR</h3>
<p>Again, I had previously put together a <a href="https://github.com/js216/mp135_boot/tree/main/ddr_test">simple
program</a> to test the DDR
on the evaluation board. It fills the memory entirely with pseudorandom bits
(PRBS-31), and then reads it out, checking that the data matches.</p>
<p>For the custom board, the program had to be modified similarly as with blink
(remove STPMIC1, LSE clock) and then it ran. <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/ddr_test">(Click for
code.)</a></p>
<p>There was an issue: all data read back was wrong and subtly corrupted. I double
checked the wiring, DDR parameter configuration (I use the same DDR as the eval
board, so what could it be!?), the code—only to realize the board was not
getting enough current on the 1.35V power supply. With more power, everything
<em>just worked</em>!</p>
<h3 id="jtag">JTAG</h3>
<p>For JTAG loading it appears to be essential to select “Development boot” (also
called “Engineering boot”) by selecting the boot pins in the <code>100</code> setting. The
datasheet says this mode is used “Used to get debug access without boot from
flash memory”.</p>
<p>There is also a footnote that says that the core is “in infinite loop toggling
PA13”, but I did not observe the toggling in the “dev boot” mode, even though it
is of course present (but not documented) in the normal UART boot mode (pins =
<code>000</code>).</p>
<p><img alt="" src="../images/jtag.jpg"/></p>
<p>Unfortunately I covered the J-Link connector with solder mask. After trying to
carefully scratch it off using a sewing needle, the connection appears to be
intermittent. Sometimes J-Link was able to download the DDR test program to the
SYSRAM, but most of the time it couldn’t. Probably it would work just fine if it
wasn’t for the soldermask covering. I wish I had just used a normal pin-header
connector rather than the J-Link needle adapter. So, I’ll have to use UART boot
mode for now, and hope that I can get the (much faster) USB mode to work.</p>
<h3 id="sd">SD</h3>
<p><em>Note: read the full SD card story
<a href="https://embd.cc/sdcard-on-bare-metal-stm32mp135">here</a>.</em></p>
<p>On the STM32MP135 evaluation board, an SDMMC example reliably reads a program
from an SD card into DDR and executes it, but porting the same code to a custom
board exposed a failure during SD initialization. Although command-level
communication succeeded—CMD0, CMD8, CMD55, and ACMD41 all completed normally and
the card identified as SDHC—the sequence consistently failed later in
<code>SD_SendSDStatus</code> with <code>SDMMC_FLAG_DTIMEOUT</code>. Hardware checks showed that SD
card power, SDMMC I/O domain voltages, and signal levels all matched the
evaluation board, with clean 3.3 V logic and a low clock rate of about 1.56 MHz.
The decisive difference turned out to be signal pull-ups: the evaluation board
routes SD signals through an ESD device with built-in pull-ups, whereas the
custom board did not. Enabling internal pull-ups on the SD data lines eliminated
the data timeout and allowed SD reads to proceed, confirming that missing
pull-ups were responsible for the initialization failure.</p>
<p>However, once SD transfers succeeded, the data read from the card appeared
corrupted in DDR: roughly every other byte was intermittently wrong, always off
by exactly two, independent of bus width, clock edge, power supply, or signal
integrity. The critical observation was that data read into a static buffer in
SYSRAM was always correct, while corruption appeared only after copying that
data into DDR using byte-wise writes such as memcpy. When DDR was written using
explicit, 32-bit aligned word accesses, the corruption disappeared entirely.
Ensuring that all DDR writes are word-sized and properly aligned provided a full
workaround for the issue and restored correct, reproducible SD card operation on
the Rev A custom board. (The issue is likely due to a mask/strobe swap in the
DDR wiring; see
<a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">this</a> for
details.)</p>
<h3 id="usb">USB</h3>
<p><em>Note: read the full USB story
<a href="https://embd.cc/usb-bringup-on-custom-stm32mp135-board">here</a>.</em></p>
<p>Getting USB working on a custom STM32MP135 board involved a few key hardware and
software steps. First, I enabled the USBHS power switch by adding a
current-limit resistor so the PHY would receive power. On the board, I removed
the permanent 1.5 kΩ pullup on the D+ line to allow proper High-Speed
enumeration. I also ensured JTAG worked reliably by booting in engineering debug
mode and verifying the vector table took interrupts in ARM mode.</p>
<p>On the software side, I disabled VBUS sensing in the HAL PCD initialization to
match the externally powered board, configured the Rx/Tx FIFOs, and made sure
all required USB interrupts were correctly handled. For the USB Device stack, I
added the necessary callbacks in <code>usbd_conf.c</code> and applied volatile casts to
ensure 32-bit accesses to SYSRAM were aligned, avoiding Data Aborts.</p>
<p>Finally, I verified proper memory alignment for DDR writes to ensure file
transfers worked without byte shuffling, and confirmed enumeration and data
transfers at High-Speed using a good USB cable and port. After these steps, the
board enumerated correctly as an MSC device, and read/write operations
functioned reliably.</p>
<h3 id="switch-to-non-secure-world">Switch to Non-Secure World</h3>
<p><em>Note: read the full TrustZone story
<a href="https://embd.cc/unsecuring-stm32mp135-trustzone">here</a>.</em></p>
<p>The STM32MP135 integrates the Arm TrustZone extension which partitions the
system into two isolated security domains, the secure and non-secure worlds,
depending on the state of the <code>NS</code> bit in the <code>SCR</code> register. Before the bit is
flipped, we need to unsecure many parts of the SoC (DDR, DMA masters, etc).</p>
<h3 id="debug-linux-early-boot">Debug Linux early boot</h3>
<p>Since Linux is just another program, why not try and run it, now that we have
disabled most secure-world hindrances? One thing to keep in mind is to respect
the link address:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>readelf<span class="w"> </span>-h<span class="w"> </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>Entry
<span class="w">  </span>Entry<span class="w"> </span>point<span class="w"> </span>address:<span class="w">               </span>0xc0008000
</pre></div>
</code></pre>
<p>Let’s copy the binary instructions from the ELF file into something we can load
into memory:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>arm-none-eabi-objcopy<span class="w"> </span>-O<span class="w"> </span>binary<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/images/vmlinux.bin
</pre></div>
</code></pre>
<p>Now we place the binary file in the same SD card image as the bootloader:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span>build/vmlinux.bin

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
</pre></div>
</code></pre>
<p>Load the ~40,000 blocks from logical block address (LBA) 324 into DDR to
location <code>0xC0008000</code>, and jump to it. If we follow along with the debug probe,
we see that the kernel begins executing in <code>arch/arm/kernel/head.S</code> and gets
stuck when it realizes that we did not pass it the correct boot parameters.</p>
<h3 id="provide-a-device-tree-blob">Provide a Device Tree Blob</h3>
<p>Let’s start with the default DTB and decompile it into the DTS:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="o">[</span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>dtc<span class="w"> </span>-I<span class="w"> </span>dtb<span class="w"> </span>-O<span class="w"> </span>dts<span class="w"> </span>-@<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>output/build/linux-custom/arch/arm/boot/dts/stm32mp135f-dk.dtb<span class="w"> </span>&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>~/temp/build/min.dts
</pre></div>
</code></pre>
<p>Now remove as much of the unnecessary peripherals from the device tree and
compile back into a DTB:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>dtc<span class="w"> </span>-I<span class="w"> </span>dts<span class="w"> </span>-O<span class="w"> </span>dtb<span class="w"> </span>min.dts<span class="w"> </span>&gt;<span class="w"> </span>min.dtb
</pre></div>
</code></pre>
<p>Next, we need to include this DTB in the SD card image:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>build/vmlinux.bin<span class="w"> </span>build/min.dtb

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
min.dtb<span class="w">                   </span><span class="m">37652</span><span class="w">    </span><span class="m">53248</span><span class="w">      </span><span class="m">105</span>
</pre></div>
</code></pre>
<p>Write the new image to the SD card, and boot the bootloader, and copy the kernel
and the DTB to DDR:</p>
<pre><code><div class="codehilite"><pre><span></span>&gt; l 40000 324 0xc0008000
Copying 40000 blocks from LBA 324 to DDR addr 0xC0008000 ...
&gt; l 105 37652 0xc2008000
Copying 105 blocks from LBA 37652 to DDR addr 0xC2008000 ...
&gt; p 256 0xc2008000
0x00000000 : d0 0d fe ed  00 00 ce 12  00 00 00 38  00 00 bc c4  ...........8....
0x00000010 : 00 00 00 28  00 00 00 11  00 00 00 10  00 00 00 00  ...(............
0x00000020 : 00 00 11 4e  00 00 bc 8c  00 00 00 00  00 00 00 00  ...N............
0x00000030 : 00 00 00 00  00 00 00 00  00 00 00 01  00 00 00 00  ................
0x00000040 : 00 00 00 03  00 00 00 04  00 00 00 00  00 00 00 01  ................
0x00000050 : 00 00 00 03  00 00 00 04  00 00 00 0f  00 00 00 01  ................
0x00000060 : 00 00 00 03  00 00 00 32  00 00 00 1b  53 54 4d 69  .......2....STMi
0x00000070 : 63 72 6f 65  6c 65 63 74  72 6f 6e 69  63 73 20 53  croelectronics S
</pre></div>
</code></pre>
<p>We can match the print against the DTB hexdump to verify that it’s been written
correctly (note the “d00dfeed” at the start of the DTB). Then issue the <code>j</code> or
<code>jump</code> instruction, and follow along with the debugger:</p>
<pre><code><div class="codehilite"><pre><span></span>gdb)
69         push  {r4} // CPSR after return
(gdb) del
(gdb) si
sm_smc_entry () at src/handoff.S:70
70         push  {r3} // PC after return
(gdb)
sm_smc_entry () at src/handoff.S:71
71         rfefd sp
(gdb)
0xc0008000 in ?? ()
(gdb) file build/vmlinux
Reading symbols from build/vmlinux...
(gdb) si
__hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
73      arch/arm/kernel/hyp-stub.S: No such file or directory.
(gdb) directory build/linux-custom
Source directories searched: build/linux-custom;$cdir;$cwd
(gdb) si
0xc01149a4      73              store_primary_cpu_mode  r4, r5
</pre></div>
</code></pre>
<p>Above we see the last three instructions from the bootloader, and then we need
to switch GDB to the Linux kernel executable, and provide it the source code
directory. Then, we see one of the first instructions from the kernel being
executed, on line 73 of <code>hyp-stub.S</code>.</p>
<p>Step instruction (<code>si</code>) a couple times until we reach the branch to
<code>__vet_atags</code>. That routine is responsible to determine the validity of the <code>r2</code>
pointer that the bootloader is supposed to point to where we copied the DTB in
the memory. Let’s see what happens:</p>
<pre><code><div class="codehilite"><pre><span></span>__vet_atags () at arch/arm/kernel/head-common.S:44
44              tst     r2, #0x3                        @ aligned?
45              bne     1f
47              ldr     r5, [r2, #0]
49              ldr     r6, =OF_DT_MAGIC                @ is it a DTB?
50              cmp     r5, r6
51              beq     2f
61      2:      ret     lr                              @ atag/dtb pointer is ok
</pre></div>
</code></pre>
<p>Evidently the DTB pointer is good! Now we return back to the startup code and
proceed with enabling MMU, clearing memory, etc. I got tired of single-stepping
through <code>memset</code> and hit continue, and was amazed to find the following on the
serial monitor:</p>
<pre><code><div class="codehilite"><pre><span></span>[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.1.28 (jk@SRS1720) (arm-buildroot-linux-uclibcgnueabihf-gcc.br_real (Buildroot 2024.11-202-g3645e3b781-dirty) 13.3.0, GNU ld (GNU Binutils) 2.42) #1 SMP PREEMPT Thu Dec 18 17:02:40 PST 2025
[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d
[    0.000000] CPU: div instructions available: patching division code
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
[    0.000000] OF: fdt: Machine model: STMicroelectronics STM32MP135F-DK Discovery Board
[    0.000000] Memory policy: Data cache writealloc
[    0.000000] cma: Reserved 64 MiB at 0xdc000000
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000]   HighMem  empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000] Initmem setup node 0 [mem 0x00000000c0000000-0x00000000dfffffff]
</pre></div>
</code></pre>
<p>In other words: <em>IT WORKS!!!</em></p>
<h3 id="discussion">Discussion</h3>
<p>There’s an important step that had to take place before the “blink” example
could run on the custom board: <em>let go of the sheer excitement</em>. Having worked
on or with some kind of a Linux system for perhaps two decades, it was an almost
surreal, mystical feeling to hold in my hands a board that I designed myself
that is supposed to run the operating system. It’s what makes engineering a
rewarding experience, but the mental jitter of it can also interfere with
getting things done. After all, this is just routine work!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><em>6. This article</em></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page3.html">← Older articles</a></div>
        <div><a class="newer" href="index.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
