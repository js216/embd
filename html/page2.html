<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="let-reality-update-you">Let Reality Update You</a></h2>
<div class="article-meta">Published 5 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/arc.jpg"/></p>
<p>Reality always makes sense because it is reality. When our ideas of it do not
correspond to it, it’s the ideas that are suspect.</p>
<p>Insofar as our understanding involves a mapping of the fluid reality to fixed
ideas, we will always end up confused when refusing to let go of fixed ideas
that have lost their relevance.</p>
<p>Staying flexible in thought is a form of mental hygiene.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Agents</div>
<h2><a href="agent-to-read-datasheets">Agent To Read Electronic Datasheets</a></h2>
<div class="article-meta">Published 2 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/pa.jpg"/></p>
<p>When an electronic design company accumulates large amounts of inventory, it can
become overwhelming for engineers to go through the thousands of parts to find
the one needed in a new design. Instead, they are likely to select a new part
from one of the distributors that have a better search engine. This leads to an
ever growing inventory: parts kept in stock and never used, a constant departure
from the ideal of having a “lean” operation.</p>
<p>Nowadays, with everyone creating their own “agent” for just about anything, I
wondered how hard it would be to create my own search engine. This article
represents a day of work, proving that structured data extraction from
semi-unstructured sources like datasheets has become almost a trivial problem.</p>
<p>I took the <a href="https://deepmind.google/models/gemma/gemma-3/">Gemma 3</a> model (12B
parameters, 3-bit quantization) from Google, ran it in the
<a href="https://github.com/ggml-org/llama.cpp">llama.cpp</a> inference framework, and fed
it the datasheet for an opamp. To extract the text from the PDFs, I used the
<a href="https://www.docling.ai/">Docling</a> Python library from IBM research. The output,
generated in about four minutes on a GPU with 8 GB of memory, will be in this
format for now:</p>
<pre><code class="language-json"><div class="codehilite"><pre><span></span><span class="nt">"PSRR (Input offset voltage versus power supply)"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nt">"min"</span><span class="p">:</span><span class="w"> </span><span class="mi">65</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"typ"</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"max"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span>
<span class="w">   </span><span class="nt">"unit"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dB"</span>
<span class="w"> </span><span class="p">},</span>
</pre></div>
</code></pre>
<p>Let’s get started!</p>
<h3 id="running-the-model">Running the model</h3>
<p>Obtain and build llama.cpp:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/ggerganov/llama.cpp
<span class="nb">cd</span><span class="w"> </span>llama.cpp
cmake<span class="w"> </span>-B<span class="w"> </span>build<span class="w"> </span>-S<span class="w"> </span>.<span class="w"> </span>-DGGML_CUDA<span class="o">=</span>ON
cmake<span class="w"> </span>--build<span class="w"> </span>build<span class="w"> </span>-j
</pre></div>
</code></pre>
<p>Obtain the <a href="https://huggingface.co/bartowski/google_gemma-3-12b-it-GGUF">Gemma
3</a> model.</p>
<p>Start the LLM server:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>llama-server<span class="w"> </span>-m<span class="w"> </span>~/temp/gemma-3-12b-it-UD-IQ3_XXS.gguf<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>--port<span class="w"> </span><span class="m">8080</span><span class="w"> </span>-c<span class="w"> </span><span class="m">4096</span><span class="w"> </span>-ngl<span class="w"> </span><span class="m">999</span>
</pre></div>
</code></pre>
<p>Open <code>localhost:8080</code> and feel free to chat with the model. How simple things
have become!</p>
<h3 id="get-datasheet-text">Get datasheet text</h3>
<p>Next, we need to convert the datasheets from the PDF format into plain text that
we can feed to the model. Assuming <code>docling</code> is installed (install it with Pip
if not), we can define the following function to convert the documents:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">docling.document_converter</span> <span class="kn">import</span> <span class="n">DocumentConverter</span>

<span class="k">def</span> <span class="nf">convert_pdf_to_markdown</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">):</span>
    <span class="n">pdf_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">pdf_file</span><span class="p">)</span>
    <span class="n">converter</span> <span class="o">=</span> <span class="n">DocumentConverter</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">pdf_path</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">export_to_markdown</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>This yields the output in a Markdown format.</p>
<h3 id="define-agent-with-a-simple-prompt">Define agent with a simple prompt</h3>
<p>Here’s the best part: the “source code” for the agent is in plain English. Here
it is in its entirety:</p>
<pre><code><div class="codehilite"><pre><span></span>You are a datasheet specification extraction agent. Your
only job is to extract specifications.

OUTPUT FORMAT:
{
  "Full parameter name (short name)": {
    "min": number or null,
    "typ": number or null,
    "max": number or null,
    "unit": "string"
  }
}

EXTRACTION RULES:
- Always include both the full and short spec name in the key.
- Full name goes first, and short name in brackets: "Operating Temperature (T)"
- If a typ value is a range like "-11.5 to 14.5", split it: min=-11.5, max=14.5
- Convert scientific notation: "10 12" → 1e12
- Convert ± values into min/max fields
- Omit parameters with no numeric values (all null)
- Omit footnotes like (1) and (2)
- If no specifications exist, return: {}

CRITICAL OUTPUT RULES:
- Return ONLY valid JSON
- NO explanations
- NO descriptions
- NO phrases like "this section", "no specifications", "I will skip"
- NO text before or after the JSON
- NO markdown code blocks
- Just the raw JSON object
</pre></div>
</code></pre>
<p>The insistence on pure JSON is a hack to make it stop being too chatty. There’s
probably a more sophisticated way to do it, but for a first attempt it’ll do
just fine.</p>
<h3 id="chunking">“Chunking”</h3>
<p>The datasheet conversion from PDF includes lots of unnecessary text like
document version information, copyright, ordering information. For now, we’d
like to get just the electronic specifications. As a first approximation, assume
that the information is always present in tables only.</p>
<p>ChatGPT assures me that the following regex magic will extract tables from a
Markdown document:</p>
<pre><code class="language-python"><div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="k">def</span> <span class="nf">get_chunks</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Return a list of Markdown tables as strings from a file."""</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">"(?:^\|.*\|\s*\n)"</span>           <span class="c1"># Header row</span>
        <span class="sa">r</span><span class="s2">"(?:^\|[-:\s|]+\|\s*\n)"</span>     <span class="c1"># Separator row</span>
        <span class="sa">r</span><span class="s2">"(?:^\|.*\|\s*\n?)+"</span><span class="p">,</span>        <span class="c1"># Body rows</span>
        <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span>
    <span class="p">)</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">table_pattern</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">]</span>
</pre></div>
</code></pre>
<h3 id="putting-it-together">Putting it together</h3>
<p>We have all the pieces now: text data in small pieces, a model, the prompt to
define an agent. Now just iterate over all the chunks as defined above, send
them to the model together with the prompt, and observe what comes out. To
automate the process from PDF to the final JSON, I used a Makefile defining the
recipes for the three steps of the transformation. All of this is too
straightforward to be worth including here.</p>
<p>For anyone interested, find the entire code presented above
<a href="https://github.com/js216/sfap">here</a>.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Self-Change</div>
<h2><a href="emptiness-constraint-actually-doing-things">On Emptiness, Constraint, and Doing Things</a></h2>
<div class="article-meta">Published 23 Dec 2025. Written by Jakob Kastelic and GPT-5.</div>
<p><img alt="" src="../images/roy.jpg"/></p>
<p>There’s a <a href="https://embd.cc/limitation-is-freedom">recurring</a> paradox in life:
when forced into constraint—normally in the office—it’s easy to get a
surprising amount of work done. When free—at home, with a desk full of
possibilities—I do almost nothing. Probably most people have felt this:
paralyzed by options, not liberated by freedom.</p>
<p>In the office, there’s a clear system. Hours, tasks, deadlines. None of these
promise joy or meaning. You just show up, pick the thing that needs to be done,
and do it. Often it’s boring, sometimes hard, sometimes fun—but mostly it’s
ordinary execution. And it gets done, the meaning/joy shows up later, if it
does. In other words, meaning is retrospective, not prospective.</p>
<h3 id="the-problem">The Problem</h3>
<p>At home, when anyone could be the architect of their own life—at least in
theory—everything feels like a potential project rather than a commitment.
There’s a long list of things to do someday. You start something, lose
interest, start something else, lose interest there too. The pile grows. The
mind feels like a full cup, overflowing, useless as a vessel since it has no
volume available. I had a lot of energy running toward the possibility of
things, and none toward actually doing any of them.</p>
<p>There are all these things to do, but when the time came, I would just scroll
through random websites and stuff.  Not for lack of desire but because every
possibility was simultaneously “urgent” and none had any context, boundary, or
commitment. I was waiting for the meaning to arrive—expecting to feel it
first, and act second. A kind of dopamine-before-action loop that never
materializes, because dopamine isn’t a starting signal; it’s a reward signal
after progress has been made.</p>
<p>I recently realized this was not a motivational problem but a structural one.
The <code>ideas.txt</code> file, where the latest projects and ideas get stored, was
effectively a home version of what at work would be called <code>unnecessary.txt</code>: a
repository of work items that don’t currently need attention (see <a href="https://embd.cc/yes-no-productivity">this
article</a> for more on this approach). But
because at home all of those things are regarded as “alive”, they were
cluttering the “mental desk”, competing for attention and claiming emotional
validity. This is exactly how productivity systems fail: they mistake interest
with execution rights. You think something is alive because you wrote it down.
That creates mental load.</p>
<p>So I enforced a constraint.</p>
<h3 id="a-solution-one-hobby-at-a-time">A Solution: One Hobby at a Time</h3>
<p>I adapted this: Only one productive leisure project gets execution rights at a
time. The rest become cold archive—“not right now, maybe later.” They live in
<code>ideas.txt</code>, not in the working memory.</p>
<p>This is not suppression of curiosity. It’s admission control, a bit like the WIP
limits (the kanban-style work in progress caps, see below) that enforce unity of
purpose and prevent jamming the “system” with too many requirements.</p>
<p>The curious thing: once all the other activities besides the “One Hobby” became
off-limits to tracking and obligation, they lost their psychological “landmine”
quality. They became playful again, instead of competing for real estate in the
head. Then they were constantly evaluated, compared, prioritized—a swarm of
partial commitments without form or finish.</p>
<h3 id="productive-vs-restorative-leisure">Productive vs Restorative Leisure</h3>
<p>That distinction matters.</p>
<p>Productive Leisure is an activity that:</p>
<ul>
<li>can be tracked for progress,</li>
<li>has future implications or expectations,</li>
<li>competes for mental slots,</li>
<li>produces artifacts, skill growth, or structured outcomes.</li>
</ul>
<p>These are the things that can fill up the mind if left unconstrained.</p>
<p>In contrast, restorative Leisure is play without future stakes:</p>
<ul>
<li>no tracking,</li>
<li>no backlog,</li>
<li>no scorecards,</li>
<li>activities done for their own sake.</li>
</ul>
<p>Once Productive Leisure items were formally demoted to “cold archive unless
active,” many of them felt like Restorative Leisure: something you might do
because it’s pleasant, not something you have to do to avoid guilt or loss.</p>
<p>This distinction mirrors the essence of constraint in productivity: by making
clear what counts and what doesn’t, you reduce the cognitive load of
decision-making and let intentional action happen.</p>
<h3 id="kanban">Kanban</h3>
<p>Kanban, in its original form at Toyota, was a simple, physical system for
managing production flow on the factory floor using cards that each represented
permission to produce or move a specific part. Rather than relying on schedules,
forecasts, or manager oversight, kanban used these tangible cards to regulate
when work could start and when it could move forward. The system naturally
enforced limits on how much unfinished work could exist at any moment.</p>
<p>The key irony is that the system makes work more productive by <em>preventing</em>
work, that is, an excess of work. Each step in the production line is governed
by a small number of physical kanban cards, and a task cannot move forward
unless a card is available. It recognizes that no worker or process has infinite
capacity and it helps no one to pretend otherwise. Bottlenecks become visible
immediately, there is no illusion of productivity or busy-work, queues cannot
silently grow, and problems are forced to surface where they actually occur.</p>
<p>Fewer parallel tasks means less context switching, faster feedback, and higher
quality, since defects were discovered close to their source. Crucially, kanban
does not rely on motivation, discipline, or managerial pressure; it embedded
restraint directly into the environment. The tokens made overcommitment
impossible, and in doing so created the emptiness in which steady, reliable work
could actually happen.</p>
<h3 id="taoist-emptiness-and-functional-capacity">Taoist Emptiness and Functional Capacity</h3>
<p>I was struck by how this aligned with a very old idea: the usefulness of
emptiness:</p>
<blockquote>
<p>I do my utmost to attain emptiness; I hold firmly to stillness. The myriad
creatures all rise together And I watch their return. [Tao Te Ching, 16]</p>
<p>The way never acts yet nothing is left undone. [37]</p>
<p>The Master does nothing, yet he leaves nothing undone. The ordinary man is
always doing things, yet many more are left to be done. [38]</p>
</blockquote>
<p>The Taoists observed that a cup is useful because it is empty; a room is useful
because it has space. When something gets completely full, it loses its
usefulness. The same applied to the “mental desk”: when it was totally full of
half-alive things, it became rigid, dead, and useless.</p>
<p>In this emptiness—not the absence of goals, but the absence of competing
commitments—things can actually happen. You don’t wait for meaning; you let
meaning emerge from action.</p>
<p>“The Way does nothing, yet leaves nothing undone.” Action arises unforced when
the system isn’t cluttered with demands, comparisons, and anticipation.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The system distilled down to a simple invariant:</p>
<ul>
<li>Only one productive leisure activity is alive in the present.</li>
<li>Everything else is archived.</li>
<li>Restorative activities are permissionless.</li>
<li>Progress, not aspiration, drives meaning.</li>
</ul>
<p>In other words, <em>interest does not grant execution rights</em>. Execution rights
must be scarce, just like kanban tokens. When they are, things get done; when
they’re abundant, nothing happens.</p>
<p>In this system, willpower or motivation became almost irrelevant. When the mind
is freed from the need to do “everything”, the intention can take over. This
kind of intentional action, in my experience, only works when there’s very few
intentions to compete with each other.</p>
<p>Emptiness isn’t the absence of desires. It’s the absence of conflicting claims
on your attention. Start there, and you can actually practice something.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="linux-bringup-on-custom-stm32mp135-board">Linux Bring-Up on a Custom STM32MP135 Board</a></h2>
<div class="article-meta">Published 22 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/vt.jpg"/></p>
<p><em>This is Part 6 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>This is a record of steps I took to successfully get Linux past the early boot
stage on my custom board using the STM32MP135 SoC. (Schematics, PCB design
files, and code available in this
<a href="https://github.com/js216/stm32mp135_test_board">repository</a>.) The write-up is
in approximate chronological order, written as I go through the debugging steps.</p>
<h3 id="blink">Blink</h3>
<p>I had previously put together a simple bare-metal
<a href="https://github.com/js216/mp135_boot/tree/main/blink_noide">program</a> that runs
on the STM32MP135 evaluation board and just blinks the LED. To work on the
custom board, I needed only to remove anything to do with the STPMIC1 and LSE
clock (the low-speed external 32.768 kHz clock), since I did not place these
parts on my board. The <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/blink">resulting
code</a>
is pretty simple modulo complexity inherited from the ST drivers.</p>
<p>To download the code, I talked directly to the ROM bootloader on the SoC. See
<a href="boot-stm32mp135-over-uart-with-python">this article</a> for details.</p>
<h3 id="ddr">DDR</h3>
<p>Again, I had previously put together a <a href="https://github.com/js216/mp135_boot/tree/main/ddr_test">simple
program</a> to test the DDR
on the evaluation board. It fills the memory entirely with pseudorandom bits
(PRBS-31), and then reads it out, checking that the data matches.</p>
<p>For the custom board, the program had to be modified similarly as with blink
(remove STPMIC1, LSE clock) and then it ran. <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/ddr_test">(Click for
code.)</a></p>
<p>There was an issue: all data read back was wrong and subtly corrupted. I double
checked the wiring, DDR parameter configuration (I use the same DDR as the eval
board, so what could it be!?), the code—only to realize the board was not
getting enough current on the 1.35V power supply. With more power, everything
<em>just worked</em>!</p>
<h3 id="jtag">JTAG</h3>
<p>For JTAG loading it appears to be essential to select “Development boot” (also
called “Engineering boot”) by selecting the boot pins in the <code>100</code> setting. The
datasheet says this mode is used “Used to get debug access without boot from
flash memory”.</p>
<p>There is also a footnote that says that the core is “in infinite loop toggling
PA13”, but I did not observe the toggling in the “dev boot” mode, even though it
is of course present (but not documented) in the normal UART boot mode (pins =
<code>000</code>).</p>
<p><img alt="" src="../images/jtag.jpg"/></p>
<p>Unfortunately I covered the J-Link connector with solder mask. After trying to
carefully scratch it off using a sewing needle, the connection appears to be
intermittent. Sometimes J-Link was able to download the DDR test program to the
SYSRAM, but most of the time it couldn’t. Probably it would work just fine if it
wasn’t for the soldermask covering. I wish I had just used a normal pin-header
connector rather than the J-Link needle adapter. So, I’ll have to use UART boot
mode for now, and hope that I can get the (much faster) USB mode to work.</p>
<h3 id="sd">SD</h3>
<p><em>Note: read the full SD card story
<a href="https://embd.cc/sdcard-on-bare-metal-stm32mp135">here</a>.</em></p>
<p>On the STM32MP135 evaluation board, an SDMMC example reliably reads a program
from an SD card into DDR and executes it, but porting the same code to a custom
board exposed a failure during SD initialization. Although command-level
communication succeeded—CMD0, CMD8, CMD55, and ACMD41 all completed normally and
the card identified as SDHC—the sequence consistently failed later in
<code>SD_SendSDStatus</code> with <code>SDMMC_FLAG_DTIMEOUT</code>. Hardware checks showed that SD
card power, SDMMC I/O domain voltages, and signal levels all matched the
evaluation board, with clean 3.3 V logic and a low clock rate of about 1.56 MHz.
The decisive difference turned out to be signal pull-ups: the evaluation board
routes SD signals through an ESD device with built-in pull-ups, whereas the
custom board did not. Enabling internal pull-ups on the SD data lines eliminated
the data timeout and allowed SD reads to proceed, confirming that missing
pull-ups were responsible for the initialization failure.</p>
<p>However, once SD transfers succeeded, the data read from the card appeared
corrupted in DDR: roughly every other byte was intermittently wrong, always off
by exactly two, independent of bus width, clock edge, power supply, or signal
integrity. The critical observation was that data read into a static buffer in
SYSRAM was always correct, while corruption appeared only after copying that
data into DDR using byte-wise writes such as memcpy. When DDR was written using
explicit, 32-bit aligned word accesses, the corruption disappeared entirely.
Ensuring that all DDR writes are word-sized and properly aligned provided a full
workaround for the issue and restored correct, reproducible SD card operation on
the Rev A custom board. (The issue is likely due to a mask/strobe swap in the
DDR wiring; see
<a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">this</a> for
details.)</p>
<h3 id="usb">USB</h3>
<p><em>Note: read the full USB story
<a href="https://embd.cc/usb-bringup-on-custom-stm32mp135-board">here</a>.</em></p>
<p>Getting USB working on a custom STM32MP135 board involved a few key hardware and
software steps. First, I enabled the USBHS power switch by adding a
current-limit resistor so the PHY would receive power. On the board, I removed
the permanent 1.5 kΩ pullup on the D+ line to allow proper High-Speed
enumeration. I also ensured JTAG worked reliably by booting in engineering debug
mode and verifying the vector table took interrupts in ARM mode.</p>
<p>On the software side, I disabled VBUS sensing in the HAL PCD initialization to
match the externally powered board, configured the Rx/Tx FIFOs, and made sure
all required USB interrupts were correctly handled. For the USB Device stack, I
added the necessary callbacks in <code>usbd_conf.c</code> and applied volatile casts to
ensure 32-bit accesses to SYSRAM were aligned, avoiding Data Aborts.</p>
<p>Finally, I verified proper memory alignment for DDR writes to ensure file
transfers worked without byte shuffling, and confirmed enumeration and data
transfers at High-Speed using a good USB cable and port. After these steps, the
board enumerated correctly as an MSC device, and read/write operations
functioned reliably.</p>
<h3 id="switch-to-non-secure-world">Switch to Non-Secure World</h3>
<p><em>Note: read the full TrustZone story
<a href="https://embd.cc/unsecuring-stm32mp135-trustzone">here</a>.</em></p>
<p>The STM32MP135 integrates the Arm TrustZone extension which partitions the
system into two isolated security domains, the secure and non-secure worlds,
depending on the state of the <code>NS</code> bit in the <code>SCR</code> register. Before the bit is
flipped, we need to unsecure many parts of the SoC (DDR, DMA masters, etc).</p>
<h3 id="debug-linux-early-boot">Debug Linux early boot</h3>
<p>Since Linux is just another program, why not try and run it, now that we have
disabled most secure-world hindrances? One thing to keep in mind is to respect
the link address:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>readelf<span class="w"> </span>-h<span class="w"> </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>Entry
<span class="w">  </span>Entry<span class="w"> </span>point<span class="w"> </span>address:<span class="w">               </span>0xc0008000
</pre></div>
</code></pre>
<p>Let’s copy the binary instructions from the ELF file into something we can load
into memory:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>arm-none-eabi-objcopy<span class="w"> </span>-O<span class="w"> </span>binary<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/images/vmlinux.bin
</pre></div>
</code></pre>
<p>Now we place the binary file in the same SD card image as the bootloader:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span>build/vmlinux.bin

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
</pre></div>
</code></pre>
<p>Load the ~40,000 blocks from logical block address (LBA) 324 into DDR to
location <code>0xC0008000</code>, and jump to it. If we follow along with the debug probe,
we see that the kernel begins executing in <code>arch/arm/kernel/head.S</code> and gets
stuck when it realizes that we did not pass it the correct boot parameters.</p>
<h3 id="provide-a-device-tree-blob">Provide a Device Tree Blob</h3>
<p>Let’s start with the default DTB and decompile it into the DTS:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="o">[</span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>dtc<span class="w"> </span>-I<span class="w"> </span>dtb<span class="w"> </span>-O<span class="w"> </span>dts<span class="w"> </span>-@<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>output/build/linux-custom/arch/arm/boot/dts/stm32mp135f-dk.dtb<span class="w"> </span>&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>~/temp/build/min.dts
</pre></div>
</code></pre>
<p>Now remove as much of the unnecessary peripherals from the device tree and
compile back into a DTB:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>dtc<span class="w"> </span>-I<span class="w"> </span>dts<span class="w"> </span>-O<span class="w"> </span>dtb<span class="w"> </span>min.dts<span class="w"> </span>&gt;<span class="w"> </span>min.dtb
</pre></div>
</code></pre>
<p>Next, we need to include this DTB in the SD card image:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>build/vmlinux.bin<span class="w"> </span>build/min.dtb

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
min.dtb<span class="w">                   </span><span class="m">37652</span><span class="w">    </span><span class="m">53248</span><span class="w">      </span><span class="m">105</span>
</pre></div>
</code></pre>
<p>Write the new image to the SD card, and boot the bootloader, and copy the kernel
and the DTB to DDR:</p>
<pre><code><div class="codehilite"><pre><span></span>&gt; l 40000 324 0xc0008000
Copying 40000 blocks from LBA 324 to DDR addr 0xC0008000 ...
&gt; l 105 37652 0xc2008000
Copying 105 blocks from LBA 37652 to DDR addr 0xC2008000 ...
&gt; p 256 0xc2008000
0x00000000 : d0 0d fe ed  00 00 ce 12  00 00 00 38  00 00 bc c4  ...........8....
0x00000010 : 00 00 00 28  00 00 00 11  00 00 00 10  00 00 00 00  ...(............
0x00000020 : 00 00 11 4e  00 00 bc 8c  00 00 00 00  00 00 00 00  ...N............
0x00000030 : 00 00 00 00  00 00 00 00  00 00 00 01  00 00 00 00  ................
0x00000040 : 00 00 00 03  00 00 00 04  00 00 00 00  00 00 00 01  ................
0x00000050 : 00 00 00 03  00 00 00 04  00 00 00 0f  00 00 00 01  ................
0x00000060 : 00 00 00 03  00 00 00 32  00 00 00 1b  53 54 4d 69  .......2....STMi
0x00000070 : 63 72 6f 65  6c 65 63 74  72 6f 6e 69  63 73 20 53  croelectronics S
</pre></div>
</code></pre>
<p>We can match the print against the DTB hexdump to verify that it’s been written
correctly (note the “d00dfeed” at the start of the DTB). Then issue the <code>j</code> or
<code>jump</code> instruction, and follow along with the debugger:</p>
<pre><code><div class="codehilite"><pre><span></span>gdb)
69         push  {r4} // CPSR after return
(gdb) del
(gdb) si
sm_smc_entry () at src/handoff.S:70
70         push  {r3} // PC after return
(gdb)
sm_smc_entry () at src/handoff.S:71
71         rfefd sp
(gdb)
0xc0008000 in ?? ()
(gdb) file build/vmlinux
Reading symbols from build/vmlinux...
(gdb) si
__hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
73      arch/arm/kernel/hyp-stub.S: No such file or directory.
(gdb) directory build/linux-custom
Source directories searched: build/linux-custom;$cdir;$cwd
(gdb) si
0xc01149a4      73              store_primary_cpu_mode  r4, r5
</pre></div>
</code></pre>
<p>Above we see the last three instructions from the bootloader, and then we need
to switch GDB to the Linux kernel executable, and provide it the source code
directory. Then, we see one of the first instructions from the kernel being
executed, on line 73 of <code>hyp-stub.S</code>.</p>
<p>Step instruction (<code>si</code>) a couple times until we reach the branch to
<code>__vet_atags</code>. That routine is responsible to determine the validity of the <code>r2</code>
pointer that the bootloader is supposed to point to where we copied the DTB in
the memory. Let’s see what happens:</p>
<pre><code><div class="codehilite"><pre><span></span>__vet_atags () at arch/arm/kernel/head-common.S:44
44              tst     r2, #0x3                        @ aligned?
45              bne     1f
47              ldr     r5, [r2, #0]
49              ldr     r6, =OF_DT_MAGIC                @ is it a DTB?
50              cmp     r5, r6
51              beq     2f
61      2:      ret     lr                              @ atag/dtb pointer is ok
</pre></div>
</code></pre>
<p>Evidently the DTB pointer is good! Now we return back to the startup code and
proceed with enabling MMU, clearing memory, etc. I got tired of single-stepping
through <code>memset</code> and hit continue, and was amazed to find the following on the
serial monitor:</p>
<pre><code><div class="codehilite"><pre><span></span>[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.1.28 (jk@SRS1720) (arm-buildroot-linux-uclibcgnueabihf-gcc.br_real (Buildroot 2024.11-202-g3645e3b781-dirty) 13.3.0, GNU ld (GNU Binutils) 2.42) #1 SMP PREEMPT Thu Dec 18 17:02:40 PST 2025
[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d
[    0.000000] CPU: div instructions available: patching division code
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
[    0.000000] OF: fdt: Machine model: STMicroelectronics STM32MP135F-DK Discovery Board
[    0.000000] Memory policy: Data cache writealloc
[    0.000000] cma: Reserved 64 MiB at 0xdc000000
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000]   HighMem  empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000] Initmem setup node 0 [mem 0x00000000c0000000-0x00000000dfffffff]
</pre></div>
</code></pre>
<p>In other words: <em>IT WORKS!!!</em></p>
<h3 id="discussion">Discussion</h3>
<p>There’s an important step that had to take place before the “blink” example
could run on the custom board: <em>let go of the sheer excitement</em>. Having worked
on or with some kind of a Linux system for perhaps two decades, it was an almost
surreal, mystical feeling to hold in my hands a board that I designed myself
that is supposed to run the operating system. It’s what makes engineering a
rewarding experience, but the mental jitter of it can also interfere with
getting things done. After all, this is just routine work!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><em>6. This article</em></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="unsecuring-stm32mp135-trustzone">Unsecuring STM32MP135 TrustZone</a></h2>
<div class="article-meta">Published 21 Dec 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/mia.jpg"/></p>
<p>The STM32MP135 integrates the Arm TrustZone extension which partitions the
system into two isolated security domains, the secure and non-secure worlds,
depending on the state of the <code>NS</code> bit. On reset, it executes in the secure
world (<code>NS=0</code>), but in normal operation, we want <code>NS=1</code>.</p>
<p>In this article, we explain how to execute the world transitions in a bare-metal
environment. See <a href="https://embd.cc/stm32mp135-without-optee">this article</a> to
learn how to do it in the context of Arm Trusted Firmware (TF-A) and Linux.</p>
<h3 id="change-worlds-with-smc-handler">Change worlds with SMC handler</h3>
<p>The <code>NS</code> bit is only supposed to be flipped in the Secure Monitor handler,
invoked with the <code>smc</code> instruction. Thus a minimum handler might look as follows
(assumes the return address is passed in via <code>r3</code>):</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="na">.align</span><span class="w"> </span><span class="mi">2</span>
<span class="nl">sm_smc_entry:</span>
<span class="w">   </span><span class="nf">mrc</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// read SCR</span>
<span class="w">   </span><span class="nf">orr</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="c1">#SCR_NS</span>
<span class="w">   </span><span class="nf">mcr</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// write SCR</span>
<span class="w">   </span><span class="nf">mov</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="mi">#0</span>

<span class="w">   </span><span class="nf">mov</span><span class="w"> </span><span class="no">r4</span><span class="p">,</span><span class="w"> </span><span class="c1">#(CPSR_MODE_SVC | CPSR_I | CPSR_F)</span>
<span class="w">   </span><span class="nf">push</span><span class="w">  </span><span class="p">{</span><span class="no">r4</span><span class="p">}</span><span class="w"> </span><span class="c1">// CPSR after return</span>
<span class="w">   </span><span class="nf">push</span><span class="w">  </span><span class="p">{</span><span class="no">r3</span><span class="p">}</span><span class="w"> </span><span class="c1">// PC after return</span>
<span class="w">   </span><span class="nf">rfefd</span><span class="w"> </span><span class="no">sp</span>
</pre></div>
</code></pre>
<p>We see that the <code>NS</code> bit lives in the <code>SCR</code> register, and that there is a
special syntax to access that register. To exit from the SMC handler, we push
the desired exception state (SVC mode with IRQ and FIQ disabled) on the stack
together with the return address, and then exit with <code>rfefd sp</code>.</p>
<h3 id="installing-the-smc-handler">Installing the SMC handler</h3>
<p>Before we can call <code>smc</code>, we should create the exception table. If the SMC is
the only exception we care about, a minimal table might look as follows:</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="na">.align</span><span class="w"> </span><span class="mi">5</span>
<span class="nl">sm_vect_table:</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Reset</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Undefined instruction</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="no">sm_smc_entry</span><span class="w"> </span><span class="c1">// Secure monitor call</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Prefetch abort</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Data abort</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Reserved</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// IRQ</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// FIQ</span>
</pre></div>
</code></pre>
<p>Then, sometime before calling <code>smc</code>, install it in the <code>MVBAR</code> register as
follows:</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="nf">ldr</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="err">=</span><span class="no">sm_vect_table</span>
<span class="nf">mcr</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c12</span><span class="p">,</span><span class="w"> </span><span class="no">c0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// MVBAR</span>
</pre></div>
</code></pre>
<h3 id="unsecuring-the-system">Unsecuring the system</h3>
<p>The system and peripherals must be set up with access allowed from the
non-secure world before we flip the <code>NS</code> bit, otherwise the system will just
freeze. Here’s a list of things that must be unsecured before the flip:</p>
<ul>
<li>DDR unsecured via the TZC-400 firewall</li>
<li>GIC distributor and CPU interface</li>
<li>ETZPC = Embedded TrustZone Protection Controller</li>
<li>Clock and reset control (RCC)</li>
<li>Pin controller / all GPIO banks</li>
</ul>
<p>In the following sections, we will examine these one by one, showing how to
unsecure then and how to verify they have been unsecured.</p>
<h3 id="unsecure-ddr-with-tzc-400">Unsecure DDR with TZC-400</h3>
<p>Let’s configure the TZC to allow DDR <code>Region0</code> R/W non-secure access for all
IDs. While we can use the TZC to partition the RAM into several regions, we will
use <code>Region0</code> only which is always enabled. (The region implicitly covers the
entire address space.)</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">TZC</span><span class="o">-&gt;</span><span class="n">GATE_KEEPER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">REG_ID_ACCESSO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">REG_ATTRIBUTESO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xC0000001</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">GATE_KEEPER</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>First, the “gate keeper” is disabled so that we can modify the configuration.
Then, we set the access bits to all ones, so that that each NSAID gets both
write and read permission. Next, we set the attributes so that secure global
write and read are enabled, and the filter is enabled for the region. Finally,
we “close” the gate keeper so that the configuration is active.</p>
<p>To verify that the configuration worked, we print out all the fields from the
TZC struct defined in the CMSIS Device Peripheral Access Layer Header File
(<code>stm32mp135fxx_ca7.h</code>):</p>
<pre><code>[TZC dump] begin
  BUILD_CONFIG     = 0x00001F08
  ACTION           = 0x00000000
  GATE_KEEPER      = 0x00010001
  SPECULATION_CTRL = 0x00000000
  REG_BASE_LOWO    = 0x00000000
  REG_BASE_HIGHO   = 0x00000000
  REG_TOP_LOWO     = 0xFFFFFFFF
  REG_TOP_HIGHO    = 0x00000000
  REG_ATTRIBUTESO  = 0xC0000001
  REG_ID_ACCESSO   = 0xFFFFFFFF
[TZC dump] end
</code></pre>
<p>Of course, we will not be able to verify that the configuration actually works
till we unsecure everything else on the list. Then, we will switch the CPU to
nonsecure world and verify that read and write from DDR succeeds.</p>
<h3 id="gic-distributor">GIC distributor</h3>
<p>The Generic Interrupt Controller is split into two parts: the Distributor (GICD)
takes care of the global IRQ configuration, while the CPU interface (GICC) does
the per-CPU IRQ delivery. In TrustZone, there are two interrupt groups:</p>
<ul>
<li>Group 0 corresponds to the Secure world</li>
<li>Group 1 corresponds to the Non-Secure world</li>
</ul>
<p>Now we go step by step, enabling non-secure access to/from interrupts. First we
configure the interrupts themselves as non-secure:</p>
<p>Allow both Group 0 and 1 interrupts to be forwarded from the GICD to the CPU
interfaces. The GICD control register (<code>GICD_CTLR</code>) is included in the CMSIS
file <code>core_ca.h</code> in the <code>GICDistributor_Type</code> struct:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">CTLR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x03U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Just before switching to non-secure world, we will disable all interrupts, mark
them as non-pending, and move to Group 1 (non-secure):</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">num_reg</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">ICENABLER</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">ICPENDR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">IGROUPR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h3 id="gic-cpu-interface">GIC CPU interface</h3>
<p>In the CPU interface control register, enable Group 1 signaling:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICInterface</span><span class="o">-&gt;</span><span class="n">CTLR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x03U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Priority masking: allow all priority levels to pass through:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICInterface</span><span class="o">-&gt;</span><span class="n">PMR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFFU</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Now we can dump all the GICC registers after handoff:</p>
<pre><code><div class="codehilite"><pre><span></span>[GICC dump] begin
  CTLR    = 0x00000003
  PMR     = 0x000000F8
  BPR     = 0x00000002
  IAR     = 0x000003FF
  EOIR    = 0x00000000
  RPR     = 0x000000FF
  HPPIR   = 0x000003FF
  ABPR    = 0x00000003
  AIAR    = 0x000003FF
  AEOIR   = 0x00000000
  AHPPIR  = 0x000003FF
  STATUSR = 0x00000000
  APR[0]   = 0x00000000
  APR[1]   = 0x00000000
  APR[2]   = 0x00000000
  APR[3]   = 0x00000000
  NSAPR[0] = 0x00000000
  NSAPR[1] = 0x00000000
  NSAPR[2] = 0x00000000
  NSAPR[3] = 0x00000000
  IIDR    = 0x0102143B
  DIR     = 0x00000000
[GICC dump] end
</pre></div>
</code></pre>
<p>This means:</p>
<ul>
<li><code>CTLR</code> enables Group 0 and 1 interrupts</li>
<li><code>PMR</code> sets <code>PRIORITY[4:0] = 0b11111</code>, which allows all non-secure interrupts
to be signaled</li>
<li><code>BPR</code> controls how the 8-bit interrupt priority field is split into a group
priority field</li>
<li><code>IAR</code> shows <code>CPUID = 0</code>, and <code>INTERRUPT_ID</code> = 1023, which indicates a
“Spurious interrupt ID” (no pending interrupt at the CPU interface)</li>
<li><code>EOIR</code>: <code>CPUID = 0</code>, end-of-interrupt ID = 0, i.e. no interrupt being
completed</li>
<li><code>RPR</code>: <code>PRIORITY[4:0] = 0b11111</code>, current running priority on the CPU
interface indicates no active interrupt</li>
</ul>
<h3 id="etzpc--enhanced-trustzone-protection-controller">ETZPC = Enhanced TrustZone Protection Controller</h3>
<p>Now we open access to all peripherals protected by ETZPC. Luckily the ST HAL
includes a function to open the entire ETZPC to non-secure access:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">__HAL_RCC_ETZPC_CLK_ENABLE</span><span class="p">();</span>

<span class="c1">// unsecure SYSRAM</span>
<span class="n">LL_ETZPC_SetSecureSysRamSize</span><span class="p">(</span><span class="n">ETZPC</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// unsecure peripherals</span>
<span class="n">LL_ETZPC_Set_All_PeriphProtection</span><span class="p">(</span><span class="n">ETZPC</span><span class="p">,</span>
<span class="w">     </span><span class="n">LL_ETZPC_PERIPH_PROTECTION_READ_WRITE_NONSECURE</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Let’s print out the ETZPC registers after running this:</p>
<pre><code><div class="codehilite"><pre><span></span>[ETZPC dump] begin
  TZMA0_SIZE       = 0x8000000D
  TZMA1_SIZE       = 0x00000000
  DECPROT0         = 0xFFFFFFFF
  DECPROT1         = 0xFFFFFFFF
  DECPROT2         = 0xFFFFFFFF
  DECPROT3         = 0xFFFFFFFF
  DECPROT4         = 0x00000000
  DECPROT5         = 0x00000000
  DECPROT_LOCK0    = 0x00000000
  DECPROT_LOCK1    = 0x00000000
  DECPROT_LOCK2    = 0x00000000
  HWCFGR           = 0x00004002
  IP_VER           = 0x00000020
  ID               = 0x00100061
  SID              = 0xA3C5DD01
[ETZPC dump] end
</pre></div>
</code></pre>
<p>This means that SYSRAM and ETZPC are fully non-secure.</p>
<h3 id="clock-and-reset-control-rcc">Clock and reset control (RCC)</h3>
<p>Through the RCC secure configuration register (<code>RCC_SECCFGR</code>), we may configure
various clocks to be either secure or non-secure. Easy enough to unsecure:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">RCC</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
</pre></div>
</code></pre>
<h3 id="pin-controller--all-gpio-banks">Pin controller / all GPIO banks</h3>
<p>Likewise, after enabling the GPIOs, we need to allow non-secure access to them:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOB</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOC</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOD</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOE</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOF</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOH</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
</pre></div>
</code></pre>
<h3 id="state-of-the-boot-process-so-far">State of the boot process so far</h3>
<p>With the steps above done, a program will run in the non-secure world (<code>NS=1</code>).
However, most of the diagnostics to get there will probe secure-only registers,
such as those used by the TZC, which will result in an immediate undefined
instruction or similar abort.</p>
<p>In other words, in non-secure world, you are limited to non-secure things!</p>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page3.html">← Older articles</a></div>
        <div><a class="newer" href="index.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
