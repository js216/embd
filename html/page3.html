<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="linux-bringup-on-custom-stm32mp135-board">Linux Bring-Up on a Custom STM32MP135 Board</a></h2>
<div class="article-meta">Published 22 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/vt.jpg"/></p>
<p><em>This is Part 6 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>This is a record of steps I took to successfully get Linux past the early boot
stage on my custom board using the STM32MP135 SoC. (Schematics, PCB design
files, and code available in this
<a href="https://github.com/js216/stm32mp135_test_board">repository</a>.) The write-up is
in approximate chronological order, written as I go through the debugging steps.</p>
<h3 id="blink">Blink</h3>
<p>I had previously put together a simple bare-metal
<a href="https://github.com/js216/mp135_boot/tree/main/blink_noide">program</a> that runs
on the STM32MP135 evaluation board and just blinks the LED. To work on the
custom board, I needed only to remove anything to do with the STPMIC1 and LSE
clock (the low-speed external 32.768 kHz clock), since I did not place these
parts on my board. The <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/blink">resulting
code</a>
is pretty simple modulo complexity inherited from the ST drivers.</p>
<p>To download the code, I talked directly to the ROM bootloader on the SoC. See
<a href="boot-stm32mp135-over-uart-with-python">this article</a> for details.</p>
<h3 id="ddr">DDR</h3>
<p>Again, I had previously put together a <a href="https://github.com/js216/mp135_boot/tree/main/ddr_test">simple
program</a> to test the DDR
on the evaluation board. It fills the memory entirely with pseudorandom bits
(PRBS-31), and then reads it out, checking that the data matches.</p>
<p>For the custom board, the program had to be modified similarly as with blink
(remove STPMIC1, LSE clock) and then it ran. <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/ddr_test">(Click for
code.)</a></p>
<p>There was an issue: all data read back was wrong and subtly corrupted. I double
checked the wiring, DDR parameter configuration (I use the same DDR as the eval
board, so what could it be!?), the code—only to realize the board was not
getting enough current on the 1.35V power supply. With more power, everything
<em>just worked</em>!</p>
<h3 id="jtag">JTAG</h3>
<p>For JTAG loading it appears to be essential to select “Development boot” (also
called “Engineering boot”) by selecting the boot pins in the <code>100</code> setting. The
datasheet says this mode is used “Used to get debug access without boot from
flash memory”.</p>
<p>There is also a footnote that says that the core is “in infinite loop toggling
PA13”, but I did not observe the toggling in the “dev boot” mode, even though it
is of course present (but not documented) in the normal UART boot mode (pins =
<code>000</code>).</p>
<p><img alt="" src="../images/jtag.jpg"/></p>
<p>Unfortunately I covered the J-Link connector with solder mask. After trying to
carefully scratch it off using a sewing needle, the connection appears to be
intermittent. Sometimes J-Link was able to download the DDR test program to the
SYSRAM, but most of the time it couldn’t. Probably it would work just fine if it
wasn’t for the soldermask covering. I wish I had just used a normal pin-header
connector rather than the J-Link needle adapter. So, I’ll have to use UART boot
mode for now, and hope that I can get the (much faster) USB mode to work.</p>
<h3 id="sd">SD</h3>
<p><em>Note: read the full SD card story
<a href="https://embd.cc/sdcard-on-bare-metal-stm32mp135">here</a>.</em></p>
<p>On the STM32MP135 evaluation board, an SDMMC example reliably reads a program
from an SD card into DDR and executes it, but porting the same code to a custom
board exposed a failure during SD initialization. Although command-level
communication succeeded—CMD0, CMD8, CMD55, and ACMD41 all completed normally and
the card identified as SDHC—the sequence consistently failed later in
<code>SD_SendSDStatus</code> with <code>SDMMC_FLAG_DTIMEOUT</code>. Hardware checks showed that SD
card power, SDMMC I/O domain voltages, and signal levels all matched the
evaluation board, with clean 3.3 V logic and a low clock rate of about 1.56 MHz.
The decisive difference turned out to be signal pull-ups: the evaluation board
routes SD signals through an ESD device with built-in pull-ups, whereas the
custom board did not. Enabling internal pull-ups on the SD data lines eliminated
the data timeout and allowed SD reads to proceed, confirming that missing
pull-ups were responsible for the initialization failure.</p>
<p>However, once SD transfers succeeded, the data read from the card appeared
corrupted in DDR: roughly every other byte was intermittently wrong, always off
by exactly two, independent of bus width, clock edge, power supply, or signal
integrity. The critical observation was that data read into a static buffer in
SYSRAM was always correct, while corruption appeared only after copying that
data into DDR using byte-wise writes such as memcpy. When DDR was written using
explicit, 32-bit aligned word accesses, the corruption disappeared entirely.
Ensuring that all DDR writes are word-sized and properly aligned provided a full
workaround for the issue and restored correct, reproducible SD card operation on
the Rev A custom board. (The issue is likely due to a mask/strobe swap in the
DDR wiring; see
<a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">this</a> for
details.)</p>
<h3 id="usb">USB</h3>
<p><em>Note: read the full USB story
<a href="https://embd.cc/usb-bringup-on-custom-stm32mp135-board">here</a>.</em></p>
<p>Getting USB working on a custom STM32MP135 board involved a few key hardware and
software steps. First, I enabled the USBHS power switch by adding a
current-limit resistor so the PHY would receive power. On the board, I removed
the permanent 1.5 kΩ pullup on the D+ line to allow proper High-Speed
enumeration. I also ensured JTAG worked reliably by booting in engineering debug
mode and verifying the vector table took interrupts in ARM mode.</p>
<p>On the software side, I disabled VBUS sensing in the HAL PCD initialization to
match the externally powered board, configured the Rx/Tx FIFOs, and made sure
all required USB interrupts were correctly handled. For the USB Device stack, I
added the necessary callbacks in <code>usbd_conf.c</code> and applied volatile casts to
ensure 32-bit accesses to SYSRAM were aligned, avoiding Data Aborts.</p>
<p>Finally, I verified proper memory alignment for DDR writes to ensure file
transfers worked without byte shuffling, and confirmed enumeration and data
transfers at High-Speed using a good USB cable and port. After these steps, the
board enumerated correctly as an MSC device, and read/write operations
functioned reliably.</p>
<h3 id="switch-to-non-secure-world">Switch to Non-Secure World</h3>
<p><em>Note: read the full TrustZone story
<a href="https://embd.cc/unsecuring-stm32mp135-trustzone">here</a>.</em></p>
<p>The STM32MP135 integrates the Arm TrustZone extension which partitions the
system into two isolated security domains, the secure and non-secure worlds,
depending on the state of the <code>NS</code> bit in the <code>SCR</code> register. Before the bit is
flipped, we need to unsecure many parts of the SoC (DDR, DMA masters, etc).</p>
<h3 id="debug-linux-early-boot">Debug Linux early boot</h3>
<p>Since Linux is just another program, why not try and run it, now that we have
disabled most secure-world hindrances? One thing to keep in mind is to respect
the link address:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>readelf<span class="w"> </span>-h<span class="w"> </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>Entry
<span class="w">  </span>Entry<span class="w"> </span>point<span class="w"> </span>address:<span class="w">               </span>0xc0008000
</pre></div>
</code></pre>
<p>Let’s copy the binary instructions from the ELF file into something we can load
into memory:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>arm-none-eabi-objcopy<span class="w"> </span>-O<span class="w"> </span>binary<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/build/linux-custom/vmlinux<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>output/images/vmlinux.bin
</pre></div>
</code></pre>
<p>Now we place the binary file in the same SD card image as the bootloader:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span>build/vmlinux.bin

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
</pre></div>
</code></pre>
<p>Load the ~40,000 blocks from logical block address (LBA) 324 into DDR to
location <code>0xC0008000</code>, and jump to it. If we follow along with the debug probe,
we see that the kernel begins executing in <code>arch/arm/kernel/head.S</code> and gets
stuck when it realizes that we did not pass it the correct boot parameters.</p>
<h3 id="provide-a-device-tree-blob">Provide a Device Tree Blob</h3>
<p>Let’s start with the default DTB and decompile it into the DTS:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="o">[</span>buildroot<span class="o">]</span>&gt;<span class="w"> </span>dtc<span class="w"> </span>-I<span class="w"> </span>dtb<span class="w"> </span>-O<span class="w"> </span>dts<span class="w"> </span>-@<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>output/build/linux-custom/arch/arm/boot/dts/stm32mp135f-dk.dtb<span class="w"> </span>&gt;<span class="w"> </span><span class="se">\</span>
<span class="w">   </span>~/temp/build/min.dts
</pre></div>
</code></pre>
<p>Now remove as much of the unnecessary peripherals from the device tree and
compile back into a DTB:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>dtc<span class="w"> </span>-I<span class="w"> </span>dts<span class="w"> </span>-O<span class="w"> </span>dtb<span class="w"> </span>min.dts<span class="w"> </span>&gt;<span class="w"> </span>min.dtb
</pre></div>
</code></pre>
<p>Next, we need to include this DTB in the SD card image:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>python3<span class="w"> </span>scripts/sdimage.py<span class="w"> </span>build/sdcard.img<span class="w"> </span>build/main.stm32<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>build/vmlinux.bin<span class="w"> </span>build/min.dtb

File<span class="w">                      </span>LBA<span class="w">      </span>Size<span class="w">       </span>Blocks
-------------------------------------------------------
main.stm32<span class="w">                </span><span class="m">128</span><span class="w">      </span><span class="m">100352</span><span class="w">     </span><span class="m">197</span>
vmlinux.bin<span class="w">               </span><span class="m">324</span><span class="w">      </span><span class="m">19111936</span><span class="w">   </span><span class="m">37329</span>
min.dtb<span class="w">                   </span><span class="m">37652</span><span class="w">    </span><span class="m">53248</span><span class="w">      </span><span class="m">105</span>
</pre></div>
</code></pre>
<p>Write the new image to the SD card, and boot the bootloader, and copy the kernel
and the DTB to DDR:</p>
<pre><code><div class="codehilite"><pre><span></span>&gt; l 40000 324 0xc0008000
Copying 40000 blocks from LBA 324 to DDR addr 0xC0008000 ...
&gt; l 105 37652 0xc2008000
Copying 105 blocks from LBA 37652 to DDR addr 0xC2008000 ...
&gt; p 256 0xc2008000
0x00000000 : d0 0d fe ed  00 00 ce 12  00 00 00 38  00 00 bc c4  ...........8....
0x00000010 : 00 00 00 28  00 00 00 11  00 00 00 10  00 00 00 00  ...(............
0x00000020 : 00 00 11 4e  00 00 bc 8c  00 00 00 00  00 00 00 00  ...N............
0x00000030 : 00 00 00 00  00 00 00 00  00 00 00 01  00 00 00 00  ................
0x00000040 : 00 00 00 03  00 00 00 04  00 00 00 00  00 00 00 01  ................
0x00000050 : 00 00 00 03  00 00 00 04  00 00 00 0f  00 00 00 01  ................
0x00000060 : 00 00 00 03  00 00 00 32  00 00 00 1b  53 54 4d 69  .......2....STMi
0x00000070 : 63 72 6f 65  6c 65 63 74  72 6f 6e 69  63 73 20 53  croelectronics S
</pre></div>
</code></pre>
<p>We can match the print against the DTB hexdump to verify that it’s been written
correctly (note the “d00dfeed” at the start of the DTB). Then issue the <code>j</code> or
<code>jump</code> instruction, and follow along with the debugger:</p>
<pre><code><div class="codehilite"><pre><span></span>gdb)
69         push  {r4} // CPSR after return
(gdb) del
(gdb) si
sm_smc_entry () at src/handoff.S:70
70         push  {r3} // PC after return
(gdb)
sm_smc_entry () at src/handoff.S:71
71         rfefd sp
(gdb)
0xc0008000 in ?? ()
(gdb) file build/vmlinux
Reading symbols from build/vmlinux...
(gdb) si
__hyp_stub_install () at arch/arm/kernel/hyp-stub.S:73
73      arch/arm/kernel/hyp-stub.S: No such file or directory.
(gdb) directory build/linux-custom
Source directories searched: build/linux-custom;$cdir;$cwd
(gdb) si
0xc01149a4      73              store_primary_cpu_mode  r4, r5
</pre></div>
</code></pre>
<p>Above we see the last three instructions from the bootloader, and then we need
to switch GDB to the Linux kernel executable, and provide it the source code
directory. Then, we see one of the first instructions from the kernel being
executed, on line 73 of <code>hyp-stub.S</code>.</p>
<p>Step instruction (<code>si</code>) a couple times until we reach the branch to
<code>__vet_atags</code>. That routine is responsible to determine the validity of the <code>r2</code>
pointer that the bootloader is supposed to point to where we copied the DTB in
the memory. Let’s see what happens:</p>
<pre><code><div class="codehilite"><pre><span></span>__vet_atags () at arch/arm/kernel/head-common.S:44
44              tst     r2, #0x3                        @ aligned?
45              bne     1f
47              ldr     r5, [r2, #0]
49              ldr     r6, =OF_DT_MAGIC                @ is it a DTB?
50              cmp     r5, r6
51              beq     2f
61      2:      ret     lr                              @ atag/dtb pointer is ok
</pre></div>
</code></pre>
<p>Evidently the DTB pointer is good! Now we return back to the startup code and
proceed with enabling MMU, clearing memory, etc. I got tired of single-stepping
through <code>memset</code> and hit continue, and was amazed to find the following on the
serial monitor:</p>
<pre><code><div class="codehilite"><pre><span></span>[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.1.28 (jk@SRS1720) (arm-buildroot-linux-uclibcgnueabihf-gcc.br_real (Buildroot 2024.11-202-g3645e3b781-dirty) 13.3.0, GNU ld (GNU Binutils) 2.42) #1 SMP PREEMPT Thu Dec 18 17:02:40 PST 2025
[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d
[    0.000000] CPU: div instructions available: patching division code
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
[    0.000000] OF: fdt: Machine model: STMicroelectronics STM32MP135F-DK Discovery Board
[    0.000000] Memory policy: Data cache writealloc
[    0.000000] cma: Reserved 64 MiB at 0xdc000000
[    0.000000] Zone ranges:
[    0.000000]   Normal   [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000]   HighMem  empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x00000000c0000000-0x00000000dfffffff]
[    0.000000] Initmem setup node 0 [mem 0x00000000c0000000-0x00000000dfffffff]
</pre></div>
</code></pre>
<p>In other words: <em>IT WORKS!!!</em></p>
<h3 id="discussion">Discussion</h3>
<p>There’s an important step that had to take place before the “blink” example
could run on the custom board: <em>let go of the sheer excitement</em>. Having worked
on or with some kind of a Linux system for perhaps two decades, it was an almost
surreal, mystical feeling to hold in my hands a board that I designed myself
that is supposed to run the operating system. It’s what makes engineering a
rewarding experience, but the mental jitter of it can also interfere with
getting things done. After all, this is just routine work!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><em>6. This article</em></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="unsecuring-stm32mp135-trustzone">Unsecuring STM32MP135 TrustZone</a></h2>
<div class="article-meta">Published 21 Dec 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/mia.jpg"/></p>
<p>The STM32MP135 integrates the Arm TrustZone extension which partitions the
system into two isolated security domains, the secure and non-secure worlds,
depending on the state of the <code>NS</code> bit. On reset, it executes in the secure
world (<code>NS=0</code>), but in normal operation, we want <code>NS=1</code>.</p>
<p>In this article, we explain how to execute the world transitions in a bare-metal
environment. See <a href="https://embd.cc/stm32mp135-without-optee">this article</a> to
learn how to do it in the context of Arm Trusted Firmware (TF-A) and Linux.</p>
<h3 id="change-worlds-with-smc-handler">Change worlds with SMC handler</h3>
<p>The <code>NS</code> bit is only supposed to be flipped in the Secure Monitor handler,
invoked with the <code>smc</code> instruction. Thus a minimum handler might look as follows
(assumes the return address is passed in via <code>r3</code>):</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="na">.align</span><span class="w"> </span><span class="mi">2</span>
<span class="nl">sm_smc_entry:</span>
<span class="w">   </span><span class="nf">mrc</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// read SCR</span>
<span class="w">   </span><span class="nf">orr</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="c1">#SCR_NS</span>
<span class="w">   </span><span class="nf">mcr</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="no">c1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">// write SCR</span>
<span class="w">   </span><span class="nf">mov</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="mi">#0</span>

<span class="w">   </span><span class="nf">mov</span><span class="w"> </span><span class="no">r4</span><span class="p">,</span><span class="w"> </span><span class="c1">#(CPSR_MODE_SVC | CPSR_I | CPSR_F)</span>
<span class="w">   </span><span class="nf">push</span><span class="w">  </span><span class="p">{</span><span class="no">r4</span><span class="p">}</span><span class="w"> </span><span class="c1">// CPSR after return</span>
<span class="w">   </span><span class="nf">push</span><span class="w">  </span><span class="p">{</span><span class="no">r3</span><span class="p">}</span><span class="w"> </span><span class="c1">// PC after return</span>
<span class="w">   </span><span class="nf">rfefd</span><span class="w"> </span><span class="no">sp</span>
</pre></div>
</code></pre>
<p>We see that the <code>NS</code> bit lives in the <code>SCR</code> register, and that there is a
special syntax to access that register. To exit from the SMC handler, we push
the desired exception state (SVC mode with IRQ and FIQ disabled) on the stack
together with the return address, and then exit with <code>rfefd sp</code>.</p>
<h3 id="installing-the-smc-handler">Installing the SMC handler</h3>
<p>Before we can call <code>smc</code>, we should create the exception table. If the SMC is
the only exception we care about, a minimal table might look as follows:</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="na">.align</span><span class="w"> </span><span class="mi">5</span>
<span class="nl">sm_vect_table:</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Reset</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Undefined instruction</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="no">sm_smc_entry</span><span class="w"> </span><span class="c1">// Secure monitor call</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Prefetch abort</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Data abort</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// Reserved</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// IRQ</span>
<span class="w">   </span><span class="nf">b</span><span class="w"> </span><span class="p">.</span><span class="w">            </span><span class="c1">// FIQ</span>
</pre></div>
</code></pre>
<p>Then, sometime before calling <code>smc</code>, install it in the <code>MVBAR</code> register as
follows:</p>
<pre><code class="language-asm"><div class="codehilite"><pre><span></span><span class="nf">ldr</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="err">=</span><span class="no">sm_vect_table</span>
<span class="nf">mcr</span><span class="w"> </span><span class="no">p15</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">r0</span><span class="p">,</span><span class="w"> </span><span class="no">c12</span><span class="p">,</span><span class="w"> </span><span class="no">c0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">// MVBAR</span>
</pre></div>
</code></pre>
<h3 id="unsecuring-the-system">Unsecuring the system</h3>
<p>The system and peripherals must be set up with access allowed from the
non-secure world before we flip the <code>NS</code> bit, otherwise the system will just
freeze. Here’s a list of things that must be unsecured before the flip:</p>
<ul>
<li>DDR unsecured via the TZC-400 firewall</li>
<li>GIC distributor and CPU interface</li>
<li>ETZPC = Embedded TrustZone Protection Controller</li>
<li>Clock and reset control (RCC)</li>
<li>Pin controller / all GPIO banks</li>
</ul>
<p>In the following sections, we will examine these one by one, showing how to
unsecure then and how to verify they have been unsecured.</p>
<h3 id="unsecure-ddr-with-tzc-400">Unsecure DDR with TZC-400</h3>
<p>Let’s configure the TZC to allow DDR <code>Region0</code> R/W non-secure access for all
IDs. While we can use the TZC to partition the RAM into several regions, we will
use <code>Region0</code> only which is always enabled. (The region implicitly covers the
entire address space.)</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">TZC</span><span class="o">-&gt;</span><span class="n">GATE_KEEPER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">REG_ID_ACCESSO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">REG_ATTRIBUTESO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xC0000001</span><span class="p">;</span>
<span class="n">TZC</span><span class="o">-&gt;</span><span class="n">GATE_KEEPER</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>First, the “gate keeper” is disabled so that we can modify the configuration.
Then, we set the access bits to all ones, so that that each NSAID gets both
write and read permission. Next, we set the attributes so that secure global
write and read are enabled, and the filter is enabled for the region. Finally,
we “close” the gate keeper so that the configuration is active.</p>
<p>To verify that the configuration worked, we print out all the fields from the
TZC struct defined in the CMSIS Device Peripheral Access Layer Header File
(<code>stm32mp135fxx_ca7.h</code>):</p>
<pre><code>[TZC dump] begin
  BUILD_CONFIG     = 0x00001F08
  ACTION           = 0x00000000
  GATE_KEEPER      = 0x00010001
  SPECULATION_CTRL = 0x00000000
  REG_BASE_LOWO    = 0x00000000
  REG_BASE_HIGHO   = 0x00000000
  REG_TOP_LOWO     = 0xFFFFFFFF
  REG_TOP_HIGHO    = 0x00000000
  REG_ATTRIBUTESO  = 0xC0000001
  REG_ID_ACCESSO   = 0xFFFFFFFF
[TZC dump] end
</code></pre>
<p>Of course, we will not be able to verify that the configuration actually works
till we unsecure everything else on the list. Then, we will switch the CPU to
nonsecure world and verify that read and write from DDR succeeds.</p>
<h3 id="gic-distributor">GIC distributor</h3>
<p>The Generic Interrupt Controller is split into two parts: the Distributor (GICD)
takes care of the global IRQ configuration, while the CPU interface (GICC) does
the per-CPU IRQ delivery. In TrustZone, there are two interrupt groups:</p>
<ul>
<li>Group 0 corresponds to the Secure world</li>
<li>Group 1 corresponds to the Non-Secure world</li>
</ul>
<p>Now we go step by step, enabling non-secure access to/from interrupts. First we
configure the interrupts themselves as non-secure:</p>
<p>Allow both Group 0 and 1 interrupts to be forwarded from the GICD to the CPU
interfaces. The GICD control register (<code>GICD_CTLR</code>) is included in the CMSIS
file <code>core_ca.h</code> in the <code>GICDistributor_Type</code> struct:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">CTLR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x03U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Just before switching to non-secure world, we will disable all interrupts, mark
them as non-pending, and move to Group 1 (non-secure):</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">num_reg</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">ICENABLER</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">ICPENDR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">  </span><span class="n">GICDistributor</span><span class="o">-&gt;</span><span class="n">IGROUPR</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h3 id="gic-cpu-interface">GIC CPU interface</h3>
<p>In the CPU interface control register, enable Group 1 signaling:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICInterface</span><span class="o">-&gt;</span><span class="n">CTLR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mh">0x03U</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Priority masking: allow all priority levels to pass through:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GICInterface</span><span class="o">-&gt;</span><span class="n">PMR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xFFU</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Now we can dump all the GICC registers after handoff:</p>
<pre><code><div class="codehilite"><pre><span></span>[GICC dump] begin
  CTLR    = 0x00000003
  PMR     = 0x000000F8
  BPR     = 0x00000002
  IAR     = 0x000003FF
  EOIR    = 0x00000000
  RPR     = 0x000000FF
  HPPIR   = 0x000003FF
  ABPR    = 0x00000003
  AIAR    = 0x000003FF
  AEOIR   = 0x00000000
  AHPPIR  = 0x000003FF
  STATUSR = 0x00000000
  APR[0]   = 0x00000000
  APR[1]   = 0x00000000
  APR[2]   = 0x00000000
  APR[3]   = 0x00000000
  NSAPR[0] = 0x00000000
  NSAPR[1] = 0x00000000
  NSAPR[2] = 0x00000000
  NSAPR[3] = 0x00000000
  IIDR    = 0x0102143B
  DIR     = 0x00000000
[GICC dump] end
</pre></div>
</code></pre>
<p>This means:</p>
<ul>
<li><code>CTLR</code> enables Group 0 and 1 interrupts</li>
<li><code>PMR</code> sets <code>PRIORITY[4:0] = 0b11111</code>, which allows all non-secure interrupts
to be signaled</li>
<li><code>BPR</code> controls how the 8-bit interrupt priority field is split into a group
priority field</li>
<li><code>IAR</code> shows <code>CPUID = 0</code>, and <code>INTERRUPT_ID</code> = 1023, which indicates a
“Spurious interrupt ID” (no pending interrupt at the CPU interface)</li>
<li><code>EOIR</code>: <code>CPUID = 0</code>, end-of-interrupt ID = 0, i.e. no interrupt being
completed</li>
<li><code>RPR</code>: <code>PRIORITY[4:0] = 0b11111</code>, current running priority on the CPU
interface indicates no active interrupt</li>
</ul>
<h3 id="etzpc--enhanced-trustzone-protection-controller">ETZPC = Enhanced TrustZone Protection Controller</h3>
<p>Now we open access to all peripherals protected by ETZPC. Luckily the ST HAL
includes a function to open the entire ETZPC to non-secure access:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">__HAL_RCC_ETZPC_CLK_ENABLE</span><span class="p">();</span>

<span class="c1">// unsecure SYSRAM</span>
<span class="n">LL_ETZPC_SetSecureSysRamSize</span><span class="p">(</span><span class="n">ETZPC</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// unsecure peripherals</span>
<span class="n">LL_ETZPC_Set_All_PeriphProtection</span><span class="p">(</span><span class="n">ETZPC</span><span class="p">,</span>
<span class="w">     </span><span class="n">LL_ETZPC_PERIPH_PROTECTION_READ_WRITE_NONSECURE</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Let’s print out the ETZPC registers after running this:</p>
<pre><code><div class="codehilite"><pre><span></span>[ETZPC dump] begin
  TZMA0_SIZE       = 0x8000000D
  TZMA1_SIZE       = 0x00000000
  DECPROT0         = 0xFFFFFFFF
  DECPROT1         = 0xFFFFFFFF
  DECPROT2         = 0xFFFFFFFF
  DECPROT3         = 0xFFFFFFFF
  DECPROT4         = 0x00000000
  DECPROT5         = 0x00000000
  DECPROT_LOCK0    = 0x00000000
  DECPROT_LOCK1    = 0x00000000
  DECPROT_LOCK2    = 0x00000000
  HWCFGR           = 0x00004002
  IP_VER           = 0x00000020
  ID               = 0x00100061
  SID              = 0xA3C5DD01
[ETZPC dump] end
</pre></div>
</code></pre>
<p>This means that SYSRAM and ETZPC are fully non-secure.</p>
<h3 id="clock-and-reset-control-rcc">Clock and reset control (RCC)</h3>
<p>Through the RCC secure configuration register (<code>RCC_SECCFGR</code>), we may configure
various clocks to be either secure or non-secure. Easy enough to unsecure:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">RCC</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
</pre></div>
</code></pre>
<h3 id="pin-controller--all-gpio-banks">Pin controller / all GPIO banks</h3>
<p>Likewise, after enabling the GPIOs, we need to allow non-secure access to them:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">GPIOA</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOB</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOC</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOD</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOE</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOF</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOG</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
<span class="n">GPIOH</span><span class="o">-&gt;</span><span class="n">SECCFGR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000000</span><span class="p">;</span>
</pre></div>
</code></pre>
<h3 id="state-of-the-boot-process-so-far">State of the boot process so far</h3>
<p>With the steps above done, a program will run in the non-secure world (<code>NS=1</code>).
However, most of the diagnostics to get there will probe secure-only registers,
such as those used by the TZC, which will result in an immediate undefined
instruction or similar abort.</p>
<p>In other words, in non-secure world, you are limited to non-secure things!</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="sdcard-on-bare-metal-stm32mp135">SD card on bare-metal STM32MP135</a></h2>
<div class="article-meta">Published 20 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/deco.jpg"/></p>
<p>This article presents my step-by-step debug process for getting the SD card to
work reliably on my <a href="https://github.com/js216/stm32mp135_test_board">custom
board</a> integrating the
STM32MP135.</p>
<h3 id="test-program">Test program</h3>
<p>For the evaluation board, I prepared a <a href="https://github.com/js216/mp135_boot/tree/main/sd_to_ddr">simple
example</a> that reads a
program (blink) from SD card to DDR, and passes control to the program. The LED
blinks, everything is fine.</p>
<p>On the custom board, I simplified the example so it just tests that DDR and SD
card can be written to and read from. The SD initialization fails as follows.
In file <code>stm32mp13xx_hal_sd.c</code>, the function <code>HAL_SD_Init</code> calls
<code>HAL_SD_GetCardStatus</code> which calls <code>SD_SendSDStatus</code>. There, the error flag
<code>SDMMC_FLAG_DTIMEOUT</code> is detected, i.e. timeout when trying to get data.</p>
<h3 id="wiring">Wiring</h3>
<p>The custom board connections from MCU to SD card pins are as follows:</p>
<pre><code>PC10/SDMMC1_D2 (B13) → 1 DAT2
PC11/SDMMC1_D3 (C14) → 2 DAT3/CD
PD2/SDMMC1_CMD (A15) → 3 CMD with 10k pullup to +3.3V
+3.3V → 4 VDD
PC12/SDMMC1_CK (B15) → 5 CLK
GND → 6 VSS
PC8/SDMMC_D0 (D14) → 7 DAT0
PC9/SDMMC_D1 (A16) → 8 DAT1
PI7 (U16) uSD_DETECT → 9 DET_B with 100K pullup to +3.3V
(nc) → 10 DET_A
</code></pre>
<p>Since the failure happens soon after switching the card into 1.8V mode, I need
to verify the voltages. On the evaluation board, <code>VDD_SD</code> is 3.3V on boot, and
when the SD program is running, it lowers it to 2.9V. I modified the code to
leave it at 3.3V, and it worked also: the code read data from SD card correctly.
On my custom board, <code>VDD_SD</code> is tied to 3.3V directly. (SD cards should accept
abything from 2.7V to 3.6V.) Thus, the SD card voltage should be okay.</p>
<p>The other voltage to check is the one powering the SoC domain for the SDMMC
controller. The eval board shows that both <code>VDDSD1</code> and <code>VDDSD2</code> are tied to
<code>VDD</code>—the same <code>VDD</code> as the rest of the SoC. We can measure that easily via
CN14 pin 13, and it measures 3.3V. On the custom board, these are tied to 3.3V
directly.</p>
<p>On the eval board, I looked at the <code>SDMMC1_CK</code> line (about 1.56 MHz),
<code>SDMMC1_CMD</code>, and the data lines with a scope probe and I saw 3V logic signals,
so it does not seem that 1.8V logic is used.</p>
<h3 id="debug-prints">Debug prints</h3>
<p>Adding lots of print statements to <code>SD_PowerON</code>, we get the following when
running on the custom board:</p>
<pre><code>CMD0: Go Idle State...
CMD0 result = 0x00000000
CMD8: Send Interface Condition...
CMD8 result = 0x00000000
CMD8 OK -&gt; CardVersion = V2.x
CMD55: APP_CMD (arg=0)
CMD55 result = 0x00000000
ACMD41 loop...
Loop 0
  CMD55...
  CMD55 result = 0x00000000
  ACMD41...
  ACMD41 result = 0x00000000
  R3 Response = 0x41FF8000
  ValidVoltage = 0
Loop 1
  CMD55...
  CMD55 result = 0x00000000
  ACMD41...
  ACMD41 result = 0x00000000
  R3 Response = 0xC1FF8000
  ValidVoltage = 1
ACMD41 success: OCR=0xC1FF8000
Card reports High Capacity (SDHC/SDXC)
SD_PowerON: SUCCESS
</code></pre>
<p>Followed by the same <code>HAL_SD_ERROR_DATA_TIMEOUT</code> error from <code>SD_SendSDStatus</code>.
Let’s instrument the latter function with prints also. Here’s what we get:</p>
<pre><code>--- SD_SendSDStatus BEGIN ---
Initial RESP1 = 0x00000900
CMD16: Set Block Length = 64...
CMD16 result = 0x00000000
CMD55: APP_CMD (arg=RCA&lt;&lt;16) = 0xAAAA0000
CMD55 result = 0x00000000
Configuring DPSM: len=64, block=64B
ACMD13: Send SD Status...
ACMD13 result = 0x00000000
Waiting for data...
ERROR: SDMMC_FLAG_DTIMEOUT detected!
</code></pre>
<h4>Pullups?</h4>
<p>The SD card initialization was inherited from the evaluation board, where
all the signals are passed through the <code>EMIF06-MSD02N16</code> ESD protection chip,
which also features built-in pullups.</p>
<p>In <code>HAL_SD_MspInit</code>, we can enable internal pullups on the data lines going to
the SD card. In that case, we get the following printout from the instrumented
version of <code>SD_SendSDStatus</code>:</p>
<pre><code>--- SD_SendSDStatus BEGIN ---
Initial RESP1 = 0x00000900
CMD16: Set Block Length = 64...
CMD16 result = 0x00000000
CMD55: APP_CMD (arg=RCA&lt;&lt;16) = 0xAAAA0000
CMD55 result = 0x00000000
Configuring DPSM: len=64, block=64B
ACMD13: Send SD Status...
ACMD13 result = 0x00000000
Waiting for data...
RXFIFOHF set — reading 8 words...
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000004
  FIFO -&gt; 0x00900004
  FIFO -&gt; 0x001A050F
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000100
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
RXFIFOHF set — reading 8 words...
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
Data-end flag set, reading remaining FIFO...
Clearing static DATA flags
--- SD_SendSDStatus SUCCESS ---
</code></pre>
<p>After that, reading from the SD card was possible—but about half of the bytes
read were slightly corrupted.</p>
<h4>Data corruption</h4>
<p>Suspecting that there is something wrong with the 4-bit data transfers, I
switched to <code>SDMMC_BUS_WIDE_1B</code> and confirmed with a scope probe that there is
no data on DAT1,2,3, only on DAT0. But data corruption is still there. The clock
speed is only about 1.56 MHz, which seems to rule out signal integrity issues.</p>
<p>I tried a different power supply for the 3.3V supply, and still the same issue.
I added 330uF capacitors on all three power rails (1.25V, 1.35V, 3.3V, althought
1.25V and 1.35V are connected together), and still no improvement. (The PCB
already has a 10U capacitor next to the SD card VDD pin.)</p>
<p>Changing the <code>ClockEdge</code> of the <code>SDHandle.Init</code> does not fix it. Nor did setting
<code>PIO_Init_Structure.Speed</code> to <code>GPIO_SPEED_FREQ_VERY_HIGH</code>.</p>
<p>Interestingly the corruption affects only every other byte, and if it is
corrupted, it’s always just off by 2 (i.e., only bit number 1 is affected).</p>
<p>Adding the external 3.3V 10k pullup on DAT0 (when running in <code>SDMMC_BUS_WIDE_1B</code>
mode) did not fux the corruption either. At any rate, scope traces show very
clean data and clock waveforms (as is to be expected at such a low frequency).</p>
<h4>Aligned writes to RAM!</h4>
<p>The test function used <code>HAL_SD_ReadBlocks</code> to write directly into DRAM. If
instead I wrote to a static buffer in SYSRAM, it works just fine.</p>
<p>So reading data from the SD card into a static buffer worked perfectly, but
copying that data into DRAM using a byte-wise method like memcpy caused
intermittent corruption. Only every other byte was sometimes wrong, always off
by exactly 2, and the pattern varied with each read. This behavior was not
reproducible when filling DRAM directly with aligned 32-bit word writes, which
always produced correct data.</p>
<p>The root cause is that the DDR wiring swapped upper and lower data bytes in a
way that only causes problems with non-32-bit data access. (The debugging
process that led to that insight is explained in a <a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">future
article</a>.) The SD
read itself was not at fault; the static buffer contained the correct bytes.</p>
<p>The workaround was to copy the SD block into DRAM using explicit 32-bit aligned
word writes, constructing each word from four bytes of the static buffer. This
ensures all writes are properly aligned and word-sized, eliminating the
intermittent errors and producing fully correct, reproducible data in DRAM.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="imperfection-as-practice">Imperfection as a Practice</a></h2>
<div class="article-meta">Published 19 Dec 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/phen.jpg"/></p>
<p>Tunnel vision is a big problem in the design process. It takes the form of
overly optimizing one particular parameter of a system, which takes the whole
into a local optimum, takes a long time, and inhibits the completion of a
project—sometimes forever.</p>
<p>The way out is to recognize it happening and consciously accept imperfection as
a Good Thing, for the best is the enemy of the good. This can mean accepting
resource underutilization, visual imbalance, or even performance tradeoffs.</p>
<p>Nature is robust, omnipresent, and not at all perfect. Imitate nature.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="usb-bringup-on-custom-stm32mp135-board">USB Bring-Up on a Custom STM32MP135 Board</a></h2>
<div class="article-meta">Published 4 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/zen.jpg"/></p>
<p>Getting USB up and running in bare-metal mode using the ST HAL drivers on my
<a href="https://github.com/js216/stm32mp135_test_board">custom STM32MP135</a> board took a
couple attempts. After a few false starts with the example projects, I was able
to make the board enumerate correctly, handle data transfers, and even read and
write files reliably. In this article, I’ll walk through the hardware tweaks,
HAL configuration, and debugging steps that helped me turn a stubborn USB
interface into a fully working USB Mass Storage device.</p>
<h3 id="initial-attempts">Initial attempts</h3>
<p>I gave up trying to make the provided <code>CDC_Standalone</code> example from
<a href="https://wiki.st.com/stm32mpu/wiki/STM32CubeMP13_Package_-_Getting_started"><code>STM32Cube_FW_MP13_V1.2.0</code></a>
to work on the eval board, let alone the custom board. Instead, let’s get USB to
work step by step.</p>
<p>First, the <code>VDD3V3_USBHS</code> must not be powered on when <code>VDDA1V8_REG</code> is not
present. For that, we have the switch U201 (NCP380), but the board unfortunately
uses the adjustable-current version of the switch w/o the adjustment resistor
present, so the USBHS circuitry is disabled. So we first have to solder a
resistor (I had 39k + 10k at hand) to enable power to the USB circuit.</p>
<p>With that fix, if I reset the device with <code>BOOT=000</code> (so PA13 LED blinks), then
plug the USB cable, then the LED stops blinking and the device manager shows
<code>DFU in FS Mode @Device ID /0x501, @Revision ID /0x1003</code> as it should—so the
hardware works, we just need to fix the code. (Without the added resistor,
Windows was not able to enumerate the device and the Device Manager shows it as
<code>Unknown USB Device (Device Descriptor Request Failed)</code>.)</p>
<p>In the <code>main()</code> function, I blink LED and print “:” on UART4 every second after
starting the USB using <code>MX_USB_OTG_HS_PCD_Init()</code> and <code>HAL_PCD_Start();</code>
functions. If I load the code with the USB cable plugged in, the “:” signs get
printed every second as they should, and also the LED blinks. If I unplug the
USB cable, then the printing and blinking stops—the code appears locked up.
The code also locks up if I select “Disable device” in Windows Device Manager.
If I load the code with USB cable not plugged in, only the first “:” gets
printed and then the code locks up.</p>
<h3 id="vbus-sense">VBUS sense?</h3>
<p>Before the main loop we also see that <code>OTG_GCCFG: 0x00000000</code>, which means that
both of the following are disabled:</p>
<ul>
<li>IDEN: USB ID detection enable</li>
<li>VBDEN: USB VBUS detection enable</li>
</ul>
<p>Note that the hardware has a permanent 1.5K pullup (up to +3.3V) on D+, so the
USB driver does not need VBUS sensing. (The board is externally powered, so
removing the cable would not unpower the core or the USB PHY.) We explicitly
disable sensing VBUS in <code>MX_USB_OTG_HS_PCD_Init()</code>, where we create the
structure passed to <code>HAL_PCD_Init()</code> with the following line:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hpcd_USB_OTG_HS</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">vbus_sensing_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DISABLE</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>With that request, the driver function <code>USB_DevInit()</code> clears the enable for
VBUS sensing in the <code>GCCFG</code> register:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">vbus_sensing_enable</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0U</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">USBx_DEVICE</span><span class="o">-&gt;</span><span class="n">DCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_DCTL_SDIS</span><span class="p">;</span>

<span class="cm">/* Deactivate VBUS Sensing B */</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GCCFG</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">USB_OTG_GCCFG_VBDEN</span><span class="p">;</span>

<span class="cm">/* B-peripheral session valid override enable */</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GOTGCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_GOTGCTL_BVALOEN</span><span class="p">;</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GOTGCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_GOTGCTL_BVALOVAL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h3 id="interrupt-storm">Interrupt storm?</h3>
<p>I checked that the USB interrupt service routine (<code>HAL_PCD_IRQHandler()</code>) is
linked by locating it in the map file (and not in the “Discarded input
sections”!). Just before the main loop, we print <code>OTG_GAHBCFG: 0x00000001</code>,
showing that OTG USB interrupts are unmasked, and <code>OTG_GINTMSK: 0x803C3810</code>,
which means the following interrupts are enabled:</p>
<ul>
<li>Bit 4: RXFLVLM: Receive FIFO non-empty mask</li>
<li>Bit 11: USBSUSPM: USB suspend mask</li>
<li>Bit 12: USBRST: USB reset mask</li>
<li>Bit 13: ENUMDNEM: Enumeration done mask</li>
<li>Bit 18: IEPINT: IN endpoints interrupt mask</li>
<li>Bit 19: OEPINT: OUT endpoints interrupt mask</li>
<li>Bit 20: IISOIXFRM: Incomplete isochronous IN transfer mask</li>
<li>Bit 21: IISOOXFRM: Incomplete isochronous OUT transfer mask</li>
<li>Bit 31: WUIM: Resume/remote wake-up detected interrupt mask</li>
</ul>
<p>If we <code>IRQ_Disable(OTG_IRQn)</code> before the main loop, than “Disable device” and
“Enable device” do not cause the core lockup. So, we just need to find out which
of the OTG USB interrupts exactly are not correctly handled, one by one.</p>
<p>If we enable just <code>USBSUSPM</code>, the locked happens. If we allow all the interrupts
that HAL enables, and then disable <code>USBSUSPM</code>, the lockup does <em>not</em> happen.</p>
<p>If we enable <code>USBRST</code> only, lockup does not happen. If we in addition add
<code>ENUMDNEM</code>, still no lockup. Add <code>IEPINT</code>, no lockup. Add <code>OEPINT</code>, no lockup.
Add <code>IISOIXFRM</code>, <code>PXFRM_IISOOXFRM</code>, and <code>WUIM</code>: no lockup.</p>
<p>If <code>USBRST</code> is the only enabled OTG interrupt, then the code locks up if the
cable is not plugged in when it starts executing, but it does not lock up if the
cable is present when it starts executing and is then unplugged.</p>
<p>If <code>USBSUSPM</code> is the only enabled OTG interrupt, then the code locks up both if
the cable is not present initially, or if it is unplugged later.</p>
<h3 id="jtag-again">JTAG again</h3>
<p>Meanwhile I figured out how to get the JTAG to work mostly reliably. First,
remember to boot with <code>BOOT=100</code>, the “Engineering debug mode”, otherwise the
JTAG is disabled. Then, the procedure is</p>
<ol>
<li>Turn the 1.35V supply off and on again.</li>
<li>Press the reset button on the PCB.</li>
<li>Open <code>JLinkGDBServer.exe</code></li>
<li>Call <code>arm-none-eabi-gdb -q -x load.gdb</code></li>
</ol>
<p>The <code>load.gdb</code> file is as follows:</p>
<pre><code>set confirm off
set pagination off
file build/main.elf
target remote localhost:2330
monitor reset
monitor flash device=STM32MP135F
load build/main.elf
monitor go
break main
step
</code></pre>
<p>Loaded with the debugger, the program runs as before, and once USB “Disable
device” is clicked from the Windows Device Manager, the following appears on the
debugger after pressing Ctrl-C:</p>
<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.
0x2ffe0104 in Vectors () at drivers/startup_stm32mp135fxx_ca7.c:444
444       __asm__ volatile(
(gdb) bt
#0  0x2ffe0104 in Vectors () at drivers/startup_stm32mp135fxx_ca7.c:444
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb)
</code></pre>
<p>Searching the forums, I found a
<a href="https://community.st.com/t5/stm32-mpus-embedded-software-and/stm32mp1-interrupt-causes-undefined-exception-in-arm-mode-but/td-p/745347">post</a>
where user bsvi discovered that <code>startup_stm32mp135fxx_ca7.c</code> take interrupts to
thumb mode in the <code>Reset_Handler()</code>:</p>
<pre><code>/* Set TE bit to take exceptions in Thumb mode */
"ORR R0, R0, #(0x1 &lt;&lt; 30) \n"
</code></pre>
<p>If the vector table is aligned and encoded as ARM mode, the of course it cannot
work. Adding <code>-mthumb</code> and the interrupt immediately fired as was able to
confirm via a flashing LED at the top of the <code>HAL_PCD_IRQHandler()</code>. Stopping
the debugger there (Ctrl-C) confirmed that the code was executing there.</p>
<p>Better yet, we can remove the <code>-mthumb</code> and simply take interrupts to ARM mode:</p>
<pre><code>/* TE = 0, exceptions enter ARM mode */
"BIC R0, R0, #(1 &lt;&lt; 30) \n"
</code></pre>
<p>I changed the debug code at the top of <code>HAL_PCD_IRQHandler()</code> to just a print
statement, and it prints any time the USB cable is plugged in and out. Great!</p>
<h3 id="usb-device-stack">USB Device Stack</h3>
<p>Now that USB interrupts are no longer freezing the whole system, we can begin
work on integrating the ST USB Device “middleware”. The initialization proceeds
as the following approximate sequence of function calls:</p>
<pre><code>MX_USB_Device_Init (usb_device.c)
   USBD_Init (usbd_core.c)
      USBD_LL_Init (usb_conf.c)
         HAL_PCD_Init (usbd_conf.c)
         HAL_PCDEx_SetRxFiFo (stm32mp13xx_hal_pcd_ex.c)
         HAL_PCDEx_SetTxFiFo (stm32mp13xx_hal_pcd_ex.c)
   USBD_RegisterClass (usbd_core.c)
   USBD_CDC_RegisterInterface (usbd_cdc.c)
   USBD_Start (usbd_core.c)
      USBD_LL_Start (usbd_conf.c)
         HAL_PCD_Start (stm32mp13xx_hal_pcd.c)
            USB_DevConnect (stm32mp13xx_ll_usb.c)
         USBD_Get_USB_Status (usbd_conf.c)
</code></pre>
<p>The example above is for a CDC-class application, but here we’re interested in a
mass-storage class device (MSC). The USB files divide into four types:</p>
<ul>
<li>HAL drivers: <code>stm32mp13xx_ll_usb.c</code>, <code>stm32mp13xx_hal_pcd.c</code>,
<code>stm32mp13xx_hal_pcd_ex.c</code></li>
<li>USB device core: <code>usbd_core.c</code>, <code>usbd_ctlreq.h</code>, <code>usbd_ioreq.c</code></li>
<li>USB class: <code>usbd_msc.c</code>, <code>usbd_msc_bot.c</code>, <code>usbd_msc_data.c</code>,
<code>usbd_msc_scsi.c</code></li>
<li>app-specific: <code>usb_device.c</code>, <code>usbd_conf.c</code>, <code>usbd_desc.c</code>, <code>usbd_msc_storage.c</code></li>
</ul>
<p>An example of how the ST drivers are used for MSC class is provided in
<a href="https://github.com/4ms/stm32mp1-baremetal/tree/master/examples/usb_msc_device">this</a>
repository.</p>
<p>For testing, we call the following from the main function:</p>
<pre><code>USBD_Init(&amp;USBD_Device, &amp;MSC_Desc, 0);
USBD_RegisterClass(&amp;USBD_Device, USBD_MSC_CLASS);
USBD_MSC_RegisterStorage(&amp;USBD_Device, &amp;USBD_MSC_fops);
USBD_Start(&amp;USBD_Device);
</code></pre>
<p>The functions complete, and then the main loop is active, blinking LED and
printing to UART. The debug print in <code>HAL_PCD_IRQHandler</code> shows that the IRQ is
called a couple times, but after a few seconds, the Windows Device Manager shows
<code>Unknown USB Device (Device Descriptor Request Failed)</code>.</p>
<p>As it turns out, I have forgotten to add the callbacks into <code>usbd_conf.c</code>. Once
that was done, the USB access from the Windows computer caused an immediate Data
Abort on the STM32MP135.</p>
<h3 id="aligned-sysram-memory-access">Aligned SYSRAM memory access</h3>
<p>The aborts happen in <code>usbd_msc_scsi.c</code> in lines such as the following:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_addr</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_len</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</pre></div>
</code></pre>
<p>As it happens, with some optimizations (I’m using <code>-Os</code> to make the whole
program fit in SYSRAM!) the compiler optimizes the byte access into a misaligned
32-bit access. Forcing a <code>volatile</code> cast fixes the problem, as follows:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_addr</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>

<span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_len</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">7</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">8</span><span class="p">]);</span>
</pre></div>
</code></pre>
<p>Make sure to repeat this several times! Search for <code>scsi_blk_addr</code> in
<code>usbd_msc_scsi.c</code> until you’ve cast all of them correctly.</p>
<p>Then, at last, the USB device enumerates as MSC correctly, and we can even read
and write raw data! However, Windows is not able to format the device.</p>
<h3 id="aligned-ddr-ram-memory-access">Aligned DDR RAM memory access</h3>
<p>Now that data can be read and written to, we observe an odd pattern:</p>
<pre><code>WRITE: eb 3c 90 6d 6b 66 73 2e 66 61
READ:  eb 00 90 3c 6b 6d 73 66 66 2e
</code></pre>
<p>Every other byte is a bit wrong, or reshuffled. Sounds familiar? Yes, it happens
if DDR writes are not aligned to word boundaries, as we experienced before with
the SD card, copying it’s data to DDR. (The debugging process that led to that
insight is explained in a <a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">future
article</a>.)</p>
<p>With the write fixed (i.e., done in correctly aligned units of 4 bytes), the
device format works, and we can even copy files to the mass storage device, and
read them back. The problems is now … read and write speeds are about 700
kB/s.</p>
<h3 id="d-pullup">D+ pullup</h3>
<p>As it happens, the USB interface on the custom board has a external, physical
1.5K pullup on the D+ line which signals a Full-Speed device. To switch to
High-Speed mode, the device needs to be able to have the pullup present
initially, but then switch it off. Indeed, Device Manager shows that the device
enumerated as a Full-Speed device, hence the low data rates.</p>
<p>Removing the resistor, the device does not enumerate, or appear at all in the
Device Manager. However, we can simply set</p>
<pre><code>hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_FULL;
</code></pre>
<p>in <code>USBD_LL_Init()</code> function (<code>usbd_conf.c</code>), and then everything works as
before. So something must be wrong with the high-speed mode configuration.</p>
<h3 id="cables-hubs-ports">Cables, hubs, ports</h3>
<p>Since removing the 1.5K pullup which was keeping the device in Full-Speed (FS)
mode, the device does not enumerate, neither in DFU mode (with <code>BOOT</code> pins set
to <code>000</code>), nor using my test firmware (unless I request FS mode directly).</p>
<p>Inserting print statements or debug breakpoints in USB interrupt handler we see
that the USB reset is detected, the device is correctly switched to HS mode
(<code>speed=0</code>), the Rx/Tx FIFOs are large enough, the <code>RXFLVL</code> interrupt is enabled
but it never arrives. The enumeration completes, but the device does not see any
setup or data packets enter the FIFO, and then the device gets suspended,
presumably because it did not reply to the host’s communications. The device
never appears in the Device Manager, or even in <a href="https://www.uwe-sieber.de/usbtreeview_e.html">USB Device Tree
Viewer</a>.</p>
<p>With <code>BOOT=000</code>, pressing reset causes the PA13 LED to blink, and when the USB
cable is attached, the blinking stops. But looking at the device and USB trees,
nothing happens. Even the <code>STM32_Programmer_CLI -l usb</code> does not see anything:</p>
<pre><code>      -------------------------------------------------------------------
                       STM32CubeProgrammer v2.18.0
      -------------------------------------------------------------------

=====  DFU Interface   =====

No STM32 device in DFU mode connecte
</code></pre>
<p>Now a different USB cable was found, connected to a different hub/port. Again
<code>BOOT=000</code>, press reset, PA13 LED blinks, and the new cable is connected, and
the blinking stops. Immediately the Device Manager and the USB Device Tree
Viewer report <code>DFU in FS Mode @Device ID /0x501, @Revision ID /0x1003</code>, so the
device enumerated. (About the “FS”: I think that’s just a cached name, since the
USB Tree also says that “Device Connection Speed  : High-Speed”.) And CubeProg:</p>
<pre><code>      -------------------------------------------------------------------
                       STM32CubeProgrammer v2.18.0
      -------------------------------------------------------------------

=====  DFU Interface   =====

Total number of available STM32 device in DFU mode: 1

  Device Index           : USB1
  USB Bus Number         : 001
  USB Address Number     : 005
  Product ID             : DFU in HS Mode @Device ID /0x501, @Revision ID /0x1003
  Serial number          : 001E00263133511332303636
  Firmware version       : 0x0110
  Device ID              : 0x0501
</code></pre>
<p>Clearly, the bad cable or hub or port was stopping the HS enumeration, at least
in DFU mode. Now let’s switch to <code>BOOT=100</code>, reset, and load our firmware via
JTAG. And … it enumerates immediately! Windows offers to format it as FAT32,
and the file write speed is up to about 4 MB/s, and read about 2 MB/s. Great
success! But could have checked the cable first.</p>
<h3 id="speed">Speed</h3>
<p>Regarding the low-ish data rates: it’s probably limited by a combination of the
slow implementations of the <code>usbd_msc_storage.c</code> backend, and the HAL driver or
other things. For firmware flashing the speed is good enough. More importantly,
it proves that everything is now wired correctly. Nonetheless, let’s see if we
can make it go faster than the 2–4 MB/s.</p>
<p>Changing the compiler optimization level from <code>-Os</code> to <code>-O3</code> brings the write
speed up to 7.6 MB/s. Windows has a built-in disk performance checker which
shows:</p>
<pre><code>C:\Users\Jkastelic&gt; winsat disk -drive e
&gt; Disk  Random 16.0 Read                       2.87 MB/s          4.5
&gt; Disk  Sequential 64.0 Read                   2.91 MB/s          2.2
&gt; Disk  Sequential 64.0 Write                  7.67 MB/s          2.6
&gt; Average Read Time with Sequential Writes     8.566 ms          4.9
&gt; Latency: 95th Percentile                     21.499 ms          4.5
&gt; Latency: Maximum                             22.485 ms          7.9
&gt; Average Read Time with Random Writes         9.149 ms          4.7

winsat disk -write -ran -drive e
&gt; Disk  Random 16.0 Write                      7.46 MB/s
</code></pre>
<p>Next, re-write the <code>STORAGE_Read</code> function to use 32-bit writes instead of
forcing 8-bit accesses (as we did previously while debugging the data
corruption). This improves the reads significantly:</p>
<pre><code>&gt; Disk  Random 16.0 Read                       9.02 MB/s          5.3
&gt; Disk  Sequential 64.0 Read                   9.39 MB/s          2.8
&gt; Disk  Sequential 64.0 Write                  7.71 MB/s          2.6
&gt; Average Read Time with Sequential Writes     3.134 ms          6.6
&gt; Latency: 95th Percentile                     8.109 ms          5.9
&gt; Latency: Maximum                             9.516 ms          8.0
&gt; Average Read Time with Random Writes         3.138 ms          6.5
</code></pre>
<p>Now consider the FIFO allocation. The USB OTG core in the STM32MP135 has 4 kB
of total FIFO. If we used all of it just for sending data back to the host, at
the 480 MBit/s (70 MB/s) data rate, the microcontroller would fire interrupts
or DMA requests every 67 μs. (USB devices designed for mass data transfer
probably have larger buffers.) Currently we have</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">HAL_PCDEx_SetRxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mh">0x200</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x100</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Let us significantly increase the buffer that sends data to the host:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">HAL_PCDEx_SetRxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mh">0x100</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2e0</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Unfortunately, the read/write performance is essentially unchanged:</p>
<pre><code>&gt; Disk  Random 16.0 Read                       9.89 MB/s          5.4
&gt; Disk  Sequential 64.0 Read                   10.28 MB/s          2.9
&gt; Disk  Sequential 64.0 Write                  7.59 MB/s          2.6
&gt; Average Read Time with Sequential Writes     3.311 ms          6.5
&gt; Latency: 95th Percentile                     8.236 ms          5.9
&gt; Latency: Maximum                             9.306 ms          8.1
&gt; Average Read Time with Random Writes         3.279 ms          6.5
</code></pre>
<p>All of that was without DMA. It might be that DMA would make it faster, or at
least unburden the CPU—but in this example, the CPU is not doing anything
except copying the data. (CPU can actually be <em>faster</em> in copying; the point of
DMA is to allow the CPU to do other, more interesting things while the copy is
taking place.)</p>
<h3 id="code-availability">Code availability</h3>
<p>You can find the final version of the USB test in
<a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/usb_test">this</a>
repository.</p>
<p>It compiles to about 117 kB with <code>-Os</code> optimization, so it fits in
SYSRAM directly. If you need more speed, <code>-O3</code> makes it compile to about 136 kB.
That’s still acceptable if we combine all of the on-chip memory into a single
block, as shown in this excerpt from the <a href="https://github.com/js216/stm32mp135_test_board/blob/main/baremetal/usb_test/stm32mp13xx_a7_sysram.ld">linker
script</a>:</p>
<pre><code>MEMORY {
      SYSRAM_BASE (rwx)   : ORIGIN = 0x2FFE0000, LENGTH = 128K
      SRAM1_BASE (rwx)    : ORIGIN = 0x30000000, LENGTH = 16K
      SRAM2_BASE (rwx)    : ORIGIN = 0x30004000, LENGTH = 8K
      SRAM3_BASE (rwx)    : ORIGIN = 0x30006000, LENGTH = 8K
      /* InternalMEM = SYSRAM + SRAM1 + SRAM2 + SRAM3 */
      InternalMEM (rwx)   : ORIGIN = 0x2FFE0000, LENGTH = 160K
      DDR_BASE (rwx)      : ORIGIN = 0xC0000000, LENGTH = 512M
}
</code></pre>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page4.html">← Older articles</a></div>
        <div><a class="newer" href="page2.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
