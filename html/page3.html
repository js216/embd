<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="sdcard-on-bare-metal-stm32mp135">SD card on bare-metal STM32MP135</a></h2>
<div class="article-meta">Published 20 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/deco.jpg"/></p>
<p>This article presents my step-by-step debug process for getting the SD card to
work reliably on my <a href="https://github.com/js216/stm32mp135_test_board">custom
board</a> integrating the
STM32MP135.</p>
<h3 id="test-program">Test program</h3>
<p>For the evaluation board, I prepared a <a href="https://github.com/js216/mp135_boot/tree/main/sd_to_ddr">simple
example</a> that reads a
program (blink) from SD card to DDR, and passes control to the program. The LED
blinks, everything is fine.</p>
<p>On the custom board, I simplified the example so it just tests that DDR and SD
card can be written to and read from. The SD initialization fails as follows.
In file <code>stm32mp13xx_hal_sd.c</code>, the function <code>HAL_SD_Init</code> calls
<code>HAL_SD_GetCardStatus</code> which calls <code>SD_SendSDStatus</code>. There, the error flag
<code>SDMMC_FLAG_DTIMEOUT</code> is detected, i.e. timeout when trying to get data.</p>
<h3 id="wiring">Wiring</h3>
<p>The custom board connections from MCU to SD card pins are as follows:</p>
<pre><code>PC10/SDMMC1_D2 (B13) → 1 DAT2
PC11/SDMMC1_D3 (C14) → 2 DAT3/CD
PD2/SDMMC1_CMD (A15) → 3 CMD with 10k pullup to +3.3V
+3.3V → 4 VDD
PC12/SDMMC1_CK (B15) → 5 CLK
GND → 6 VSS
PC8/SDMMC_D0 (D14) → 7 DAT0
PC9/SDMMC_D1 (A16) → 8 DAT1
PI7 (U16) uSD_DETECT → 9 DET_B with 100K pullup to +3.3V
(nc) → 10 DET_A
</code></pre>
<p>Since the failure happens soon after switching the card into 1.8V mode, I need
to verify the voltages. On the evaluation board, <code>VDD_SD</code> is 3.3V on boot, and
when the SD program is running, it lowers it to 2.9V. I modified the code to
leave it at 3.3V, and it worked also: the code read data from SD card correctly.
On my custom board, <code>VDD_SD</code> is tied to 3.3V directly. (SD cards should accept
abything from 2.7V to 3.6V.) Thus, the SD card voltage should be okay.</p>
<p>The other voltage to check is the one powering the SoC domain for the SDMMC
controller. The eval board shows that both <code>VDDSD1</code> and <code>VDDSD2</code> are tied to
<code>VDD</code>—the same <code>VDD</code> as the rest of the SoC. We can measure that easily via
CN14 pin 13, and it measures 3.3V. On the custom board, these are tied to 3.3V
directly.</p>
<p>On the eval board, I looked at the <code>SDMMC1_CK</code> line (about 1.56 MHz),
<code>SDMMC1_CMD</code>, and the data lines with a scope probe and I saw 3V logic signals,
so it does not seem that 1.8V logic is used.</p>
<h3 id="debug-prints">Debug prints</h3>
<p>Adding lots of print statements to <code>SD_PowerON</code>, we get the following when
running on the custom board:</p>
<pre><code>CMD0: Go Idle State...
CMD0 result = 0x00000000
CMD8: Send Interface Condition...
CMD8 result = 0x00000000
CMD8 OK -&gt; CardVersion = V2.x
CMD55: APP_CMD (arg=0)
CMD55 result = 0x00000000
ACMD41 loop...
Loop 0
  CMD55...
  CMD55 result = 0x00000000
  ACMD41...
  ACMD41 result = 0x00000000
  R3 Response = 0x41FF8000
  ValidVoltage = 0
Loop 1
  CMD55...
  CMD55 result = 0x00000000
  ACMD41...
  ACMD41 result = 0x00000000
  R3 Response = 0xC1FF8000
  ValidVoltage = 1
ACMD41 success: OCR=0xC1FF8000
Card reports High Capacity (SDHC/SDXC)
SD_PowerON: SUCCESS
</code></pre>
<p>Followed by the same <code>HAL_SD_ERROR_DATA_TIMEOUT</code> error from <code>SD_SendSDStatus</code>.
Let’s instrument the latter function with prints also. Here’s what we get:</p>
<pre><code>--- SD_SendSDStatus BEGIN ---
Initial RESP1 = 0x00000900
CMD16: Set Block Length = 64...
CMD16 result = 0x00000000
CMD55: APP_CMD (arg=RCA&lt;&lt;16) = 0xAAAA0000
CMD55 result = 0x00000000
Configuring DPSM: len=64, block=64B
ACMD13: Send SD Status...
ACMD13 result = 0x00000000
Waiting for data...
ERROR: SDMMC_FLAG_DTIMEOUT detected!
</code></pre>
<h4>Pullups?</h4>
<p>The SD card initialization was inherited from the evaluation board, where
all the signals are passed through the <code>EMIF06-MSD02N16</code> ESD protection chip,
which also features built-in pullups.</p>
<p>In <code>HAL_SD_MspInit</code>, we can enable internal pullups on the data lines going to
the SD card. In that case, we get the following printout from the instrumented
version of <code>SD_SendSDStatus</code>:</p>
<pre><code>--- SD_SendSDStatus BEGIN ---
Initial RESP1 = 0x00000900
CMD16: Set Block Length = 64...
CMD16 result = 0x00000000
CMD55: APP_CMD (arg=RCA&lt;&lt;16) = 0xAAAA0000
CMD55 result = 0x00000000
Configuring DPSM: len=64, block=64B
ACMD13: Send SD Status...
ACMD13 result = 0x00000000
Waiting for data...
RXFIFOHF set — reading 8 words...
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000004
  FIFO -&gt; 0x00900004
  FIFO -&gt; 0x001A050F
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000100
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
RXFIFOHF set — reading 8 words...
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
  FIFO -&gt; 0x00000000
Data-end flag set, reading remaining FIFO...
Clearing static DATA flags
--- SD_SendSDStatus SUCCESS ---
</code></pre>
<p>After that, reading from the SD card was possible—but about half of the bytes
read were slightly corrupted.</p>
<h4>Data corruption</h4>
<p>Suspecting that there is something wrong with the 4-bit data transfers, I
switched to <code>SDMMC_BUS_WIDE_1B</code> and confirmed with a scope probe that there is
no data on DAT1,2,3, only on DAT0. But data corruption is still there. The clock
speed is only about 1.56 MHz, which seems to rule out signal integrity issues.</p>
<p>I tried a different power supply for the 3.3V supply, and still the same issue.
I added 330uF capacitors on all three power rails (1.25V, 1.35V, 3.3V, althought
1.25V and 1.35V are connected together), and still no improvement. (The PCB
already has a 10U capacitor next to the SD card VDD pin.)</p>
<p>Changing the <code>ClockEdge</code> of the <code>SDHandle.Init</code> does not fix it. Nor did setting
<code>PIO_Init_Structure.Speed</code> to <code>GPIO_SPEED_FREQ_VERY_HIGH</code>.</p>
<p>Interestingly the corruption affects only every other byte, and if it is
corrupted, it’s always just off by 2 (i.e., only bit number 1 is affected).</p>
<p>Adding the external 3.3V 10k pullup on DAT0 (when running in <code>SDMMC_BUS_WIDE_1B</code>
mode) did not fux the corruption either. At any rate, scope traces show very
clean data and clock waveforms (as is to be expected at such a low frequency).</p>
<h4>Aligned writes to RAM!</h4>
<p>The test function used <code>HAL_SD_ReadBlocks</code> to write directly into DRAM. If
instead I wrote to a static buffer in SYSRAM, it works just fine.</p>
<p>So reading data from the SD card into a static buffer worked perfectly, but
copying that data into DRAM using a byte-wise method like memcpy caused
intermittent corruption. Only every other byte was sometimes wrong, always off
by exactly 2, and the pattern varied with each read. This behavior was not
reproducible when filling DRAM directly with aligned 32-bit word writes, which
always produced correct data.</p>
<p>The root cause is that the DDR wiring swapped upper and lower data bytes in a
way that only causes problems with non-32-bit data access. (The debugging
process that led to that insight is explained in a <a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">future
article</a>.) The SD
read itself was not at fault; the static buffer contained the correct bytes.</p>
<p>The workaround was to copy the SD block into DRAM using explicit 32-bit aligned
word writes, constructing each word from four bytes of the static buffer. This
ensures all writes are properly aligned and word-sized, eliminating the
intermittent errors and producing fully correct, reproducible data in DRAM.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="imperfection-as-practice">Imperfection as a Practice</a></h2>
<div class="article-meta">Published 19 Dec 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/phen.jpg"/></p>
<p>Tunnel vision is a big problem in the design process. It takes the form of
overly optimizing one particular parameter of a system, which takes the whole
into a local optimum, takes a long time, and inhibits the completion of a
project—sometimes forever.</p>
<p>The way out is to recognize it happening and consciously accept imperfection as
a Good Thing, for the best is the enemy of the good. This can mean accepting
resource underutilization, visual imbalance, or even performance tradeoffs.</p>
<p>Nature is robust, omnipresent, and not at all perfect. Imitate nature.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="usb-bringup-on-custom-stm32mp135-board">USB Bring-Up on a Custom STM32MP135 Board</a></h2>
<div class="article-meta">Published 4 Dec 2025, modified 9 Jan 2026. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/zen.jpg"/></p>
<p>Getting USB up and running in bare-metal mode using the ST HAL drivers on my
<a href="https://github.com/js216/stm32mp135_test_board">custom STM32MP135</a> board took a
couple attempts. After a few false starts with the example projects, I was able
to make the board enumerate correctly, handle data transfers, and even read and
write files reliably. In this article, I’ll walk through the hardware tweaks,
HAL configuration, and debugging steps that helped me turn a stubborn USB
interface into a fully working USB Mass Storage device.</p>
<h3 id="initial-attempts">Initial attempts</h3>
<p>I gave up trying to make the provided <code>CDC_Standalone</code> example from
<a href="https://wiki.st.com/stm32mpu/wiki/STM32CubeMP13_Package_-_Getting_started"><code>STM32Cube_FW_MP13_V1.2.0</code></a>
to work on the eval board, let alone the custom board. Instead, let’s get USB to
work step by step.</p>
<p>First, the <code>VDD3V3_USBHS</code> must not be powered on when <code>VDDA1V8_REG</code> is not
present. For that, we have the switch U201 (NCP380), but the board unfortunately
uses the adjustable-current version of the switch w/o the adjustment resistor
present, so the USBHS circuitry is disabled. So we first have to solder a
resistor (I had 39k + 10k at hand) to enable power to the USB circuit.</p>
<p>With that fix, if I reset the device with <code>BOOT=000</code> (so PA13 LED blinks), then
plug the USB cable, then the LED stops blinking and the device manager shows
<code>DFU in FS Mode @Device ID /0x501, @Revision ID /0x1003</code> as it should—so the
hardware works, we just need to fix the code. (Without the added resistor,
Windows was not able to enumerate the device and the Device Manager shows it as
<code>Unknown USB Device (Device Descriptor Request Failed)</code>.)</p>
<p>In the <code>main()</code> function, I blink LED and print “:” on UART4 every second after
starting the USB using <code>MX_USB_OTG_HS_PCD_Init()</code> and <code>HAL_PCD_Start();</code>
functions. If I load the code with the USB cable plugged in, the “:” signs get
printed every second as they should, and also the LED blinks. If I unplug the
USB cable, then the printing and blinking stops—the code appears locked up.
The code also locks up if I select “Disable device” in Windows Device Manager.
If I load the code with USB cable not plugged in, only the first “:” gets
printed and then the code locks up.</p>
<h3 id="vbus-sense">VBUS sense?</h3>
<p>Before the main loop we also see that <code>OTG_GCCFG: 0x00000000</code>, which means that
both of the following are disabled:</p>
<ul>
<li>IDEN: USB ID detection enable</li>
<li>VBDEN: USB VBUS detection enable</li>
</ul>
<p>Note that the hardware has a permanent 1.5K pullup (up to +3.3V) on D+, so the
USB driver does not need VBUS sensing. (The board is externally powered, so
removing the cable would not unpower the core or the USB PHY.) We explicitly
disable sensing VBUS in <code>MX_USB_OTG_HS_PCD_Init()</code>, where we create the
structure passed to <code>HAL_PCD_Init()</code> with the following line:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hpcd_USB_OTG_HS</span><span class="p">.</span><span class="n">Init</span><span class="p">.</span><span class="n">vbus_sensing_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DISABLE</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>With that request, the driver function <code>USB_DevInit()</code> clears the enable for
VBUS sensing in the <code>GCCFG</code> register:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">vbus_sensing_enable</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0U</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">USBx_DEVICE</span><span class="o">-&gt;</span><span class="n">DCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_DCTL_SDIS</span><span class="p">;</span>

<span class="cm">/* Deactivate VBUS Sensing B */</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GCCFG</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">USB_OTG_GCCFG_VBDEN</span><span class="p">;</span>

<span class="cm">/* B-peripheral session valid override enable */</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GOTGCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_GOTGCTL_BVALOEN</span><span class="p">;</span>
<span class="n">USBx</span><span class="o">-&gt;</span><span class="n">GOTGCTL</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">USB_OTG_GOTGCTL_BVALOVAL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<h3 id="interrupt-storm">Interrupt storm?</h3>
<p>I checked that the USB interrupt service routine (<code>HAL_PCD_IRQHandler()</code>) is
linked by locating it in the map file (and not in the “Discarded input
sections”!). Just before the main loop, we print <code>OTG_GAHBCFG: 0x00000001</code>,
showing that OTG USB interrupts are unmasked, and <code>OTG_GINTMSK: 0x803C3810</code>,
which means the following interrupts are enabled:</p>
<ul>
<li>Bit 4: RXFLVLM: Receive FIFO non-empty mask</li>
<li>Bit 11: USBSUSPM: USB suspend mask</li>
<li>Bit 12: USBRST: USB reset mask</li>
<li>Bit 13: ENUMDNEM: Enumeration done mask</li>
<li>Bit 18: IEPINT: IN endpoints interrupt mask</li>
<li>Bit 19: OEPINT: OUT endpoints interrupt mask</li>
<li>Bit 20: IISOIXFRM: Incomplete isochronous IN transfer mask</li>
<li>Bit 21: IISOOXFRM: Incomplete isochronous OUT transfer mask</li>
<li>Bit 31: WUIM: Resume/remote wake-up detected interrupt mask</li>
</ul>
<p>If we <code>IRQ_Disable(OTG_IRQn)</code> before the main loop, than “Disable device” and
“Enable device” do not cause the core lockup. So, we just need to find out which
of the OTG USB interrupts exactly are not correctly handled, one by one.</p>
<p>If we enable just <code>USBSUSPM</code>, the locked happens. If we allow all the interrupts
that HAL enables, and then disable <code>USBSUSPM</code>, the lockup does <em>not</em> happen.</p>
<p>If we enable <code>USBRST</code> only, lockup does not happen. If we in addition add
<code>ENUMDNEM</code>, still no lockup. Add <code>IEPINT</code>, no lockup. Add <code>OEPINT</code>, no lockup.
Add <code>IISOIXFRM</code>, <code>PXFRM_IISOOXFRM</code>, and <code>WUIM</code>: no lockup.</p>
<p>If <code>USBRST</code> is the only enabled OTG interrupt, then the code locks up if the
cable is not plugged in when it starts executing, but it does not lock up if the
cable is present when it starts executing and is then unplugged.</p>
<p>If <code>USBSUSPM</code> is the only enabled OTG interrupt, then the code locks up both if
the cable is not present initially, or if it is unplugged later.</p>
<h3 id="jtag-again">JTAG again</h3>
<p>Meanwhile I figured out how to get the JTAG to work mostly reliably. First,
remember to boot with <code>BOOT=100</code>, the “Engineering debug mode”, otherwise the
JTAG is disabled. Then, the procedure is</p>
<ol>
<li>Turn the 1.35V supply off and on again.</li>
<li>Press the reset button on the PCB.</li>
<li>Open <code>JLinkGDBServer.exe</code></li>
<li>Call <code>arm-none-eabi-gdb -q -x load.gdb</code></li>
</ol>
<p>The <code>load.gdb</code> file is as follows:</p>
<pre><code>set confirm off
set pagination off
file build/main.elf
target remote localhost:2330
monitor reset
monitor flash device=STM32MP135F
load build/main.elf
monitor go
break main
step
</code></pre>
<p>Loaded with the debugger, the program runs as before, and once USB “Disable
device” is clicked from the Windows Device Manager, the following appears on the
debugger after pressing Ctrl-C:</p>
<pre><code>Program received signal SIGTRAP, Trace/breakpoint trap.
0x2ffe0104 in Vectors () at drivers/startup_stm32mp135fxx_ca7.c:444
444       __asm__ volatile(
(gdb) bt
#0  0x2ffe0104 in Vectors () at drivers/startup_stm32mp135fxx_ca7.c:444
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
(gdb)
</code></pre>
<p>Searching the forums, I found a
<a href="https://community.st.com/t5/stm32-mpus-embedded-software-and/stm32mp1-interrupt-causes-undefined-exception-in-arm-mode-but/td-p/745347">post</a>
where user bsvi discovered that <code>startup_stm32mp135fxx_ca7.c</code> take interrupts to
thumb mode in the <code>Reset_Handler()</code>:</p>
<pre><code>/* Set TE bit to take exceptions in Thumb mode */
"ORR R0, R0, #(0x1 &lt;&lt; 30) \n"
</code></pre>
<p>If the vector table is aligned and encoded as ARM mode, the of course it cannot
work. Adding <code>-mthumb</code> and the interrupt immediately fired as was able to
confirm via a flashing LED at the top of the <code>HAL_PCD_IRQHandler()</code>. Stopping
the debugger there (Ctrl-C) confirmed that the code was executing there.</p>
<p>Better yet, we can remove the <code>-mthumb</code> and simply take interrupts to ARM mode:</p>
<pre><code>/* TE = 0, exceptions enter ARM mode */
"BIC R0, R0, #(1 &lt;&lt; 30) \n"
</code></pre>
<p>I changed the debug code at the top of <code>HAL_PCD_IRQHandler()</code> to just a print
statement, and it prints any time the USB cable is plugged in and out. Great!</p>
<h3 id="usb-device-stack">USB Device Stack</h3>
<p>Now that USB interrupts are no longer freezing the whole system, we can begin
work on integrating the ST USB Device “middleware”. The initialization proceeds
as the following approximate sequence of function calls:</p>
<pre><code>MX_USB_Device_Init (usb_device.c)
   USBD_Init (usbd_core.c)
      USBD_LL_Init (usb_conf.c)
         HAL_PCD_Init (usbd_conf.c)
         HAL_PCDEx_SetRxFiFo (stm32mp13xx_hal_pcd_ex.c)
         HAL_PCDEx_SetTxFiFo (stm32mp13xx_hal_pcd_ex.c)
   USBD_RegisterClass (usbd_core.c)
   USBD_CDC_RegisterInterface (usbd_cdc.c)
   USBD_Start (usbd_core.c)
      USBD_LL_Start (usbd_conf.c)
         HAL_PCD_Start (stm32mp13xx_hal_pcd.c)
            USB_DevConnect (stm32mp13xx_ll_usb.c)
         USBD_Get_USB_Status (usbd_conf.c)
</code></pre>
<p>The example above is for a CDC-class application, but here we’re interested in a
mass-storage class device (MSC). The USB files divide into four types:</p>
<ul>
<li>HAL drivers: <code>stm32mp13xx_ll_usb.c</code>, <code>stm32mp13xx_hal_pcd.c</code>,
<code>stm32mp13xx_hal_pcd_ex.c</code></li>
<li>USB device core: <code>usbd_core.c</code>, <code>usbd_ctlreq.h</code>, <code>usbd_ioreq.c</code></li>
<li>USB class: <code>usbd_msc.c</code>, <code>usbd_msc_bot.c</code>, <code>usbd_msc_data.c</code>,
<code>usbd_msc_scsi.c</code></li>
<li>app-specific: <code>usb_device.c</code>, <code>usbd_conf.c</code>, <code>usbd_desc.c</code>, <code>usbd_msc_storage.c</code></li>
</ul>
<p>An example of how the ST drivers are used for MSC class is provided in
<a href="https://github.com/4ms/stm32mp1-baremetal/tree/master/examples/usb_msc_device">this</a>
repository.</p>
<p>For testing, we call the following from the main function:</p>
<pre><code>USBD_Init(&amp;USBD_Device, &amp;MSC_Desc, 0);
USBD_RegisterClass(&amp;USBD_Device, USBD_MSC_CLASS);
USBD_MSC_RegisterStorage(&amp;USBD_Device, &amp;USBD_MSC_fops);
USBD_Start(&amp;USBD_Device);
</code></pre>
<p>The functions complete, and then the main loop is active, blinking LED and
printing to UART. The debug print in <code>HAL_PCD_IRQHandler</code> shows that the IRQ is
called a couple times, but after a few seconds, the Windows Device Manager shows
<code>Unknown USB Device (Device Descriptor Request Failed)</code>.</p>
<p>As it turns out, I have forgotten to add the callbacks into <code>usbd_conf.c</code>. Once
that was done, the USB access from the Windows computer caused an immediate Data
Abort on the STM32MP135.</p>
<h3 id="aligned-sysram-memory-access">Aligned SYSRAM memory access</h3>
<p>The aborts happen in <code>usbd_msc_scsi.c</code> in lines such as the following:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_addr</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_len</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</pre></div>
</code></pre>
<p>As it happens, with some optimizations (I’m using <code>-Os</code> to make the whole
program fit in SYSRAM!) the compiler optimizes the byte access into a misaligned
32-bit access. Forcing a <code>volatile</code> cast fixes the problem, as follows:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_addr</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">5</span><span class="p">]);</span>

<span class="n">hmsc</span><span class="o">-&gt;</span><span class="n">scsi_blk_len</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">7</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w">  </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="k">volatile</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">params</span><span class="p">)[</span><span class="mi">8</span><span class="p">]);</span>
</pre></div>
</code></pre>
<p>Make sure to repeat this several times! Search for <code>scsi_blk_addr</code> in
<code>usbd_msc_scsi.c</code> until you’ve cast all of them correctly.</p>
<p>Then, at last, the USB device enumerates as MSC correctly, and we can even read
and write raw data! However, Windows is not able to format the device.</p>
<h3 id="aligned-ddr-ram-memory-access">Aligned DDR RAM memory access</h3>
<p>Now that data can be read and written to, we observe an odd pattern:</p>
<pre><code>WRITE: eb 3c 90 6d 6b 66 73 2e 66 61
READ:  eb 00 90 3c 6b 6d 73 66 66 2e
</code></pre>
<p>Every other byte is a bit wrong, or reshuffled. Sounds familiar? Yes, it happens
if DDR writes are not aligned to word boundaries, as we experienced before with
the SD card, copying it’s data to DDR. (The debugging process that led to that
insight is explained in a <a href="https://embd.cc/debugging-stm32mp135-kernel-decompression.md">future
article</a>.)</p>
<p>With the write fixed (i.e., done in correctly aligned units of 4 bytes), the
device format works, and we can even copy files to the mass storage device, and
read them back. The problems is now … read and write speeds are about 700
kB/s.</p>
<h3 id="d-pullup">D+ pullup</h3>
<p>As it happens, the USB interface on the custom board has a external, physical
1.5K pullup on the D+ line which signals a Full-Speed device. To switch to
High-Speed mode, the device needs to be able to have the pullup present
initially, but then switch it off. Indeed, Device Manager shows that the device
enumerated as a Full-Speed device, hence the low data rates.</p>
<p>Removing the resistor, the device does not enumerate, or appear at all in the
Device Manager. However, we can simply set</p>
<pre><code>hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_FULL;
</code></pre>
<p>in <code>USBD_LL_Init()</code> function (<code>usbd_conf.c</code>), and then everything works as
before. So something must be wrong with the high-speed mode configuration.</p>
<h3 id="cables-hubs-ports">Cables, hubs, ports</h3>
<p>Since removing the 1.5K pullup which was keeping the device in Full-Speed (FS)
mode, the device does not enumerate, neither in DFU mode (with <code>BOOT</code> pins set
to <code>000</code>), nor using my test firmware (unless I request FS mode directly).</p>
<p>Inserting print statements or debug breakpoints in USB interrupt handler we see
that the USB reset is detected, the device is correctly switched to HS mode
(<code>speed=0</code>), the Rx/Tx FIFOs are large enough, the <code>RXFLVL</code> interrupt is enabled
but it never arrives. The enumeration completes, but the device does not see any
setup or data packets enter the FIFO, and then the device gets suspended,
presumably because it did not reply to the host’s communications. The device
never appears in the Device Manager, or even in <a href="https://www.uwe-sieber.de/usbtreeview_e.html">USB Device Tree
Viewer</a>.</p>
<p>With <code>BOOT=000</code>, pressing reset causes the PA13 LED to blink, and when the USB
cable is attached, the blinking stops. But looking at the device and USB trees,
nothing happens. Even the <code>STM32_Programmer_CLI -l usb</code> does not see anything:</p>
<pre><code>      -------------------------------------------------------------------
                       STM32CubeProgrammer v2.18.0
      -------------------------------------------------------------------

=====  DFU Interface   =====

No STM32 device in DFU mode connecte
</code></pre>
<p>Now a different USB cable was found, connected to a different hub/port. Again
<code>BOOT=000</code>, press reset, PA13 LED blinks, and the new cable is connected, and
the blinking stops. Immediately the Device Manager and the USB Device Tree
Viewer report <code>DFU in FS Mode @Device ID /0x501, @Revision ID /0x1003</code>, so the
device enumerated. (About the “FS”: I think that’s just a cached name, since the
USB Tree also says that “Device Connection Speed  : High-Speed”.) And CubeProg:</p>
<pre><code>      -------------------------------------------------------------------
                       STM32CubeProgrammer v2.18.0
      -------------------------------------------------------------------

=====  DFU Interface   =====

Total number of available STM32 device in DFU mode: 1

  Device Index           : USB1
  USB Bus Number         : 001
  USB Address Number     : 005
  Product ID             : DFU in HS Mode @Device ID /0x501, @Revision ID /0x1003
  Serial number          : 001E00263133511332303636
  Firmware version       : 0x0110
  Device ID              : 0x0501
</code></pre>
<p>Clearly, the bad cable or hub or port was stopping the HS enumeration, at least
in DFU mode. Now let’s switch to <code>BOOT=100</code>, reset, and load our firmware via
JTAG. And … it enumerates immediately! Windows offers to format it as FAT32,
and the file write speed is up to about 4 MB/s, and read about 2 MB/s. Great
success! But could have checked the cable first.</p>
<h3 id="speed">Speed</h3>
<p>Regarding the low-ish data rates: it’s probably limited by a combination of the
slow implementations of the <code>usbd_msc_storage.c</code> backend, and the HAL driver or
other things. For firmware flashing the speed is good enough. More importantly,
it proves that everything is now wired correctly. Nonetheless, let’s see if we
can make it go faster than the 2–4 MB/s.</p>
<p>Changing the compiler optimization level from <code>-Os</code> to <code>-O3</code> brings the write
speed up to 7.6 MB/s. Windows has a built-in disk performance checker which
shows:</p>
<pre><code>C:\Users\Jkastelic&gt; winsat disk -drive e
&gt; Disk  Random 16.0 Read                       2.87 MB/s          4.5
&gt; Disk  Sequential 64.0 Read                   2.91 MB/s          2.2
&gt; Disk  Sequential 64.0 Write                  7.67 MB/s          2.6
&gt; Average Read Time with Sequential Writes     8.566 ms          4.9
&gt; Latency: 95th Percentile                     21.499 ms          4.5
&gt; Latency: Maximum                             22.485 ms          7.9
&gt; Average Read Time with Random Writes         9.149 ms          4.7

winsat disk -write -ran -drive e
&gt; Disk  Random 16.0 Write                      7.46 MB/s
</code></pre>
<p>Next, re-write the <code>STORAGE_Read</code> function to use 32-bit writes instead of
forcing 8-bit accesses (as we did previously while debugging the data
corruption). This improves the reads significantly:</p>
<pre><code>&gt; Disk  Random 16.0 Read                       9.02 MB/s          5.3
&gt; Disk  Sequential 64.0 Read                   9.39 MB/s          2.8
&gt; Disk  Sequential 64.0 Write                  7.71 MB/s          2.6
&gt; Average Read Time with Sequential Writes     3.134 ms          6.6
&gt; Latency: 95th Percentile                     8.109 ms          5.9
&gt; Latency: Maximum                             9.516 ms          8.0
&gt; Average Read Time with Random Writes         3.138 ms          6.5
</code></pre>
<p>Now consider the FIFO allocation. The USB OTG core in the STM32MP135 has 4 kB
of total FIFO. If we used all of it just for sending data back to the host, at
the 480 MBit/s (70 MB/s) data rate, the microcontroller would fire interrupts
or DMA requests every 67 μs. (USB devices designed for mass data transfer
probably have larger buffers.) Currently we have</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">HAL_PCDEx_SetRxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mh">0x200</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x100</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Let us significantly increase the buffer that sends data to the host:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">HAL_PCDEx_SetRxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mh">0x100</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">);</span>
<span class="n">HAL_PCDEx_SetTxFiFo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpcd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x2e0</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Unfortunately, the read/write performance is essentially unchanged:</p>
<pre><code>&gt; Disk  Random 16.0 Read                       9.89 MB/s          5.4
&gt; Disk  Sequential 64.0 Read                   10.28 MB/s          2.9
&gt; Disk  Sequential 64.0 Write                  7.59 MB/s          2.6
&gt; Average Read Time with Sequential Writes     3.311 ms          6.5
&gt; Latency: 95th Percentile                     8.236 ms          5.9
&gt; Latency: Maximum                             9.306 ms          8.1
&gt; Average Read Time with Random Writes         3.279 ms          6.5
</code></pre>
<p>All of that was without DMA. It might be that DMA would make it faster, or at
least unburden the CPU—but in this example, the CPU is not doing anything
except copying the data. (CPU can actually be <em>faster</em> in copying; the point of
DMA is to allow the CPU to do other, more interesting things while the copy is
taking place.)</p>
<h3 id="code-availability">Code availability</h3>
<p>You can find the final version of the USB test in
<a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/usb_test">this</a>
repository.</p>
<p>It compiles to about 117 kB with <code>-Os</code> optimization, so it fits in
SYSRAM directly. If you need more speed, <code>-O3</code> makes it compile to about 136 kB.
That’s still acceptable if we combine all of the on-chip memory into a single
block, as shown in this excerpt from the <a href="https://github.com/js216/stm32mp135_test_board/blob/main/baremetal/usb_test/stm32mp13xx_a7_sysram.ld">linker
script</a>:</p>
<pre><code>MEMORY {
      SYSRAM_BASE (rwx)   : ORIGIN = 0x2FFE0000, LENGTH = 128K
      SRAM1_BASE (rwx)    : ORIGIN = 0x30000000, LENGTH = 16K
      SRAM2_BASE (rwx)    : ORIGIN = 0x30004000, LENGTH = 8K
      SRAM3_BASE (rwx)    : ORIGIN = 0x30006000, LENGTH = 8K
      /* InternalMEM = SYSRAM + SRAM1 + SRAM2 + SRAM3 */
      InternalMEM (rwx)   : ORIGIN = 0x2FFE0000, LENGTH = 160K
      DDR_BASE (rwx)      : ORIGIN = 0xC0000000, LENGTH = 512M
}
</code></pre>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="limitation-is-freedom">Limitation Is Freedom</a></h2>
<div class="article-meta">Published 25 Nov 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/nat.jpg"/></p>
<p>Limitation is the only way to get anything done. The less one aims to do, the
more gets done. By the time the aim becomes to do nothing at all, everything is
accomplished.</p>
<p>On a practical level, trying to do too many things at once results in not having
enough time for any single one of them. Thus the paradox: the less one is trying
to do, the more gets done. At any rate, it’s impossible to do more than one
thing at a time. The closer one approaches to the ideal of unity, the more
efficient the work becomes. Distraction is dissipation; limitation is focus.</p>
<p>This is not a moral statement but a practical one: limitations free your energy
for what matters.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="boot-stm32mp135-over-uart-with-python">Boot STM32MP135 Over UART With Python</a></h2>
<div class="article-meta">Published 19 Nov 2025, modified 21 Nov 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/brid.jpg"/></p>
<p><em>This article is also available as a <a href="https://github.com/js216/mp135_boot/tree/main/uart_boot">Jupyter
notebook.</a></em></p>
<p><a href="stm32mp135-linux-cubeprog.md">Previously</a> we have explored how to flash the
STM32MP135 using the STM32CubeProg over USB and remained puzzled why we need
1.5G of code just to transfer some serial data. Here, we will flash the chip
by talking to the built-in ROM bootloader over UART with a couple lines of
Python, as explained in an ST app note<sup class="footnote-ref"><a href="#21956565-fn1" id="21956565-fnref1">[1]</a></sup>. The article is in three sections:
(1) define the communication functions, (2) use them on the evaluation board,
(3) use them on a custom board.</p>
<h3 id="comm-functions">Comm Functions</h3>
<p>This section documents how the STM32MP1 ROM bootloader communicates over UART,
including the supported commands, packet formats, checksum rules, and Python
helper functions used to implement the protocol. Skip to the <a href="#flash-the-evaluation-board">next
section</a> to see how these functions are used.</p>
<p>The supported commands are listed below:</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">interp_cmd</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get Version"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get ID"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get phase"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x11</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Read Memory"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x12</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Read Partition"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x21</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Start (Go)"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x31</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Download (Write Memory)"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"???"</span>
</pre></div>
</code></pre>
<p>All communications from STM32CubeProgrammer (PC) to the device are verified as
follows:</p>
<ul>
<li>
<p>The UART/USART even parity is checked.</p>
</li>
<li>
<p>For each command the host sends a byte and its complement (XOR = 0x00).</p>
</li>
<li>
<p>The device performs a checksum on the sent/received datablocks. A byte
containing the computed XOR of all previous bytes is appended at the end of
each communication (checksum byte). By XORing all received bytes, data +
checksum, the result at the end of the packet must be 0x00. A timeout must be
managed in any waiting loop to avoid any blocking situation.</p>
</li>
</ul>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pack_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Invalid cmd requested."</span><span class="p">)</span>
    <span class="c1"># command followed by its complement</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BB"</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">-</span><span class="n">cmd</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>Each command packet is either accepted (ACK answer), discarded (NACK answer) or
aborted (unrecoverable error):</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">interp_byte</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x79</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"ACK"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x1F</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"NACK"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x5F</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"ABORT"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">'#04x'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_ack</span><span class="p">(</span><span class="n">note</span><span class="o">=</span><span class="s2">""</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">interp_byte</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}{</span><span class="n">note</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interp_byte</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">"ACK"</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive ACK."</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>Once the serial boot mode is entered (boot pins set to 000), all the UART/USART
instances are scanned by the ROM code, monitoring for each instance the
<code>USARTx_RX</code> line pin, waiting to receive the 0x7F data frame (one start bit,
0x7F data bits, none parity bit and one stop bit).</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">uart_init</span><span class="p">():</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">))</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="n">note</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Get command returns the bootloader version and the supported commands. When
the device receives the Get command, it transmits the version and the supported
command codes to the host. The commands not supported are removed from the list.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
    <span class="c1"># Get command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x00</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">num_bytes</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: Bootloader version</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">version </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">10</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    
    <span class="c1"># Response: device ID</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">cmd = </span><span class="si">{</span><span class="n">interp_cmd</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get version command is used to get the version of the running component.
When the device receives the command, it transmits the version to the host.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_version</span><span class="p">():</span>
    <span class="c1"># Get version command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x01</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
    
    <span class="c1"># Response: Bootloader version</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">version </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">10</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="c1"># Response: Option byte 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Option byte 1"</span><span class="p">)</span>
    
    <span class="c1"># Response: Option byte 2</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Option byte 2"</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get ID command is used to get the version of the device ID (identification).
When the device receives the command, it transmits the device ID to the host.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_id</span><span class="p">():</span>
    <span class="c1"># Get ID command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x02</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: device ID</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x05\x00</span><span class="s1">'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">STM32MP15x"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x05\x01</span><span class="s1">'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">STM32MP13x"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive device ID."</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get phase command enables the host to get the phase ID, in order to identify
the next partition that is going to be downloaded.</p>
<p>The download address, when present, provides the destination address in memory.
A value of 0xFFFFFFFF means than the partition is going to be written in NVM.</p>
<p>Phase ID = 0xFF corresponds to an answered value Reset, in this case the
information bytes provide the cause of the error in a string just before
executing the reset.</p>
<p>The ROM code sends phase = TF-A</p>
<pre><code><div class="codehilite"><pre><span></span>Byte 1: ACK
Byte 2 N = 6
Byte 3: phase ID (file containing FSBL = TF-A, 1)
Byte 4-7: 0x2FFC2400 on STM32MP15x, 0x2FFDFE00 on STM32MP13x
Byte 8: X = 1
Byte 9: 0: reserved
Byte 10: ACK
</pre></div>
</code></pre>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_phase</span><span class="p">():</span>
    <span class="c1"># Get phase command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x03</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: phase ID</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Phase ID"</span><span class="p">)</span>

    <span class="c1"># Response: download address</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\t</span><span class="s2">Download address"</span><span class="p">)</span>

    <span class="c1"># Response: number of additional bytes</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> additional bytes following"</span><span class="p">)</span>
    
    <span class="c1"># Response: reserved</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> Reserved"</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The download command is used to download a binary code (image) into the SRAM
memory or to write a partition in NVM.</p>
<p>Two types of operations are available:</p>
<ul>
<li>
<p>Normal operation: download current partition binary to the device. For
initialization phase the partitions are loaded in SRAM, otherwise for writing
phase the partition are written in NVM.</p>
</li>
<li>
<p>Special operation: download non-signed data to non-executable memory space</p>
</li>
</ul>
<p>A Start command is necessary to finalize these operations after the download
command.</p>
<p>The Packet number is used to specify the type of operation and the number of the
current packet. The table below gives the description of the packet number.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Byte</th>
<th style="text-align:center">Value</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0x00</td>
<td style="text-align:left">Normal operation: write in current phase</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF2</td>
<td style="text-align:left">Special operation: OTP write</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF3</td>
<td style="text-align:left">Special operation: Reserved</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF4</td>
<td style="text-align:left">Special operation PMIC: NVM write</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">Others</td>
<td style="text-align:left">Reserved</td>
</tr>
<tr>
<td style="text-align:center">0-2</td>
<td style="text-align:center">—</td>
<td style="text-align:left">Packet number, increasing from 0 to 0xFFFFFF (*)</td>
</tr>
</tbody>
</table>
<p>Packet number it is not an address as on STM32 MCU with only memory mapped
flash, but the index of the received packet. The offset of the packet N the
offset in the current partition/phase is N* 256 bytes when only full packets are
used.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1"># Data sanity check</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Packet number </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2"> of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">:"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Too much data to send."</span><span class="p">)</span>
        
    <span class="c1"># Send "Download" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x31</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>
    
    <span class="c1"># Packet number</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" packet number"</span><span class="p">)</span>
    
    <span class="c1"># Packet size (0 &lt; N &lt; 255)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># N-1 data bytes</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        
    <span class="c1"># Checksum byte: XOR (byte 8 to Last-1)</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">checksum</span> <span class="o">^=</span> <span class="n">d</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">checksum</span><span class="p">))</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" data"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Read memory command is used to read data from any valid memory address in
the system memory.</p>
<p>When the device receives the read memory command, it transmits the ACK byte to
the application. After the transmission of the ACK byte, the device waits for an
address (4 bytes) and a checksum byte, then it checks the received address. If
the address is valid and the checksum is correct, the device transmits an ACK
byte, otherwise it transmits a NACK byte and aborts the command.</p>
<p>When the address is valid and the checksum is correct, the device waits for N (N
= number of bytes to be received -1) and for its complemented byte (checksum).
If the checksum is correct the device transmits the needed data (N+1 bytes) to
the application, starting from the received address. If the checksum is not
correct, it sends a NACK before aborting the command.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">read_memory</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Note: read memory command not supported by ROM code STM32MP13x."</span><span class="p">)</span>
    
    <span class="c1"># Data sanity check</span>
    <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Too much data to receive."</span><span class="p">)</span>
        
    <span class="c1"># Send "Read memory" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x11</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>

    <span class="c1"># Start address</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" start address"</span><span class="p">)</span>
    
    <span class="c1"># Number of bytes to be received – 1 (N = [0, 255])</span>
    <span class="c1"># (also Checksum byte: XOR)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" number of bytes"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Start command is used:</p>
<ul>
<li>
<p>To execute the code just downloaded in the memory or any other code by
branching to an address specified by the application. When the device receives
the Start command, it transmits the ACK byte to the application. If the address
is valid the device transmits an ACK byte and jumps to this address, otherwise
it transmits a NACK byte and aborts the command.</p>
</li>
<li>
<p>To finalize the last download command, when the host indicates the address =
0xFFFFFFFF.</p>
</li>
</ul>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="c1"># Send "Start" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>

    <span class="c1"># Start address</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i3</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="n">i3</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i3</span> <span class="o">^</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" address"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>To download a complete file:</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">down_file</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="s1">'tf-a-stm32mp135f-dk.stm32'</span><span class="p">):</span>
    <span class="c1"># size of each chunk (must be &lt;= 256 bytes)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="mi">256</span>

    <span class="c1"># open file with the bitstream</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># split file into this many chunks</span>
    <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fb</span><span class="p">)</span> <span class="o">/</span> <span class="n">sz</span><span class="p">))</span>

    <span class="c1"># send each chunk one by one</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">)):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">fb</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">sz</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sz</span><span class="p">]</span>
        <span class="n">download</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span>
        
    <span class="c1"># necessary to finalize download</span>
    <span class="n">start</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">)</span>
</pre></div>
</code></pre>
<h3 id="flash-the-evaluation-board">Flash the Evaluation Board</h3>
<p>We simply run the functions one after the other and verify that the output
printed matches what’s shown here.</p>
<p>As an example, we will use the Blink program that we develop, compile, and
package in <a href="https://github.com/js216/mp135_boot/tree/main/blink_noide">this repo.</a></p>
<pre><code><div class="codehilite"><pre><span></span>&gt;&gt;&gt; uart_init()
0x79		ACK

&gt;&gt;&gt; get()
0x79		ACK
0x06		6 + 1 bytes to follow
0x40		version 1.0
0x06		cmd = Get
0x06		cmd = Get Version
0x06		cmd = Get ID
0x06		cmd = Get phase
0x06		cmd = Start (Go)
0x06		cmd = Download (Write Memory)
0x79		ACK

&gt;&gt;&gt; get_version()
0x79		ACK
0x10		version 1.0
0x00		Option byte 1
0x00		Option byte 2
0x79		ACK

&gt;&gt;&gt; get_id()
0x79		ACK
0x01		1 + 1 bytes to follow
0x05 0x01 	STM32MP13x
0x79		ACK

&gt;&gt;&gt; get_phase()
0x79		ACK
0x06		6 + 1 bytes to follow
0x01		Phase ID
0x2ffdfe00	Download address
0x01		1 additional bytes following
0x00		0 Reserved
0x79		ACK

&gt;&gt;&gt; down_file(fname='blink.stm32')
Packet number 0 of length 256:
0x79		ACK command
0x79		ACK packet number
0x79		ACK data
...
(skip over lots of packets)
...
Packet number 264 of length 156:
0x79		ACK command
0x79		ACK packet number
0x79		ACK data
0x79		ACK command
0x79		ACK address
</pre></div>
</code></pre>
<p>After a little bit, the red LED on the evaluation board will blink. Success!</p>
<h3 id="flash-a-custom-board">Flash a Custom Board</h3>
<p>Amazingly, the exact same procedure works on any custom board, so long as it
breaks out the UART4 pin and applies 3.3V and 1.35V power supplies in the
correct sequence. Find the schematics and layout files for my board in
<a href="https://github.com/js216/stm32mp135_test_board">this repository.</a></p>
<p>Since the custom board does not use STPMIC1, the code for the blink example is
even simpler. Find it <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/blink">here.</a></p>
<p>The UART wires (green/yellow) and the two power supplies is all that needs to be
connected, and then the red LED (middle of the PCB) will blink. Yes, the setup
is that simple!</p>
<p><img alt="" src="../images/first_blink.jpg"/></p>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="21956565-fn1"><p>ST application note AN5275, “USB DFU/USART protocols used in STM32MP1
Series bootloaders”. <a class="footnote-backref" href="#21956565-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page4.html">← Older articles</a></div>
        <div><a class="newer" href="page2.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
