<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="boot-stm32mp135-over-uart-with-python">Boot STM32MP135 Over UART With Python</a></h2>
<div class="article-meta">Published 19 Nov 2025, modified 21 Nov 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/brid.jpg"/></p>
<p><em>This article is also available as a <a href="https://github.com/js216/mp135_boot/tree/main/uart_boot">Jupyter
notebook.</a></em></p>
<p><a href="stm32mp135-linux-cubeprog.md">Previously</a> we have explored how to flash the
STM32MP135 using the STM32CubeProg over USB and remained puzzled why we need
1.5G of code just to transfer some serial data. Here, we will flash the chip
by talking to the built-in ROM bootloader over UART with a couple lines of
Python, as explained in an ST app note<sup class="footnote-ref"><a href="#21956565-fn1" id="21956565-fnref1">[1]</a></sup>. The article is in three sections:
(1) define the communication functions, (2) use them on the evaluation board,
(3) use them on a custom board.</p>
<h3 id="comm-functions">Comm Functions</h3>
<p>This section documents how the STM32MP1 ROM bootloader communicates over UART,
including the supported commands, packet formats, checksum rules, and Python
helper functions used to implement the protocol. Skip to the <a href="#flash-the-evaluation-board">next
section</a> to see how these functions are used.</p>
<p>The supported commands are listed below:</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">interp_cmd</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get Version"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x02</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get ID"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x03</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Get phase"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x11</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Read Memory"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x12</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Read Partition"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x21</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Start (Go)"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x31</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"Download (Write Memory)"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"???"</span>
</pre></div>
</code></pre>
<p>All communications from STM32CubeProgrammer (PC) to the device are verified as
follows:</p>
<ul>
<li>
<p>The UART/USART even parity is checked.</p>
</li>
<li>
<p>For each command the host sends a byte and its complement (XOR = 0x00).</p>
</li>
<li>
<p>The device performs a checksum on the sent/received datablocks. A byte
containing the computed XOR of all previous bytes is appended at the end of
each communication (checksum byte). By XORing all received bytes, data +
checksum, the result at the end of the packet must be 0x00. A timeout must be
managed in any waiting loop to avoid any blocking situation.</p>
</li>
</ul>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pack_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cmd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Invalid cmd requested."</span><span class="p">)</span>
    <span class="c1"># command followed by its complement</span>
    <span class="k">return</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BB"</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mh">0xff</span><span class="o">-</span><span class="n">cmd</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>Each command packet is either accepted (ACK answer), discarded (NACK answer) or
aborted (unrecoverable error):</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">interp_byte</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x79</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"ACK"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x1F</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"NACK"</span>
    <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mh">0x5F</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">"ABORT"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">'#04x'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_ack</span><span class="p">(</span><span class="n">note</span><span class="o">=</span><span class="s2">""</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">interp_byte</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}{</span><span class="n">note</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interp_byte</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">"ACK"</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive ACK."</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>Once the serial boot mode is entered (boot pins set to 000), all the UART/USART
instances are scanned by the ROM code, monitoring for each instance the
<code>USARTx_RX</code> line pin, waiting to receive the 0x7F data frame (one start bit,
0x7F data bits, none parity bit and one stop bit).</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">uart_init</span><span class="p">():</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">))</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="n">note</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Get command returns the bootloader version and the supported commands. When
the device receives the Get command, it transmits the version and the supported
command codes to the host. The commands not supported are removed from the list.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get</span><span class="p">():</span>
    <span class="c1"># Get command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x00</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">num_bytes</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: Bootloader version</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">version </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">10</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    
    <span class="c1"># Response: device ID</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">cmd = </span><span class="si">{</span><span class="n">interp_cmd</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get version command is used to get the version of the running component.
When the device receives the command, it transmits the version to the host.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_version</span><span class="p">():</span>
    <span class="c1"># Get version command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x01</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
    
    <span class="c1"># Response: Bootloader version</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">version </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)[</span><span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">10</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="c1"># Response: Option byte 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Option byte 1"</span><span class="p">)</span>
    
    <span class="c1"># Response: Option byte 2</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Option byte 2"</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get ID command is used to get the version of the device ID (identification).
When the device receives the command, it transmits the device ID to the host.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_id</span><span class="p">():</span>
    <span class="c1"># Get ID command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x02</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: device ID</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x05\x00</span><span class="s1">'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">STM32MP15x"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x05\x01</span><span class="s1">'</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">STM32MP13x"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive device ID."</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The Get phase command enables the host to get the phase ID, in order to identify
the next partition that is going to be downloaded.</p>
<p>The download address, when present, provides the destination address in memory.
A value of 0xFFFFFFFF means than the partition is going to be written in NVM.</p>
<p>Phase ID = 0xFF corresponds to an answered value Reset, in this case the
information bytes provide the cause of the error in a string just before
executing the reset.</p>
<p>The ROM code sends phase = TF-A</p>
<pre><code><div class="codehilite"><pre><span></span>Byte 1: ACK
Byte 2 N = 6
Byte 3: phase ID (file containing FSBL = TF-A, 1)
Byte 4-7: 0x2FFC2400 on STM32MP15x, 0x2FFDFE00 on STM32MP13x
Byte 8: X = 1
Byte 9: 0: reserved
Byte 10: ACK
</pre></div>
</code></pre>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_phase</span><span class="p">():</span>
    <span class="c1"># Get phase command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x03</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>

    <span class="c1"># Response: number of following bytes – 1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> + 1 bytes to follow"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Did not receive number of bytes to follow."</span><span class="p">)</span>

    <span class="c1"># Response: phase ID</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="s2">Phase ID"</span><span class="p">)</span>

    <span class="c1"># Response: download address</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s1">'#04x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">'02x'</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\t</span><span class="s2">Download address"</span><span class="p">)</span>

    <span class="c1"># Response: number of additional bytes</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> additional bytes following"</span><span class="p">)</span>
    
    <span class="c1"># Response: reserved</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">mp1</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">format</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="s1">'#04x'</span><span class="p">)</span><span class="si">}</span><span class="se">\t\t</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s2"> Reserved"</span><span class="p">)</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">()</span>
</pre></div>
</code></pre>
<p>The download command is used to download a binary code (image) into the SRAM
memory or to write a partition in NVM.</p>
<p>Two types of operations are available:</p>
<ul>
<li>
<p>Normal operation: download current partition binary to the device. For
initialization phase the partitions are loaded in SRAM, otherwise for writing
phase the partition are written in NVM.</p>
</li>
<li>
<p>Special operation: download non-signed data to non-executable memory space</p>
</li>
</ul>
<p>A Start command is necessary to finalize these operations after the download
command.</p>
<p>The Packet number is used to specify the type of operation and the number of the
current packet. The table below gives the description of the packet number.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Byte</th>
<th style="text-align:center">Value</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0x00</td>
<td style="text-align:left">Normal operation: write in current phase</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF2</td>
<td style="text-align:left">Special operation: OTP write</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF3</td>
<td style="text-align:left">Special operation: Reserved</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">0xF4</td>
<td style="text-align:left">Special operation PMIC: NVM write</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">Others</td>
<td style="text-align:left">Reserved</td>
</tr>
<tr>
<td style="text-align:center">0-2</td>
<td style="text-align:center">—</td>
<td style="text-align:left">Packet number, increasing from 0 to 0xFFFFFF (*)</td>
</tr>
</tbody>
</table>
<p>Packet number it is not an address as on STM32 MCU with only memory mapped
flash, but the index of the received packet. The offset of the packet N the
offset in the current partition/phase is N* 256 bytes when only full packets are
used.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">download</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1"># Data sanity check</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Packet number </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2"> of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">:"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Too much data to send."</span><span class="p">)</span>
        
    <span class="c1"># Send "Download" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x31</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>
    
    <span class="c1"># Packet number</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" packet number"</span><span class="p">)</span>
    
    <span class="c1"># Packet size (0 &lt; N &lt; 255)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># N-1 data bytes</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        
    <span class="c1"># Checksum byte: XOR (byte 8 to Last-1)</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">checksum</span> <span class="o">^=</span> <span class="n">d</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">checksum</span><span class="p">))</span>

    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" data"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Read memory command is used to read data from any valid memory address in
the system memory.</p>
<p>When the device receives the read memory command, it transmits the ACK byte to
the application. After the transmission of the ACK byte, the device waits for an
address (4 bytes) and a checksum byte, then it checks the received address. If
the address is valid and the checksum is correct, the device transmits an ACK
byte, otherwise it transmits a NACK byte and aborts the command.</p>
<p>When the address is valid and the checksum is correct, the device waits for N (N
= number of bytes to be received -1) and for its complemented byte (checksum).
If the checksum is correct the device transmits the needed data (N+1 bytes) to
the application, starting from the received address. If the checksum is not
correct, it sends a NACK before aborting the command.</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">read_memory</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Note: read memory command not supported by ROM code STM32MP13x."</span><span class="p">)</span>
    
    <span class="c1"># Data sanity check</span>
    <span class="k">if</span> <span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">"Too much data to receive."</span><span class="p">)</span>
        
    <span class="c1"># Send "Read memory" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x11</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>

    <span class="c1"># Start address</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" start address"</span><span class="p">)</span>
    
    <span class="c1"># Number of bytes to be received – 1 (N = [0, 255])</span>
    <span class="c1"># (also Checksum byte: XOR)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" number of bytes"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The Start command is used:</p>
<ul>
<li>
<p>To execute the code just downloaded in the memory or any other code by
branching to an address specified by the application. When the device receives
the Start command, it transmits the ACK byte to the application. If the address
is valid the device transmits an ACK byte and jumps to this address, otherwise
it transmits a NACK byte and aborts the command.</p>
</li>
<li>
<p>To finalize the last download command, when the host indicates the address =
0xFFFFFFFF.</p>
</li>
</ul>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="c1"># Send "Start" command</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">pack_cmd</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" command"</span><span class="p">)</span>

    <span class="c1"># Start address</span>
    <span class="n">i0</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">i3</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"BBBB"</span><span class="p">,</span> <span class="n">i3</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i0</span><span class="p">))</span>

    <span class="c1"># Checksum byte: XOR (byte 3 to byte 6)</span>
    <span class="n">mp1</span><span class="o">.</span><span class="n">write_raw</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">"B"</span><span class="p">,</span> <span class="n">i3</span> <span class="o">^</span> <span class="n">i2</span> <span class="o">^</span> <span class="n">i1</span> <span class="o">^</span> <span class="n">i0</span><span class="p">))</span>
    
    <span class="c1"># Response: ACK</span>
    <span class="n">get_ack</span><span class="p">(</span><span class="s2">" address"</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>To download a complete file:</p>
<pre><code class="language-Python"><div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">down_file</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="s1">'tf-a-stm32mp135f-dk.stm32'</span><span class="p">):</span>
    <span class="c1"># size of each chunk (must be &lt;= 256 bytes)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="mi">256</span>

    <span class="c1"># open file with the bitstream</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">fb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="c1"># split file into this many chunks</span>
    <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fb</span><span class="p">)</span> <span class="o">/</span> <span class="n">sz</span><span class="p">))</span>

    <span class="c1"># send each chunk one by one</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">)):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">fb</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">sz</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sz</span><span class="p">]</span>
        <span class="n">download</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">chunk</span><span class="p">)</span>
        
    <span class="c1"># necessary to finalize download</span>
    <span class="n">start</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">)</span>
</pre></div>
</code></pre>
<h3 id="flash-the-evaluation-board">Flash the Evaluation Board</h3>
<p>We simply run the functions one after the other and verify that the output
printed matches what’s shown here.</p>
<p>As an example, we will use the Blink program that we develop, compile, and
package in <a href="https://github.com/js216/mp135_boot/tree/main/blink_noide">this repo.</a></p>
<pre><code><div class="codehilite"><pre><span></span>&gt;&gt;&gt; uart_init()
0x79		ACK

&gt;&gt;&gt; get()
0x79		ACK
0x06		6 + 1 bytes to follow
0x40		version 1.0
0x06		cmd = Get
0x06		cmd = Get Version
0x06		cmd = Get ID
0x06		cmd = Get phase
0x06		cmd = Start (Go)
0x06		cmd = Download (Write Memory)
0x79		ACK

&gt;&gt;&gt; get_version()
0x79		ACK
0x10		version 1.0
0x00		Option byte 1
0x00		Option byte 2
0x79		ACK

&gt;&gt;&gt; get_id()
0x79		ACK
0x01		1 + 1 bytes to follow
0x05 0x01 	STM32MP13x
0x79		ACK

&gt;&gt;&gt; get_phase()
0x79		ACK
0x06		6 + 1 bytes to follow
0x01		Phase ID
0x2ffdfe00	Download address
0x01		1 additional bytes following
0x00		0 Reserved
0x79		ACK

&gt;&gt;&gt; down_file(fname='blink.stm32')
Packet number 0 of length 256:
0x79		ACK command
0x79		ACK packet number
0x79		ACK data
...
(skip over lots of packets)
...
Packet number 264 of length 156:
0x79		ACK command
0x79		ACK packet number
0x79		ACK data
0x79		ACK command
0x79		ACK address
</pre></div>
</code></pre>
<p>After a little bit, the red LED on the evaluation board will blink. Success!</p>
<h3 id="flash-a-custom-board">Flash a Custom Board</h3>
<p>Amazingly, the exact same procedure works on any custom board, so long as it
breaks out the UART4 pin and applies 3.3V and 1.35V power supplies in the
correct sequence. Find the schematics and layout files for my board in
<a href="https://github.com/js216/stm32mp135_test_board">this repository.</a></p>
<p>Since the custom board does not use STPMIC1, the code for the blink example is
even simpler. Find it <a href="https://github.com/js216/stm32mp135_test_board/tree/main/baremetal/blink">here.</a></p>
<p>The UART wires (green/yellow) and the two power supplies is all that needs to be
connected, and then the red LED (middle of the PCB) will blink. Yes, the setup
is that simple!</p>
<p><img alt="" src="../images/first_blink.jpg"/></p>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="21956565-fn1"><p>ST application note AN5275, “USB DFU/USART protocols used in STM32MP1
Series bootloaders”. <a class="footnote-backref" href="#21956565-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="always-mutate-the-entire-global-state">Always Mutate the Entire Global State</a></h2>
<div class="article-meta">Published 17 Oct 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/mask.jpg"/></p>
<p>For the past month I had been stuck hunting down subtle bugs that happen when a
particular sequence of commands is entered into a program. Sometimes even
repeating the exact sequence would not be enough to reproduce the bug, since the
program’s behavior depends on all commands that have been entered before as well
as some saved state. Such chaos is to be expected when the user commands that a
program exposes each modify one or more global state variables.</p>
<p>The wizards of functional programming counsel us to use pure functions only,
i.e., those whose output depends only on their inputs and that don’t change
anything else in the system. That style of coding would have fixed my bugs, but
is strictly speaking impossible. If no function modifies any global state, then
how can it return values? The return values get passed back via the call stack,
which is of course part of the global state and influences the execution of
functions that follow. Even ignoring that, ultimately the program needs to
output the values to the user or manipulate the hardware in some way, which is
also part of the global state.</p>
<p>The real solution indicated in this case is of the type “if you can’t beat them,
you join them”. If you cannot have perfectly pure functions, then you should
have functions that are <em>perfectly impure</em>. In other words, functions that
mutate the global state to the largest extent possible.</p>
<p>In the example from the first paragraphs, my program exposed a range of user
commands: some change system parameters, and others work on one of several
similar output channels of an instrument. The intuitive but buggy approach is
for each command to change only the things it needs to change. The “perfectly
impure” approach is to recompute the entire global state no matter how small the
change that the command actually needs to make.</p>
<p>This results in a tremendous simplification of the possible parameter space. For
every set of user-visible parameter values, there is only one possible state the
system or program can be in. Contrast that to the intuitive/buggy approach where
there is an almost infinite number of system states corresponding to a given set
of parameters!</p>
<p>But isn’t this awfully inefficient? If an instrument has ten outputs, and each
output has 25 parameters, then to change one parameter would take 250 times
longer than it needs to! Not really. If all user commands eventually call the
same function to effect a parameter change, that <em>one</em> function can do the
optimization to not modify things that haven’t changed. In other words, instead
of having to perform the optimization manually in each user-facing command, the
optimization is done at the last possible moment in a single function
automatically. For a reasonably complex program, it’s nearly impossible to
manually keep track of this kind of “cache consistency”, but pretty easy to do
automatically as described here.</p>
<p>The actual result regarding the mysterious bugs I spent a month chasing? They
were all gone, replaced by relatively shallow issues that were easy to reproduce
and quick to fix. Besides, once I implemented the “inefficient” approach of
updating the whole state on each command, the system became faster and more
responsive, since the automatic optimization did a much better job than my
bug-prone manual ones.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="from-fixing-to-creating">From Fixing to Creating</a></h2>
<div class="article-meta">Published 9 Oct 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/air.jpg"/></p>
<p>If all your activities are about fixing problems, filling needs, and resolving
pain, then your life requires problems, needs, pain, and conflict. If instead
you pursue things meaningful in themselves, with an intrinsic joy, then the good
life is more easily achieved.</p>
<p>Move from a reactive mindset (“What needs fixing?”) to a generative one (“What
do I love creating?”).</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="failure-is-not-personal">Failure Is Not Personal</a></h2>
<div class="article-meta">Published 3 Oct 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/tube.jpg"/></p>
<p>In a probabilistic world, it is unreasonable to expect any one thing to succeed.
At most, you can hope that of the several that were attempted, at least one will
turn out as expected. That’s the genetic algorithm: try a countless number of
things, and remember which ones work and which ones don’t.</p>
<p>There’s nothing personal about things that fail—or, for that matter, those
that succeed. It is just the unfolding of a complex system, so better not be
attached to any one outcome.</p>
<p>Success and failure are signals, not verdicts on your worth.</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-without-optee">STM32MP135 Without OP-TEE</a></h2>
<div class="article-meta">Published 26 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1120.jpg"/></p>
<p><em>This is Part 5 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>Arm chips, such as the STM32MP135, implementing the TrustZone extension divide
the execution into two worlds: a normal, non-secure world inhabited by the
application operating system, and a secure world serviced by a secure OS such as
OP-TEE. The ST wiki<sup class="footnote-ref"><a href="#836d8114-fn1" id="836d8114-fnref1">[1]</a></sup> assures us that OP-TEE is required on all STM32MP1
produces “due to the hardware architecture”. It is our purpose in this article
to show that that is not the case: <em>OP-TEE is in fact entirely optional</em>.</p>
<p>The only mechanism to enter the “secure world” is via the <code>SMC</code> instruction
(secure monitor call). This is analogous to how user-space applications invoke
kernel system calls via the <code>SVC</code> (supervisor call) instruction to enter
privileged mode. So long as the kernel does not issue the <code>SMC</code> instruction, the
secure world need never be entered. Thus, we can restate our purpose as removing
all secure monitor calls from the kernel configuration.</p>
<p>The present article is somewhat more involved than the preceding ones in the
series. For this reason I offer the <a href="#quick-start">“Quick Start”</a> version, where
the required modifications to kernel drivers are offered as patches to apply to
a particular version. For those interested, the <a href="#theory">“Theory”</a> section fill
in the details. As in other articles, we conclude with a brief discussion.</p>
<h3 id="quick-start">Quick Start</h3>
<p>Start by cloning Buildroot as above. However, this time we check out a different
sequence of patches and board files:</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone https://gitlab.com/buildroot.org/buildroot.git
$ git clone git@github.com:js216/stm32mp135_simple.git

$ cd buildroot
$ git checkout 3645e3b781be5cedbb0e667caa70455444ce4552

$ git apply ../stm32mp135_simple/patches/add_falcon.patch
$ cp ../stm32mp135_simple/configs/stm32mp135f_dk_nonsecure_defconfig configs
$ cp -r ../stm32mp135_simple/board/stm32mp135f-dk-nonsecure board/stmicroelectronics
</pre></div>
</code></pre>
<p>Now build:</p>
<pre><code><div class="codehilite"><pre><span></span>$ make stm32mp135f_dk_nonsecure_defconfig
$ make
</pre></div>
</code></pre>
<p>Write the generated image to the SD card (either directly with a tool such as
<code>dd</code>, or using the STM32CubeProg as explained
<a href="stm32mp135-linux-cubeprog">here</a>). Watch it boot up without U-Boot, and without
OP-TEE.</p>
<h3 id="theory">Theory</h3>
<p>To understand the modifications we are about to do in the next section, we need
to take a closer look at the boot process from TF-A to OP-TEE to Linux. In
particular, we need to explain how secure monitor calls (SMC) calls work; the
use of secure interrupts (<code>FIQ</code>) in OP-TEE; and explain how SCMI clocks work</p>
<h4>Boot process from TF-A to OP-TEE to Linux</h4>
<p>When Arm Trusted Firmware (TF-A) is done with its own initialization, it loads
several images into memory. In the STM32MP1 case, these are defined in the
array <code>bl2_mem_params_desc</code> in file
<code>plat/st/stm32mp1/plat_bl2_mem_params_desc.c</code>, and include the following:</p>
<ul>
<li>
<p><code>FW_CONFIG_ID</code>: firmware config, which is mostly just the information on
TrustZone memory regions that is used by TF-A itself</p>
</li>
<li>
<p><code>BL32_IMAGE_ID</code>: the OP-TEE executable</p>
</li>
<li>
<p><code>BL32_EXTRA1_IMAGE_ID</code>, <code>BL32_EXTRA2_IMAGE_ID</code>, and <code>TOS_FW_CONFIG_ID</code>: some
stuff needed by OP-TEE</p>
</li>
<li>
<p><code>BL33_IMAGE_ID</code>: the non-trusted bootloader (U-Boot) or directly Linux itself,
if operating in the “falcon mode”</p>
</li>
<li>
<p><code>HW_CONFIG_ID</code>: the Device Tree Blob (DTB) used by U-Boot or Linux, whichever
is run as “BL33”</p>
</li>
</ul>
<p>Just before passing control to OP-TEE, the TF-A prints a couple messages in the
<code>bl2_main()</code> function (<code>bl2/bl2_main.c</code>), and then runs <code>bl2_run_next_image</code>
(<code>bl2/aarch32/bl2_run_next_image.S</code>). There, we disable MMU, put the OP-TEE
entry address into the link register (either <code>lr</code> or <code>lr_svc</code>), load the <code>SPSR</code>
register, and then do an “exception return” to atomically change the program
counter to the link register value, and restore the Current Program Status
Register (<code>CPSR</code>) from the Saved Program Status Register (<code>SPSR</code>).</p>
<h4>How do secure monitor calls (SMC) work?</h4>
<p>The ARMv7-A architecture provides optional TrustZone extension, which are
implemented on the STM32MP135 chips (as well as the virtualisation
extension). In this scheme, the processor is at all times executing in one of
two “worlds”, either the secure or the non-secure one.</p>
<p>The <code>NS</code> bit of the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/SCR--Secure-Configuration-Register--Security-Extensions?lang=en"><code>SCR</code></a>
register defines which world we’re currently in. If <code>NS=1</code>, we are in non-secure
world, otherwise we’re in the secure world. The one exception to this is that
when the processor is running in
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/The-System-Level-Programmers--Model/ARM-processor-modes-and-ARM-core-registers/ARM-processor-modes?lang=en#CIHGHDGI">Monitor mode</a>;
in that case, the code is executing the secure world and <code>SCR.NS</code> merely
indicates which world the processor was in before entering the Monitor mode.
(The current processor mode is given by the <code>M</code> bits of the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/The-System-Level-Programmers--Model/ARM-processor-modes-and-ARM-core-registers/Program-Status-Registers--PSRs-?lang=en#CIHBFGJG"><code>CPSR</code></a>
register.)</p>
<p>The processor starts execution in the secure world. How do we transition to the
non-secure world? Outside of Monitor mode, Arm does not recommend direct
manipulation of the <code>SCR.NS</code> bit to change from the secure world to the
non-secure world or vice versa. Instead, the right way is to first change into
Monitor mode, flip the <code>SCR.NS</code> bit, and leave monitor mode. To enter Monitor
mode, execute the <code>SMC</code> instruction. This triggers the SMC exception, and the
processor begins executing the SMC handler.</p>
<p>The location of the SMC handler has to be previously stored in the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/MVBAR--Monitor-Vector-Base-Address-Register--Security-Extensions"><code>MVBAR</code> register</a>.
The initial setup required is as follows:</p>
<ol>
<li>
<p>Write a SMC handler. As an example, consult OP-TEE source code, which
provides the handler <code>sm_smc_entry</code>, defined in <code>core/arch/arm/sm/sm_a32.S</code>.</p>
</li>
<li>
<p>Create a vector table for monitor mode. As specified in the
<a href="https://developer.arm.com/documentation/ddi0406/b/System-Level-Architecture/The-System-Level-Programmers--Model/Exceptions/Exception-vectors-and-the-exception-base-address?lang=en">Arm architecture</a>
manual, the monitor vector table has eight entries:</p>
<ol>
<li>Unused</li>
<li>Unused</li>
<li>Secure Monitor Call (SMC) handler</li>
<li>Prefetch Abort handler</li>
<li>Data Abort handler</li>
<li>Unused</li>
<li><code>IRQ</code> interrupt handler</li>
<li><code>FIQ</code> interrupt handler</li>
</ol>
<p>Obviously entry number 3 has to point to the SMC handler defined previously.
For example, OP-TEE defines the following vector table in
<code>core/arch/arm/sm/sm_a32.S</code>:</p>
<pre><code>LOCAL_FUNC sm_vect_table , :, align=32
UNWIND(	.cantunwind)
	b	.		/* Reset			*/
	b	.		/* Undefined instruction	*/
	b	sm_smc_entry	/* Secure monitor call		*/
	b	.		/* Prefetch abort		*/
	b	.		/* Data abort			*/
	b	.		/* Reserved			*/
	b	.		/* IRQ				*/
	b	sm_fiq_entry	/* FIQ				*/
END_FUNC sm_vect_table
</code></pre>
<p>We see only the SMC and <code>FIQ</code> handlers are installed, since OP-TEE setup
disables all other Monitor-mode interrupts and exceptions.</p>
</li>
<li>
<p>Install the vector table to the <code>MVBAR</code> register. The OP-TEE source code
defines the following macros in <code>out/core/include/generated/arm32_sysreg.h</code>:</p>
<pre><code>/* Monitor Vector Base Address Register */
static inline __noprof uint32_t read_mvbar(void)
{
	uint32_t v;

	asm volatile ("mrc p15, 0, %0, c12, c0, 1" : "=r"  (v));

	return v;
}

/* Monitor Vector Base Address Register */
static inline __noprof void write_mvbar(uint32_t v)
{
	asm volatile ("mcr p15, 0, %0, c12, c0, 1" : : "r"  (v));
}
</code></pre>
<p>This merely follows the Arm manual on how to access the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/MVBAR--Monitor-Vector-Base-Address-Register--Security-Extensions"><code>MVBAR</code> register</a>.</p>
</li>
</ol>
<p>With this setup in place, to transition from the secure world to the non-secure
world, the steps are as follows:</p>
<ol>
<li>
<p>Place the arguments to the SMC handler into registers <code>r0</code> through <code>r4</code> (or
as many as are needed by the handler), and execute the SMC instruction. For
example, just before passing control to the non-secure world, OP-TEE
<code>reset_primary</code> function (called from the <code>_start</code> function) does the
following:</p>
<pre><code>mov	r4, #0
mov	r3, r6
mov	r2, r7
mov	r1, #0
mov	r0, #TEESMC_OPTEED_RETURN_ENTRY_DONE
smc	#0
</code></pre>
</li>
<li>
<p>This puts the processor into Monitor mode, and it begins execution at the
previously-installed SMC handler. The handler stores secure-mode registers
into some memory location for future use, then sets the <code>SCR.NS</code> bit:</p>
<pre><code>read_scr r0
orr	r0, r0, #(SCR_NS | SCR_FIQ) /* Set NS and FIQ bit in SCR */
write_scr r0
</code></pre>
<p>This also sets the <code>SCR.FIQ</code> bit, which means that <code>FIQ</code> interrupts are also
taken to Monitor mode. In this way, OP-TEE assigns <code>IRQ</code> interrupts to the
non-secure world, and <code>FIQ</code> interrupts to the secure-world. Of course, this
means that the Monitor-mode vector table needs a <code>FIQ</code> handler (as mentioned
in passing above), and the system interrupt handler (GIC on STM32MP135) needs
to be configured to pass “secure” interrupts as <code>FIQ</code>.</p>
</li>
<li>
<p>After adjusting the stack pointer and restoring the non-secure register
values from the stack, the SMC handler returns:</p>
<pre><code>add	sp, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R0)
pop	{r0-r7}
rfefd	sp!
</code></pre>
<p>The return location and processor mode is stored on the stack and
automatically retrieved by the <code>rfefd sp!</code> instruction. Of course this means
they have to be previously stored in the right place on the stack; see
<code>sm_smc_entry</code> source code for details.</p>
</li>
</ol>
<h4>Secure interrupts in OP-TEE</h4>
<p>As mentioned above, OP-TEE code, before returning to non-secure mode, enables
the <code>SCR.FIQ</code> bit, which means that <code>FIQ</code> interrupts get taken to Monitor mode,
serviced by the <code>FIQ</code> handler that is installed in the Monitor-mode vector table
(the table address is stored in the <code>MVBAR</code> register).</p>
<p>As mentioned above, an arbitrary number of system interrupts may be passed as a
<code>FIQ</code> to the processor core. OP-TEE handles these interrupts in <code>itr_handle()</code>
(defined in <code>core/kernel/interrupt.c</code>). The individual interrupt handlers are
stored in a linked list, which <code>itr_handle()</code> traverses until it finds a handler
whose interrupt number (<code>h-&gt;it</code>) matches the given interrupt.</p>
<p>For example, the handler for the <code>TZC</code> interrupt (TrustZone memory protection)
is defined in <code>core/arch/arm/plat-stm32mp1/plat_tzc400.c</code>, as the
<code>tzc_it_handler()</code> function.</p>
<h4>How do SCMI clocks work?</h4>
<p>In general, to configure clocks, Linux uses the
<a href="https://www.kernel.org/doc/Documentation/clk.txt">Common Clock Framework</a>. Each
clock needs to define some common operations, such as <code>enable()</code>, <code>disable()</code>,
<code>set_rate()</code>, and so on, as relevant to each particular clock.</p>
<p>Since in the ST-recommended scheme the clock configuration is done entirely in
the secure world, the STM32MP135 clock drivers
(<code>drivers/clk/stm32/clk-strm32mp13.c</code>) make use of the SCMI clock driver
(<code>drivers/clk/clk/scmi.c</code>). The latter provides a translation from the common
clock functions to SCMI functions. For example, <code>enable()</code> is implemented as
follows:</p>
<pre><code>static int scmi_clk_enable(struct clk_hw *hw)
{
	struct scmi_clk *clk = to_scmi_clk(hw);
	return scmi_proto_clk_ops-&gt;enable(clk-&gt;ph, clk-&gt;id);
}
</code></pre>
<p>This is just a wrapper around the SCMI clock enable function, as found in the
<code>scmi_proto_clk_ops</code> structure (which contains all the SCMI-protocol clock
operations).</p>
<p>At Linux boot, when the SCMI clock driver is being “probed”, it asks OP-TEE
about the number of supported clocks, and then retrieves information about each
one in sequence. Thus it acquires a list of clocks, with a header file defining
the sequential ID numbers (<code>include/dt-bindings/clock/stm32mp13-clks.h</code>):</p>
<pre><code>/* SCMI clock identifiers */
#define CK_SCMI_HSE		0
#define CK_SCMI_HSI		1
#define CK_SCMI_CSI		2
#define CK_SCMI_LSE		3
#define CK_SCMI_LSI		4
#define CK_SCMI_HSE_DIV2	5
#define CK_SCMI_PLL2_Q		6
#define CK_SCMI_PLL2_R		7
#define CK_SCMI_PLL3_P		8
#define CK_SCMI_PLL3_Q		9
#define CK_SCMI_PLL3_R		10
#define CK_SCMI_PLL4_P		11
#define CK_SCMI_PLL4_Q		12
#define CK_SCMI_PLL4_R		13
#define CK_SCMI_MPU		14
#define CK_SCMI_AXI		15
#define CK_SCMI_MLAHB		16
#define CK_SCMI_CKPER		17
#define CK_SCMI_PCLK1		18
#define CK_SCMI_PCLK2		19
#define CK_SCMI_PCLK3		20
#define CK_SCMI_PCLK4		21
#define CK_SCMI_PCLK5		22
#define CK_SCMI_PCLK6		23
#define CK_SCMI_CKTIMG1		24
#define CK_SCMI_CKTIMG2		25
#define CK_SCMI_CKTIMG3		26
#define CK_SCMI_RTC		27
#define CK_SCMI_RTCAPB		28
</code></pre>
<p>(There must be some way to ensure that the same sequential number is used in
Linux as in OP-TEE, or else the clocks would get confused. Presumably the same
header file is used in Linux as in OP-TEE.)</p>
<p>The SCMI clock numbers are then used in device trees. For example, in
<code>core/arch/arm/dts/stm32mp131.dtsi</code>, we see some of these constants being used:</p>
<pre><code>rcc: rcc@50000000 {
	compatible = "st,stm32mp13-rcc", "syscon";
	reg = &lt;0x50000000 0x1000&gt;;
	#clock-cells = &lt;1&gt;;
	#reset-cells = &lt;1&gt;;
	clock-names = "hse", "hsi", "csi", "lse", "lsi";
	clocks = &lt;&amp;scmi_clk CK_SCMI_HSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_HSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_CSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSI&gt;;
};
</code></pre>
<p>Thus, when the driver compatible with <code>"st,stm32mp13-rcc"</code> (implemented in
<code>drivers/clk/stm32/clk-stm32mp13.c</code>) needs to refer to its <code>"hse"</code> clock, it
calls the <code>scmi_clk</code> and gives it the <code>CK_SCMI_HSE</code> parameter. Recall that
<code>scmi_clk</code> is defined in the same <code>DTSI</code> file, under <code>firmware</code> / <code>scmi</code>:</p>
<pre><code>scmi_clk: protocol@14 {
	reg = &lt;0x14&gt;;
	#clock-cells = &lt;1&gt;;
};
</code></pre>
<p>There are some SCMI clocks, however, which are used by the <code>"st,stm32mp13-rcc"</code>
driver, which are not listed in the device tree. For example, in
<code>drivers/clk/stm32/clk-stm32mp13.c</code> we find many definitions such as the
following:</p>
<pre><code>static const char * const sdmmc12_src[] = {
	"ck_axi", "pll3_r", "pll4_p", "ck_hsi"
};
</code></pre>
<p>Here <code>ck_axi</code>, <code>pll3_r</code>, etc., refer to SCMI clocks, but these are not mentioned
in the device tree. How can the kernel find them? The way it works is that
during SCMI clock driver initialization, the driver registers these clocks (and
others as per the listing from the <code>stm32mp13-clks.h</code> header file above). When,
later, the <code>"st,stm32mp13-rcc"</code> driver is being initialized, it is able to refer
to these clocks simply by their name.</p>
<p>This means that the SCMI driver needs to be probed before the <code>RCC</code> driver. To
ensure this, note the following part of the device tree:</p>
<pre><code>rcc: rcc@50000000 {
    ...
	clocks = &lt;&amp;scmi_clk CK_SCMI_HSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_HSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_CSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSI&gt;;
};
</code></pre>
<p>The reference to SCMI clocks here does not mean that these particular clocks
(<code>HSE,</code> <code>HSI,</code> <code>CSI,</code> <code>LSE,</code> <code>LSI)</code> are used by the <code>RCC</code> driver. Rather, it
ensures that the SCMI clock driver is a dependency of the <code>RCC</code> driver, and gets
initialized first. It would have been much nicer if the device tree <code>RCC</code> node
listed all the clocks that are used by <code>RCC</code> rather than just referring to them
by their name string (such as <code>"pll3_r"</code>), but that’s the way ST implemented
things. In particular, this means that if we unset the <code>CONFIG_COMMON_CLK_SCMI</code>
entry in the kernel configuration, the kernel will no longer boot, without
printing any error message at all; the <code>RCC</code> driver will fail to work properly
since it can no longer refer to many of the clocks it needs by their name
string.</p>
<p>There is no need to understand SCMI clocks further, so long as we can replace
them all with “real” clocks, with registers under direct control of the <code>RCC</code>
driver from the Linux kernel.</p>
<h3 id="discussion">Discussion</h3>
<p>STM32MP135 presents an SDK that is, to my mind, overly complicated. To port the
setup from the evaluation board to a new board requires the understanding of
three bootloaders (ROM, TF-A, U-Boot), two operating systems (Linux, OP-TEE),
and a stack of other software. Most of this arose out of a desire to simplify
the process; for example, U-Boot aims to be the one universal bootloader in
embedded systems, so as to not have to learn a new one for each platform. But
the ironic end result is that after piling on so many “simplifications”, the net
result is more complicated than having none of them.</p>
<p>The claim that OP-TEE is mandatory probably arises out of a desire to avoid
having to maintain two separate development branches, a secure and a non-secure
one. This must be even more so considering the need to support the GUI-based
configuration utilities (STM32Cube), or the Yocto-based distributions.</p>
<p>However, as a developer I would prefer to be offered a minimal working
configuration where OP-TEE would be an “opt-in” configuration, rather than
tightly bundling it in with the kernel. Many (most?) applications do not call
for secure-world services; these get included only due to the large cost of
<em>removing</em> it from the provided SDKs.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>09/26/2025: I have made the modifications available in the repository
<a href="https://github.com/js216/stm32mp135_simple"><code>stm32mp135_simple</code></a>, as mentioned
in the quick tutorial above. I do not at present have the intention of
upstreaming it, since it would involve a lot of effort updating it to the latest
version of Buildroot (or TF-A and Linux), only to watch it become obsolete again
during the upstreaming process.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><em>5. This article</em></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="836d8114-fn1"><p>ST wiki: <a href="https://wiki.st.com/stm32mpu/wiki/How_to_disable_OP-TEE_secure_services">How to disable OP-TEE secure
services</a> <a class="footnote-backref" href="#836d8114-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page5.html">← Older articles</a></div>
        <div><a class="newer" href="page3.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
