<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="linux-tfa-bl33-qemu">Linux as TF-A BL33 on Qemu (No U-Boot)</a></h2>
<div class="article-meta">Published 15 Sep 2025, modified 18 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1.jpg"/></p>
<p><em>This is Part 4 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>With Qemu, anyone can customize the Linux boot process and run it without the
need for custom hardware. In this article, we will adapt a Buildroot defconfig
to make TF-A boot Linux and OP-TEE directly without U-Boot.</p>
<p>This approach was suggested by A. Vandecappelle on the Buildroot mailing
list<sup class="footnote-ref"><a href="#fd3de487-fn1" id="fd3de487-fnref1">[1]</a></sup>. He was correct to point out that it would be
interesting to see a Qemu simulation of the “Falcon mode” boot process:</p>
<blockquote>
<p>Perhaps it would also be a good idea to add a variant of the qemu defconfigs
that tests this option. We can use the <code>qemu_arm_vexpress_tz_defconfig</code>, drop
U-Boot from it, and switch to booting to Linux directly from TF-A.</p>
</blockquote>
<p>First, we will look at the “normal” boot process with U-Boot to understand how
to remove it. Then, we will provide tutorial-style steps to remove U-Boot from
the boot process. Then, we suggest with how to integrate this into Buildroot. We
conclude with a discussion of alternative approaches.</p>
<h3 id="normal-boot-process">“Normal” boot process</h3>
<p>In the <code>qemu_arm_vexpress_tz_defconfig</code> defconfig, Qemu is instructed to load
Arm Trusted Firmware (TF-A) as “<code>bios</code>”. Qemu auto-generates a Device Tree Blob
(DTB) and loads it in memory at the start of RAM. As the Qemu
documentation<sup class="footnote-ref"><a href="#fd3de487-fn2" id="fd3de487-fnref2">[2]</a></sup> explains:</p>
<blockquote>
<ul>
<li>
<p>For guests using the Linux kernel boot protocol (this means any non-ELF file
passed to the QEMU <code>-kernel</code> option) the address of the DTB is passed in a
register (<code>r2</code> for 32-bit guests, or <code>x0</code> for 64-bit guests)</p>
</li>
<li>
<p>For guests booting as “bare-metal” (any other kind of boot), the DTB is at
the start of RAM (0x4000_0000)</p>
</li>
</ul>
</blockquote>
<p>In our case, TF-A is booted in the “bare-metal” mode. We can see in file
<code>plat/qemu/qemu/include/platform_def.h</code> that this is so:</p>
<pre><code><div class="codehilite"><pre><span></span>#define PLAT_QEMU_DT_BASE           NS_DRAM0_BASE
</pre></div>
</code></pre>
<p>TF-A patches the Qemu-provided DTB by inserting the information about the
reserved memory addresses used by the secure OS (OP-TEE), as well as the
protocol (PSCI) that Linux is to use to communicate with OP-TEE. Then, it passes
control to U-Boot.</p>
<p>U-Boot only task in this configuration, as far as I can tell, is to load the
initial compressed filesystem image into some range of memory addresses, then
patch the DTB with these addresses. Then, it passes control to the Linux kernel.</p>
<p>Linux reads the DTB, either from the address given in register r2 or perhaps
from the pre-defined memory location (not sure). Then, it reads the
<code>initrd-start</code> location from the <code>chosen</code> node, decompresses the filesystem,
locates the init process, and runs it.</p>
<p>Thus to remove U-Boot, we just have to load the initramfs ourselves, and add its
address to the DTB. Of course, we must also tell TF-A to not load the U-Boot and
instead run Linux directly. In the following section, we explain how to do that.</p>
<h3 id="falcon-mode-tutorial">Falcon-mode tutorial</h3>
<ol>
<li>
<p>Obtain Buildroot and check out and build the defconfig that we’re starting
from:</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone https://gitlab.com/buildroot.org/buildroot.git --depth=1
$ make qemu_arm_vexpress_tz_defconfig
$ make
</pre></div>
</code></pre>
<p>This builds everything and gives the script <code>start_qemu.sh</code> (under
<code>output/images</code>) with the suggested Qemu command line.</p>
</li>
<li>
<p>Extract the DTB by modifying the Qemu command as follows (note the
<code>dumpdtb=qemu.dtb</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>$ qemu-system-arm -machine virt,dumpdtb=qemu.dtb -cpu cortex-a15
</pre></div>
</code></pre>
</li>
<li>
<p>Uncompile the DTB into the source format so we can edit it:</p>
<pre><code><div class="codehilite"><pre><span></span>$ dtc -I dtb -O dts qemu.dtb &gt; new.dts
</pre></div>
</code></pre>
<p>Open <code>new.dts</code> in a text editor and modify the <code>chosen</code> node as follows,
adding the location of the initramfs (initrd):</p>
<pre><code><div class="codehilite"><pre><span></span>chosen {
	linux,initrd-end = &lt;0x00 0x7666e09d&gt;;
	linux,initrd-start = &lt;0x00 0x76000040&gt;;
	bootargs = "test console=ttyAMA0,115200 earlyprintk=serial,ttyAMA0,115200";
	stdout-path = "/pl011@9000000";
};
</pre></div>
</code></pre>
<p>Compile it back into the DTB format:</p>
<pre><code><div class="codehilite"><pre><span></span>dtc -I dts -O dtb new.dts &gt; new.dtb
</pre></div>
</code></pre>
</li>
<li>
<p>Open <code>make menuconfig</code> and navigate to <code>Bootloaders ---&gt; Arm Trusted Firmware (ATF)</code>. Switch the BL33 to <code>None</code>, and add the following Additional ATF build
variables:</p>
<pre><code><div class="codehilite"><pre><span></span>BL33=$(BINARIES_DIR)/zImage
</pre></div>
</code></pre>
<p>Exit and save new configuration and rebuild:</p>
<pre><code><div class="codehilite"><pre><span></span>$ make arm-trusted-firmware-rebuild
$ make
</pre></div>
</code></pre>
<p>Check that <code>output/images</code> contains updated <code>fip.bin</code>, which should be about
5 or 6M in size since it contains the whole kernel rather than just U-Boot.</p>
</li>
<li>
<p>Run Qemu with the following commands:</p>
<pre><code><div class="codehilite"><pre><span></span>$ cd output/images
$ exec qemu-system-arm -machine virt -dtb art.dtb -device \
     loader,file=rootfs.cpio.gz,addr=0x76000040 -machine secure=on -cpu \
     cortex-a15 -smp 1 -s -m 1024 -d unimp -netdev user,id=vmnic -device \
     virtio-net-device,netdev=vmnic -nographic \
     -semihosting-config enable=on,target=native -bios flash.bin
</pre></div>
</code></pre>
<p>This is of course just the old command from <code>start-qemu.sh</code>, with the DTB and
initramfs added. With some luck, you should see messages from TF-A directly
transitioning into the ones from the kernel, with no U-Boot in between:</p>
<pre><code><div class="codehilite"><pre><span></span>NOTICE:  Booting Trusted Firmware
NOTICE:  BL1: v2.7(release):v2.7
NOTICE:  BL1: Built : 20:55:52, Sep 12 2025
NOTICE:  BL1: Booting BL2
NOTICE:  BL2: v2.7(release):v2.7
NOTICE:  BL2: Built : 20:55:52, Sep 12 2025
NOTICE:  BL1: Booting BL32
Booting Linux on physical CPU 0x0
Linux version 6.12.27 (jk@Lutien) (arm-buildroot-linux-gnueabihf-gcc.br_real (Buildroot -g5b6b80bf) 14.3.0, GNU ld (GNU Binutils) 2.43.1) #2 SMP Fri Sep 12 20:03:32 PDT 2025
CPU: ARMv7 Processor [414fc0f0] revision 0 (ARMv7), cr=10c5387d
CPU: div instructions available: patching division code
CPU: PIPT / VIPT nonaliasing data cache, PIPT instruction cache
OF: fdt: Machine model: linux,dummy-virt
OF: fdt: Ignoring memory range 0x40000000 - 0x60000000
</pre></div>
</code></pre>
</li>
</ol>
<h3 id="tf-a-support-for-linux-as-bl33">TF-A support for Linux as BL33</h3>
<p>We saw above that TF-A is happy to boot Linux directly so long as we just point
it to a kernel image for the BL33 executable. It turns out that there we can
find limited support for this use case already in the TF-A source tree via the
<code>ARM_LINUX_KERNEL_AS_BL33</code> flag.</p>
<p>The flag is specific to a few platforms. For AArch64 on Qemu, the documentation
(<code>docs/plat/qemu.rst</code>, as well as <code>docs/plat/arm/arm-build-options.rst</code>)
explains that the flag makes TF-A pass the Qemu-generated DTB to the kernel via
the <code>x0</code> register. We see the implementation of it in
<code>plat/qemu/common/qemu_bl2_setup.c</code> (and very similar lines in
<code>plat/arm/common/arm_bl31_setup.c</code>):</p>
<pre><code><div class="codehilite"><pre><span></span>#if ARM_LINUX_KERNEL_AS_BL33
		/*
		 * According to the file ``Documentation/arm64/booting.txt`` of
		 * the Linux kernel tree, Linux expects the physical address of
		 * the device tree blob (DTB) in x0, while x1-x3 are reserved
		 * for future use and must be 0.
		 */
		bl_mem_params-&gt;ep_info.args.arg0 =
			(u_register_t)ARM_PRELOADED_DTB_BASE;
		bl_mem_params-&gt;ep_info.args.arg1 = 0U;
		bl_mem_params-&gt;ep_info.args.arg2 = 0U;
		bl_mem_params-&gt;ep_info.args.arg3 = 0U;
</pre></div>
</code></pre>
<p>On AArch32, the flag as currently implemented is intended for operation with
<code>SP_MIN</code>. This is clear from the documentation: “for AArch32 <code>RESET_TO_SP_MIN</code>
must be 1 when using” the <code>ARM_LINUX_KERNEL_AS_BL33</code> flag
(<code>docs/plat/arm/arm-build-options.rst</code>). The <code>plat/arm/common/arm_common.mk</code>
Makefile enforces this.</p>
<p>Unfortunately this limits the potential use cases of <code>ARM_LINUX_KERNEL_AS_BL33</code>
to AArch64, or else to AArch32 with <code>SP_MIN</code> enabled. The Buildroot defconfig we
have adapted in the previous section uses OP-TEE instead of <code>SP_MIN</code>, and it is
also possible to use no BL32 at all.</p>
<h3 id="patching-initramfs-address">Patching initramfs address</h3>
<p>In the tutorial above, we dumped the Qemu DTB and modified it just to add two
lines into the <code>chosen</code> node. The same can be done by TF-A.</p>
<p>The file <code>plat/qemu/common/qemu_bl2_setup.c</code> defines the function <code>update_dt()</code>
which is used for precisely this purpose, updating the DTB with some extra
board-specific details. (In the defconfig, it inserts PSCI nodes.)</p>
<p>We can insert the two <code>chosen</code> lines in the middle of <code>update_dt()</code>:</p>
<pre><code><div class="codehilite"><pre><span></span>fdt_setprop_u64(fdt, fdt_path_offset(fdt, "/chosen"),
        "linux,initrd-start", 0x76000040);
fdt_setprop_u64(fdt, fdt_path_offset(fdt, "/chosen"),
        "linux,initrd-end",   0x7666e09d);
</pre></div>
</code></pre>
<p>On recompile, there is no need to manually modify the DTB anymore.</p>
<p>The disadvantage of this approach is that we have to patch TF-A, making our
defconfig fragile against future changes in TF-A. It would be better to include
that DTB compilation as a post-build script in Buildroot.</p>
<h3 id="discussion">Discussion</h3>
<p>Is it practical to assume that the initramfs will be loaded in memory before
TF-A even starts executing? Of course not. But on a real embedded platform, such
as the setup from the <a href="stm32mp135-without-u-boot">previous article</a>, the root
filesystem is the SD card or some other non-volatile storage. There appears to
be no good reason to use U-Boot since TF-A can read from these just fine. If, on
the other hand, your setup requires some complicated configuration of the root
filesystem, possibly involving Ethernet, then U-Boot may well be a good choice.
Still, I believe that the best tool for the job is the simplest one that works
reliably.</p>
<p>It is also not reasonable to assume that the DTB would be loaded in memory
before TF-A even begins execution. After all, as the only bootloader, it is its
job to load it and point the kernel to where it loaded it. As P. Maydell
explains on the qemu-discuss mailing list<sup class="footnote-ref"><a href="#fd3de487-fn3" id="fd3de487-fnref3">[3]</a></sup>, providing the <code>-dtb</code> option to
Qemu “overrides the autogenerated file. But generally you shouldn’t do that.”
Instead, the Qemu user should provide the DTB, if emulating real hardware, or
else to have the Qemu</p>
<blockquote>
<p>autogenerate the DTB matching whatever it does, like the virt board. This is
the unusual case – virt only does this because it is a purely “virtual” board
that doesn’t match any real physical hardware and which changes depending on
what the user asked for.</p>
</blockquote>
<p>For example, on STM32MP1, the TF-A <code>fiptool</code> is used to package the DTB in a
form that TF-A is able to load it in memory using the <code>BL33_CFG</code> flag, as we
have used in <a href="stm32mp135-without-u-boot">previous article</a>.</p>
<p>There may be other ways to load the DTB and initramfs in Qemu, but the one
presented in our tutorial above appears to be the easiest. We could, for
example, modify Qemu to allow using the <code>-initrd</code> command line flag without the
<code>-kernel</code> flag, and emit the DTB with the appropriate address. Or, we could
teach TF-A how to read the initramfs file via the semihosting or virtio
protocols, load it into memory, and modify the DTB accordingly.</p>
<p>However, the tutorial method above works without modifying Qemu or TF-A code. It
uses an explicit DTB, as one is likely to do on a physical embedded target.
Since it passes the initramfs using an explicit command line option, it avoids
hard-coding it into any compiled code.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>17/9/2025: first submission of the Qemu defconfig
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786597.html">(link)</a></p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><em>4. This article</em></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="fd3de487-fn1"><p>Buildroot mailing list, Fri May 16 2025 message:
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-May/778563.html">boot/arm-trusted-firmware: optional Linux as
BL33</a>
(cited on 09/15/2025) <a class="footnote-backref" href="#fd3de487-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="fd3de487-fn2"><p>Qemu: <a href="https://www.qemu.org/docs/master/system/arm/virt.html#hardware-configuration-information-for-bare-metal-programming">‘virt’ generic virtual
platform</a>
(cited 09/15/2025). <a class="footnote-backref" href="#fd3de487-fnref2">↩︎</a></p>
</li>
<li class="footnote-item" id="fd3de487-fn3"><p>qemu-discuss mailing list, Thu 4 Aug 2022 message: <a href="https://lists.gnu.org/archive/html/qemu-discuss/2022-08/msg00007.html">Re: how to prevent automatic
dtb
load?</a>
(cited 09/15/2025) <a class="footnote-backref" href="#fd3de487-fnref3">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="false-promise-of-dead-code-elimination">Dead Code Elimination is a False Promise</a></h2>
<div class="article-meta">Published 14 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/sq.jpg"/></p>
<p>Go through the source of any nontrivial program and chances are, most of the
code in there is used very rarely, and a lot if it may never be used. This is
the more so if a program is supposed to be very portable, such as in the Linux
kernel. Of course, compilers will eliminate it, so there’s no problem?</p>
<h3 id="the-problem">The Problem</h3>
<p>Compilers are supposed to detect what’s not being used, and remove the code.
They don’t do that. For example, processing one “compilation unit” at a time, a
C compiler has no idea which functions will be referenced to from other units
and which are entirely dead. (If the function is declared static, this <em>does</em>
work, so declare as many of them static.)</p>
<p>Surely by the time the linker is invoked, all the function calls are clear and
the rest can be stripped away? Also not likely. For example, the function calls
could be computed during runtime as casts of integers into function pointers. If
the linker were to remove them, this mechanism would fail. So long as several
functions are compiled into the same section, the linker will always include all
of them so long as at least one of them is used.</p>
<p>What if we instead explicitly mark which things we would like excluded?</p>
<h3 id="conditional-compilation">Conditional Compilation</h3>
<p>With conditional compilation, you can include/exclude whatever you want. When a
program has these conditional compilation switches, dead code <em>does</em> get
entirely deleted before the compiler even sees it. Most often, the result is a
myriad of poorly-documented (more likely: entirely undocumented) switches that
you don’t know what you’re allowed to disable.</p>
<p>For example, the Linux kernel provides the amazing menuconfig tool to manage
these inclusions and exclusions. Still, it can take days of work trying out
disabling and re-enabling things, till you give up and wisely conclude that this
“premature optimization” is not worth your time and leave everything turned on
as it is by default.</p>
<h3 id="packages">“Packages”</h3>
<p>The sad reality of modern scripting languages, and even compiled ones like Rust,
is that their robust ecosystems of packages and libraries encourage wholesale
inclusion of code whose size is entirely out of proportion to the task they
perform. (Don’t even mention <a href="https://harmful.cat-v.org/software/dynamic-linking/">shared
libraries</a>.)</p>
<p>As an example, let’s try out the popular Rust GUI library
<a href="https://github.com/emilk/egui">egui</a>. According to its Readme, it is modular,
so you can use small parts of egui as needed, and comes with “minimal
dependencies”. Just what we need to make a tiny app! Okay, first we need Rust
itself:</p>
<pre><code><div class="codehilite"><pre><span></span>$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ du -hs .rustup .cargo
1.3G    .rustup
20M     .cargo
</pre></div>
</code></pre>
<p>So far so good—the entire compiler and toolchain fits inside 1.3G, and we
start with 20M of packages. Now let’s clone the GUI library and compile its
simple example with a couple really simple widgets:</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone git@github.com:emilk/egui.git
$ cd egui/examples/hello_world_simple
$ cargo run -p hello_world_simple
$ cd &amp;&amp; du -hs .rustup .cargo
2.6G    .rustup
210M    .cargo
</pre></div>
</code></pre>
<p>Oops! How many gigabytes of code does it take to show a couple characters and
rectangles on the screen? Besides, the above took more than 20 min to complete
on a machine vastly superior to the Cray-2 supercomputer. The compiled program
was 236M in size, or 16M after stripping. Everyday We Stray Further …</p>
<p>This is far from being a “freak” example; even the simplest tasks in Rust and
Python and pretty much anything else considered “modern” will pull in gigabytes
of “essential” packages.</p>
<p>Packages get inextricably linked with the main program, resulting in an
exponential explosion of complexity (besides the linear growth in size). Once
linked, the program and its libraries/packages are no longer separate modules;
you cannot simply replace a library for a different one, despite the host of
false promises from the OOP crowd.</p>
<p>This is because the interfaces between these modules are very complex: hundreds
or thousands of function calls, complex object operations, &amp;c.</p>
<h3 id="the-solution">The Solution</h3>
<p>The only way I know of that works is to not have dead code to begin with.
Extra features should be strictly opt-in, not opt-out. These should be
implemented with separate compilation <em>and</em> linking; in other words, each
feature is a new program, not a library.</p>
<p>The objection may be raised that we’re advocating an extremely inefficient
paradigm, increasing the already significant overhead of function calls with the
much greater one of executing new programs. As an “extreme” example, a typical
Unix shell will parse each command (with few exceptions) as the name of a new
program to execute. How inefficient!?</p>
<p>Maintainable, replaceable code reuse can only happen when the interfaces are
well specified and minimal, such as obtain between cooperating independent
programs in a Unix pipeline.</p>
<blockquote>
<p>The key to problem-solving on the UNIX system is to identify the right
primitive operations and to put them at the right place. UNIX programs tend to
solve general problems rather than special cases. In a very loose sense, the
programs are orthogonal, spanning the space of jobs to be done (although with
a fair amount of overlap for reasons of history, convenience or efficiency).
Functions are placed where they will do the most good: there shouldn’t be a
pager in every program that produces output any more than there should be
filename pattern matching in every program that uses filenames.</p>
<p>One thing that UNIX does not need is more features. It is successful in part
because it has a small number of good ideas that work well together. Merely
adding features does not make it easier for users to do things — it just
makes the manual thicker.<sup class="footnote-ref"><a href="#2d457a2f-fn1" id="2d457a2f-fnref1">[1]</a></sup></p>
</blockquote>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="2d457a2f-fn1"><p>Pike, Rob, and Brian Kernighan. “Program design in the UNIX
environment.” AT&amp;T Bell Laboratories Technical Journal 63.8 (1984):
1595-1605. See also <a href="https://harmful.cat-v.org/cat-v/">UNIX Style, or cat -v Considered
Harmful</a>. <a class="footnote-backref" href="#2d457a2f-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-without-u-boot">STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></h2>
<div class="article-meta">Published 11 Sep 2025, modified 20 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/red.jpg"/></p>
<p><em>This is Part 3 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In this article, we use Arm Trusted Firmware (TF-A) to load the Linux kernel
directly, without using U-Boot.<sup class="footnote-ref"><a href="#2585774d-fn1" id="2585774d-fnref1">[1]</a></sup> I have seen the idea of omitting the
Secondary Program Loader (SPL) referred to as “falcon mode”, since it makes the
boot process (slightly) faster. However, I am primarily interested in it as a
way of reducing overall complexity of the software stack.</p>
<p>In this article, we will implement this in two ways. First, we modify the files
as needed manually. At the end of the article, we provide an alternative method:
directly integrate the changes into Buildroot.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>To get started, make sure to have built the default configuration as per the
<a href="stm32mp135-linux-default-buildroot">first article</a> of this series. Very
briefly, this entails cloning the official Buildroot repository, selecting a
defconfig, and compiling:</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone https://gitlab.com/buildroot.org/buildroot.git --depth=1
$ cd buildroot
$ make stm32mp135f_dk_defconfig
$ make menuconfig # add the STM32MP_USB_PROGRAMMER=1 flag to TF-A build
$ make
</pre></div>
</code></pre>
<p>It is also recommended to learn how to flash the SD card without removing it via
a USB connection, as explained in the <a href="stm32mp135-linux-cubeprog">second
article</a>.</p>
<h3 id="tutorial">Tutorial</h3>
<p>The procedure is pretty simple. All we need to do is to modify some files,
adjust some build parameters, recompile, and the new SD card image is ready to
test.</p>
<ol>
<li>
<p>Before making any modifications, make a backup of the file containing U-Boot.</p>
<pre><code><div class="codehilite"><pre><span></span>$ cd output/images
$ cp fip.bin fip_uboot.bin
</pre></div>
</code></pre>
<p>Double check that the above <code>fip.bin</code> was built using the additional ATF
build variable <code>STM32MP_USB_PROGRAMMER=1</code>, otherwise USB flashing will not
work!</p>
<p>Open <code>flash.tsv</code>, and update the <code>fip.bin</code> to <code>fip_uboot.bin</code> there as well.</p>
<p>(Despite removing U-Boot from the boot process, we are still going to use it
to flash the SD card image via USB using the STM32CubeProg.)</p>
</li>
<li>
<p>Two TF-A files need to be modified, so navigate to the TF-A build directory:</p>
<pre><code><div class="codehilite"><pre><span></span>$ cd ../build/arm-trusted-firmware-lts-v2.10.5
</pre></div>
</code></pre>
<p>Since the kernel is much bigger than U-Boot, it takes longer to load. We need
to adjust the SD card reading timeout. In <code>drivers/st/mmc/stm32_sdmmc2.c</code>,
find the line</p>
<pre><code><div class="codehilite"><pre><span></span>timeout = timeout_init_us(TIMEOUT_US_1_S);
</pre></div>
</code></pre>
<p>and replace it with</p>
<pre><code><div class="codehilite"><pre><span></span>timeout = timeout_init_us(TIMEOUT_US_1_S * 5);
</pre></div>
</code></pre>
<p>Next, we would like to load the kernel deep enough into the memory space so
that relocation of the compressed image is not necessary. In file
<code>plat/st/stm32mp1/stm32mp1_def.h</code>, find the line</p>
<pre><code><div class="codehilite"><pre><span></span>#define STM32MP_BL33_BASE              STM32MP_DDR_BASE
</pre></div>
</code></pre>
<p>and replace it with</p>
<pre><code><div class="codehilite"><pre><span></span>#define STM32MP_BL33_BASE              (STM32MP_DDR_BASE + U(0x2008000))
</pre></div>
</code></pre>
<p>Finally, in order to allow loading such a big <code>BL33</code> as the kernel image, we
adjust the max size. In the same file, find the line</p>
<pre><code><div class="codehilite"><pre><span></span>#define STM32MP_BL33_MAX_SIZE          U(0x400000)
</pre></div>
</code></pre>
<p>and replace it with</p>
<pre><code><div class="codehilite"><pre><span></span>#define STM32MP_BL33_MAX_SIZE          U(0x3FF8000)
</pre></div>
</code></pre>
</li>
<li>
<p>Next, we need to modify a couple build parameters. Open the <code>make menuconfig</code>
and navigate to <code>Bootloaders ---&gt; ARM Trusted Firmware (ATF)</code>.</p>
<ul>
<li>
<p>Under <code>BL33</code>, change from U-Boot to None.</p>
</li>
<li>
<p>Under <code>Additional ATF build variables</code>, make sure that U-Boot is not
present and add the following key-value pairs:</p>
<pre><code><div class="codehilite"><pre><span></span>BL33=$(BINARIES_DIR)/zImage BL33_CFG=$(BINARIES_DIR)/stm32mp135f-dk.dtb
</pre></div>
</code></pre>
</li>
</ul>
<p>Select “Ok” and “Esc” out of the menus, making sure to save the new
configuration.</p>
<p>Next, open the file
<code>board/stmicroelectronics/common/stm32mp1xx/genimage.cfg.template</code> and
increase the size of the <code>fip</code> partition, for example:</p>
<pre><code><div class="codehilite"><pre><span></span>partition fip {
	image = "fip.bin"
	size = 8M
}
</pre></div>
</code></pre>
<p>Finally, since U-Boot will no longer be around to pass the Linux command line
arguments, we can instead pass them through the device tree source. Open the
file <code>output/build/linux-6.12.22/arch/arm/boot/dts/st/stm32mp135f-dk.dts</code>
(you may have a different Linux version, just modify the path as appropriate)
and add the <code>bootargs</code> into the <code>chosen</code> section, as follows:</p>
<pre><code><div class="codehilite"><pre><span></span>chosen {
	stdout-path = "serial0:115200n8";
	bootargs = "root=/dev/mmcblk0p4 rootwait";
};
</pre></div>
</code></pre>
</li>
<li>
<p>Now we can rebuild the TF-A, the device tree blob, and regenerate the SD card
image. Thanks to the magic of Buildroot, all it takes is:</p>
<pre><code><div class="codehilite"><pre><span></span>$ make linux-rebuild
$ make arm-trusted-firmware-rebuild
$ make
</pre></div>
</code></pre>
<p>Keep in mind that rebuilding TF-A is needed any time the Linux kernel or DTS
or TF-A sources change, since the kernel gets packaged into the <code>fip</code> by the
TF-A build process. In this case, the first <code>make</code> rebuilds the DTB, the
second packages it in the <code>fip</code>, and the third makes sure it gets into the SD
card.</p>
</li>
<li>
<p>Set DIP switch to serial boot (press in the upper all of all rockers) and
flash to SD card:</p>
<pre><code><div class="codehilite"><pre><span></span>$ sudo ~/cube/bin/STM32_Programmer_CLI -c port=usb1 -w output/images/flash.tsv
</pre></div>
</code></pre>
<p>Then reconfigure the DIP switches for SD card boot (press the bottom side of
the second rocker switch from the left), and press the black reboot button.</p>
</li>
</ol>
<p>If you watch the serial monitor carefully, you will notice that we transition
from TF-A directly to OP-TEE and Linux. Success! No U-Boot in the boot process:</p>
<pre><code><div class="codehilite"><pre><span></span>NOTICE:  Model: STMicroelectronics STM32MP135F-DK Discovery Board
NOTICE:  Board: MB1635 Var1.0 Rev.E-02
NOTICE:  BL2: v2.10.5(release):lts-v2.10.5
NOTICE:  BL2: Built : 20:58:52, Sep 10 2025
NOTICE:  BL2: Booting BL32
I/TC: Early console on UART#4
I/TC: 
I/TC: Embedded DTB found
I/TC: OP-TEE version: Unknown_4.3 (gcc version 14.3.0 (Buildroot 2025.08-rc3-87-gbbb0164de0)) #1 Thu Sep  4 03:06:46 UTC 2025 arm
...
(more OP-TEE messages here)
...
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.12.22 (jk@Lutien) (arm-buildroot-linux-gnueabihf-gcc.br_real (Buildroot 2025.08-rc3-87-gbbb0164de0) 14.3.0, GNU ld (GNU Binutils) 2.43.1) #1 SMP PREEMPT Wed Sep  3 20:23:46 PDT 2025
[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d
</pre></div>
</code></pre>
<h3 id="buildroot-integration">Buildroot integration</h3>
<p>Instead of following the above instructions, we can automate the build process
by integrating it into Buildroot. To this end, I provide the GitHub repository
<a href="https://github.com/js216/stm32mp135_simple"><code>stm32mp135_simple</code></a> that can be
used as follows.</p>
<p>Clone the Buildroot repository. To make the procedure reproducible, let’s start
from a fixed commit (latest at the time of this writing):</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone https://gitlab.com/buildroot.org/buildroot.git
$ cd buildroot
$ git checkout 5b6b80bfc5237ab4f4e35c081fdac1376efdd396
</pre></div>
</code></pre>
<p>Obtain this repository with the patches we need. Copy the defconfig and the
board-specific files into the Buildroot tree.</p>
<pre><code><div class="codehilite"><pre><span></span>$ git clone git@github.com:js216/stm32mp135_simple.git
$ cd buildroot # NOT stm32mp135_simple
$ git apply ../stm32mp135_simple/patches/add_falcon.patch
$ git apply ../stm32mp135_simple/patches/increase_fip.patch
$ cp ../configs/stm32mp135_simple/stm32mp135f_dk_falcon_defconfig configs
$ cp -r ../board/stm32mp135_simple/stm32mp135f-dk-falcon board/stmicroelectronics
</pre></div>
</code></pre>
<p>Build as usual, but using the new defconfig:</p>
<pre><code><div class="codehilite"><pre><span></span>$ make stm32mp135f_dk_falcon_defconfig
$ make
</pre></div>
</code></pre>
<p>Flash to the SD card and boot into the new system. You should reach the login
prompt exactly as in the default configuration—but without involving U-Boot</p>
<h3 id="discussion">Discussion</h3>
<p>To port the “default” STM32MP135 setup<sup class="footnote-ref"><a href="#2585774d-fn2" id="2585774d-fnref2">[2]</a></sup> to a new board design, one is
expected to be comfortable writing and modifying the drivers and device tree
sources that work with</p>
<ul>
<li>Arm Trusted Firmware (Primary Program Loader)</li>
<li>OP-TEE (Trusted Execution Environment)</li>
<li>U-Boot (Secondary Program Loader)</li>
<li>Linux kernel</li>
<li>Buildroot, or, worse, Yocto</li>
</ul>
<p>That is a tall order for a new embedded developer trying to get started
integrating Linux in their products. To make things worse, there is at present
almost no literature to be found suggesting that a simpler, saner method exists.
Certainly the chip vendors themselves do not encourage it.<sup class="footnote-ref"><a href="#2585774d-fn3" id="2585774d-fnref3">[3]</a></sup></p>
<p>With this article, we have began chipping away at the unnecessary complexity. We
have removed U-Boot from the boot chain. (We still use it for copying the SD
card image via USB. One thing at a time!) Since our goal is to <em>run Linux</em>, the
list above gives us a blueprint for the work that remains to be done: get rid of
everything that is <em>not Linux</em>.</p>
<p>The software that you do not run is software you do not have to understand,
test, debug, maintain, and be responsible for when it breaks down ten years down
the line in some deeply embedded application, perhaps in outer space.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>19/12/2024: original Buildroot mailing list submission <a href="https://lists.buildroot.org/pipermail/buildroot/2024-December/769250.html">(1/1)</a></p>
<p>16/12/2025: response by Arnout Vandecappelle <a href="https://lists.buildroot.org/pipermail/buildroot/2025-May/778563.html">(link)</a></p>
<p>17/9/2025: amended submission <a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786595.html">(v2 0/2, </a>
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786596.html">1/2, </a>
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786597.html">2/2)</a></p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><em>3. This article</em></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="2585774d-fn1"><p>This approach is inspired by the ST wiki article <a href="https://wiki.st.com/stm32mpu/wiki/How_to_optimize_the_boot_time">How to optimize the
boot time</a>,
under “Optimizing boot-time by removing U-Boot”. (cited 09/11/2025) <a class="footnote-backref" href="#2585774d-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="2585774d-fn2"><p>See the ST Wiki, <a href="https://wiki.st.com/stm32mpu/wiki/OpenSTLinux_distribution">OpenSTLinux
distribution</a>
(cited 09/11/2025) <a class="footnote-backref" href="#2585774d-fnref2">↩︎</a></p>
</li>
<li class="footnote-item" id="2585774d-fn3"><p>As per the <a href="https://community.st.com/t5/stm32-mpus-embedded-software-and/start-linux-kernel-from-tf-a/td-p/91321">ST
forum,</a>
(cited 09/11/2025) the approach outlined in the present article is
officially <em>not</em> supported by ST. <a class="footnote-backref" href="#2585774d-fnref3">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="bugs-in-nxp-kinetis-ethernet-driver">Bugs in NXP Kinetis Ethernet Driver</a></h2>
<div class="article-meta">Published 10 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/lev63.jpg"/></p>
<p>The SDK<sup class="footnote-ref"><a href="#d22b0ac5-fn1" id="d22b0ac5-fnref1">[1]</a></sup> drivers provided by NXP for use on the Kinetis K64 platform are
extensive, well-tested and … not perfect. This article shows three bugs found
in the ethernet driver. Note that none of this is original content; I merely put
it together here for my future reference.</p>
<h3 id="forgetting-to-check-for-zero-length-buffers">Forgetting to check for zero-length buffers</h3>
<p>I have only seen this bug happen once in two years and have not found a way to
reproduce it at will. So the analysis below may or may not be correct.</p>
<p>The symptom was that the firmware froze upon triggering the assertion in
<code>lwip/port/enet_ethernetif_kinetis.c</code>:</p>
<blockquote>
<p>“Buffer returned by <code>ENET_GetRxFrame()</code> doesn’t match any RX buffer descriptor”</p>
</blockquote>
<p>After some Googling I found <a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">this forum
thread,</a>
which suggests, in a roundabout way, that there is a missing check in
<code>fsl_enet.c</code>. We have to add following to <code>ENET_GetRxFrame()</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">curBuffDescrip</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0U</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Set LAST bit manually to let following drop error frame</span>
<span class="cm">       operation drop this abnormal BD.</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="n">curBuffDescrip</span><span class="o">-&gt;</span><span class="n">control</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">ENET_BUFFDESCRIPTOR_RX_LAST_MASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kStatus_ENET_RxFrameError</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>The NXP engineer on the forum explains: “I didn’t use this logic because I never
meet this corner case and consider it a redundant operation.” I was curious if
this “corner case” every happens, so I added a breakpoint, which got triggered
after about two days of constant testing.</p>
<p>ChatGPT seems to think this check is necessary (but then again, I seem to be
able to convince it of just about anything I do or do not believe in):</p>
<blockquote>
<p>If you omit the check and DMA ever delivers a BD with <code>length == 0</code>: Your code
will think it’s still in the middle of assembling a frame. It will not see the
<code>LAST</code> bit yet, so it will happily advance to the next BD. That means the
logic walks into an inconsistent state: <code>rxBuffer</code> may point to nothing, your
<code>rxFrame</code> bookkeeping goes out of sync, and later you’ll crash on a buffer
underrun, invalid pointer, or corrupted frame queue.</p>
</blockquote>
<p>It remains to be seen if this check was behind my original crash, and if the
body of the if statement is appropriate to handle the condition of unexpected
zero-length buffer descriptor.</p>
<p><em>Credit: User pjanco first reported the error, while AbnerWang posted the
solution.</em>
<a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">[source]</a></p>
<h3 id="incorrect-memory-deallocation">Incorrect memory deallocation</h3>
<p>In <code>fsl_enet.c</code>, the function <code>ENET_GetRxFrame()</code> tries to deallocate the
pointer of the receive buffer:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0U</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">rxBuffFree</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rxFrame</span><span class="o">-&gt;</span><span class="n">rxBuffArray</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">        </span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">,</span><span class="w"> </span><span class="n">ringId</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>First need to unpack some definitions to understand what the above means.</p>
<ol>
<li>
<p>If we dig into the <code>rxBuffFree()</code> function, we discover it in the file
<code>lwip/port/enet_ethernetif_kinetis.c</code>. The buffer to be deallocated is passed
as a pointer <code>void * buffer</code>, and freed</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">rx_buffer_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">RxDataBuff</span><span class="p">;</span>
<span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">RxPbufs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">buffer_used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</pre></div>
</code></pre>
</li>
<li>
<p>Next, what are <code>rxFrame</code> and <code>rxBuffArray</code>? The first one is of type
<code>enet_rx_frame_struct_t</code>, which is defined in <code>fsl_enet.h</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_enet_rx_frame_struct</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">enet_buffer_struct_t</span><span class="w"> </span><span class="o">*</span><span class="n">rxBuffArray</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span><span class="w"> </span><span class="n">enet_rx_frame_struct_t</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>This allows us to see what is the type of <code>rxBuffArray</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_enet_buffer_struct</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">enet_buffer_struct_t</span><span class="p">;</span>
</pre></div>
</code></pre>
</li>
<li>
<p>Finally, what is <code>ethernetif-&gt;RxDataBuff</code>? We find it declared in
<code>lwip/port/enet_ethernetif_kinetis.c</code> as the static array in the function
<code>ethernetif0_init()</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">SDK_ALIGN</span><span class="p">(</span><span class="k">static</span><span class="w"> </span><span class="n">rx_buffer_t</span><span class="w"> </span><span class="n">rxDataBuff_0</span><span class="p">[</span><span class="n">ENET_RXBUFF_NUM</span><span class="p">],</span>
<span class="w">    </span><span class="n">FSL_ENET_BUFF_ALIGNMENT</span><span class="p">);</span>
<span class="n">ethernetif_0</span><span class="p">.</span><span class="n">RxDataBuff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">rxDataBuff_0</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</code></pre>
<p>More precisely, <code>RxDataBuff</code> is a pointer to the first element of this array.
This pointer therefore has the type <code>rx_buffer_t*</code>.</p>
<p>That type itself is declared at the top of the same file as an aligned
version of a <code>uint8_t</code> buffer:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">rx_buffer_t</span><span class="p">[</span><span class="n">SDK_SIZEALIGN</span><span class="p">(</span><span class="n">ENET_RXBUFF_SIZE</span><span class="p">,</span>
<span class="w">    </span><span class="n">FSL_ENET_BUFF_ALIGNMENT</span><span class="p">)];</span>
</pre></div>
</code></pre>
</li>
</ol>
<p>Now we can take a step back and think whether the <code>idx</code> calculation would be
best done with the buffer itself, or a pointer to it. The calculation subtracts
the following:</p>
<ul>
<li>
<p><code>rxFrame-&gt;rxBuffArray[index].buffer</code>, of type <code>void*</code>, is a pointer to the
memory location that stores the ethernet frame.</p>
</li>
<li>
<p><code>ethernetif-&gt;RxDataBuff</code>, of type <code>rx_buffer_t*</code></p>
</li>
</ul>
<p>The corrected code should pass the buffer pointer stored in .buffer, not the
address of the .buffer field (omit the <code>&amp;</code>):</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">rxBuffFree</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">rxFrame</span><span class="o">-&gt;</span><span class="n">rxBuffArray</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">,</span><span class="w"> </span><span class="n">ringId</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><em>Credit: This bug was found by KC on 7/31/2024.</em></p>
<h3 id="buffers-not-zero-initialized">Buffers not zero-initialized</h3>
<p>Another bug in <code>ethernetif0_init()</code> in <code>enet_ethernetif_kinetis.c</code>: the ethernet
buffer descriptor structs are declared static:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">AT_NONCACHEABLE_SECTION_ALIGN</span><span class="p">(</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">enet_rx_bd_struct_t</span><span class="w"> </span><span class="n">rxBuffDescrip_0</span><span class="p">[</span><span class="n">ENET_RXBD_NUM</span><span class="p">],</span>
<span class="w">    </span><span class="n">FSL_ENET_BUFF_ALIGNMENT</span><span class="p">);</span>
<span class="n">AT_NONCACHEABLE_SECTION_ALIGN</span><span class="p">(</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">enet_tx_bd_struct_t</span><span class="w"> </span><span class="n">txBuffDescrip_0</span><span class="p">[</span><span class="n">ENET_TXBD_NUM</span><span class="p">],</span>
<span class="w">    </span><span class="n">FSL_ENET_BUFF_ALIGNMENT</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>The assumption is that since they are declared <code>static</code>, the descriptors will be
zero-initialized at system startup. However, the macro
<code>AT_NONCACHEABLE_SECTION_ALIGN</code> potentially places these descriptor in a special
section that can bypass the zero-initialization, depending on the startup code
and linker script.</p>
<p>In that case, we need to manually zero out these buffers. I put the following at
the top of <code>ethernetif_enet_init()</code> in <code>enet_ethernetif_kinetis.c</code>:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="c1">// Buffer descriptors must be initialized to zero</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">RxBuffDescrip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="n">ENET_RXBD_NUM</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">RxBuffDescrip</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">TxBuffDescrip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="n">ENET_TXBD_NUM</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ethernetif</span><span class="o">-&gt;</span><span class="n">TxBuffDescrip</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
</code></pre>
<p><em>Credit: This bug was also found by KC.</em></p>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="d22b0ac5-fn1"><p>I am using SDK version 2.11.0 for the MK64FN1M0xxx12. <a class="footnote-backref" href="#d22b0ac5-fnref1">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-linux-cubeprog">STM32MP135 Flashing via USB with STM32CubeProg</a></h2>
<div class="article-meta">Published 7 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/cal.jpg"/></p>
<p><em>This is Part 2 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In the <a href="stm32mp135-linux-default-buildroot">previous article</a>, we built a Linux
kernel and manually copied it to an SD card. This works for a first test, but
quickly becomes annoying. Here, we show how to use the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg</a>
to flash the SD card without removing it from the evaluation board.</p>
<h3 id="tutorial">Tutorial</h3>
<p>Note: You may find the extensive explanations in the <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-implementing-factory-flashing/">Bootlin article about
flashing a similar
chip</a>
helpful.</p>
<ol>
<li>
<p>Finish the build process as per the <a href="stm32mp135-linux-default-buildroot">previous
article</a>, so as to have at least the
following files under <code>buildroot/output/images/</code>:</p>
<ul>
<li><code>tf-a-stm32mp135f-dk.stm32</code></li>
<li><code>fip.bin</code></li>
<li><code>u-boot-nodtb.bin</code></li>
<li><code>sdcard.img</code></li>
</ul>
</li>
<li>
<p>Go to the ST website to download the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg.</a>
This unfortunately requires a registration and sign-up.</p>
<p>Get the Linux version, unpack in a new directory, and run the installer (just
follow its verbose prompts):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>cubeprog
$<span class="w"> </span>unzip<span class="w"> </span>../stm32cubeprg-lin-v2-20-0.zip
$<span class="w"> </span>./SetupSTM32CubeProgrammer-2.20.0.linux
</pre></div>
</code></pre>
</li>
<li>
<p>Now plug in all three USB cables for the board. Set the DIP boot switches for
serial boot (press in all the upper parts of the white rocker switches).
Press the black reset button. If everything worked, you should be able to see
the board under your USB devices:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>jk@Lutien:/var/www/articles$<span class="w"> </span>lsusb
...
Bus<span class="w"> </span><span class="m">001</span><span class="w"> </span>Device<span class="w"> </span><span class="m">114</span>:<span class="w"> </span>ID<span class="w"> </span><span class="m">0483</span>:3753<span class="w"> </span>STMicroelectronics<span class="w"> </span>STLINK-V3
Bus<span class="w"> </span><span class="m">001</span><span class="w"> </span>Device<span class="w"> </span><span class="m">012</span>:<span class="w"> </span>ID<span class="w"> </span><span class="m">0483</span>:df11<span class="w"> </span>STMicroelectronics<span class="w"> </span>STM<span class="w"> </span>Device<span class="w"> </span><span class="k">in</span><span class="w"> </span>DFU<span class="w"> </span>Mode
...
</pre></div>
</code></pre>
<p>The <code>STLINK-V3</code> is what you can use to monitor the flashing progress via UART.
Simply open a serial monitor:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>sudo<span class="w"> </span>picocom<span class="w"> </span>-b<span class="w"> </span><span class="m">115200</span><span class="w"> </span>/dev/ttyACM0
</pre></div>
</code></pre>
</li>
<li>
<p>Run the STM32CubeProg from the location that you installed it in to check
that it is able to detect the board:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>~/cube/bin/STM32_Programmer_CLI<span class="w"> </span>-l<span class="w"> </span>usb
<span class="w">      </span>-------------------------------------------------------------------
<span class="w">                        </span>STM32CubeProgrammer<span class="w"> </span>v2.20.0
<span class="w">      </span>-------------------------------------------------------------------

<span class="o">=====</span><span class="w">  </span>DFU<span class="w"> </span><span class="nv">Interface</span><span class="w">   </span><span class="o">=====</span>

Total<span class="w"> </span>number<span class="w"> </span>of<span class="w"> </span>available<span class="w"> </span>STM32<span class="w"> </span>device<span class="w"> </span><span class="k">in</span><span class="w"> </span>DFU<span class="w"> </span>mode:<span class="w"> </span><span class="m">1</span>

<span class="w">  </span>Device<span class="w"> </span>Index<span class="w">           </span>:<span class="w"> </span>USB1
<span class="w">  </span>USB<span class="w"> </span>Bus<span class="w"> </span>Number<span class="w">         </span>:<span class="w"> </span><span class="m">001</span>
<span class="w">  </span>USB<span class="w"> </span>Address<span class="w"> </span>Number<span class="w">     </span>:<span class="w"> </span><span class="m">002</span>
<span class="w">  </span>Product<span class="w"> </span>ID<span class="w">             </span>:<span class="w"> </span>USB<span class="w"> </span>download<span class="w"> </span>gadget@Device<span class="w"> </span>ID<span class="w"> </span>/0x501,<span class="w"> </span>@Revision<span class="w"> </span>ID<span class="w"> </span>/0x1003,<span class="w"> </span>@Name<span class="w"> </span>/STM32MP135F<span class="w"> </span>Rev.Y,
<span class="w">  </span>Serial<span class="w"> </span>number<span class="w">          </span>:<span class="w"> </span><span class="m">002800423232511538303631</span>
<span class="w">  </span>Firmware<span class="w"> </span>version<span class="w">       </span>:<span class="w"> </span>0x0110
<span class="w">  </span>Device<span class="w"> </span>ID<span class="w">              </span>:<span class="w"> </span>0x0501
</pre></div>
</code></pre>
</li>
<li>
<p>If that worked, it’s time to prepare the images for flashing. Go to
<code>buildroot/output/images</code> and create a file <code>flash.tsv</code> with the following
contents:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="c1">#Opt	Id	Name	Type	IP	Offset	Binary</span>
-<span class="w">	</span>0x01<span class="w">	</span>fsbl1-boot<span class="w">	</span>Binary<span class="w">	</span>none<span class="w">	</span>0x0<span class="w">	</span>tf-a-stm32mp135f-dk.stm32
-<span class="w">	</span>0x03<span class="w">	</span>fip_boot<span class="w">	</span>Binary<span class="w">		</span>none<span class="w">	</span>0x0<span class="w">		</span>fip.bin
-<span class="w">	</span>0x03<span class="w">	</span>ssbl-boot<span class="w">	</span>Binary<span class="w">	</span>none<span class="w">	</span>0x0<span class="w">	</span>u-boot-nodtb.bin
P<span class="w">	</span>0x10<span class="w">	</span>sdcard<span class="w">	</span>RawImage<span class="w">	</span>mmc0<span class="w">		</span>0x0<span class="w">	</span>sdcard.img
</pre></div>
</code></pre>
<p>Finally, run the flashing command itself:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>sudo<span class="w"> </span>~/cube/bin/STM32_Programmer_CLI<span class="w"> </span>-c<span class="w"> </span><span class="nv">port</span><span class="o">=</span>usb1<span class="w"> </span>-w<span class="w"> </span>flash.tsv
</pre></div>
</code></pre>
<p>The STM32CubeProg will go through the sequence of files you wrote into
<code>flash.tsv</code>. First, the Arm Trusted Firmware (TF-A) gets written to the
memory and executed. It then does some secure magic behind the scenes and
accepts the next payload via the DFU protocol, the U-Boot. At last, U-Boot
itself is executed and it in turn accepts the last payload: the SD card
itself. Which was, after all, the only thing you wanted to transfer anyway
…</p>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>The tutorial above again presents the simplest method I have found so far, with
a minimum of steps and prerequisites, to flash the SD card of the eval board
without taking the card in and out. What’s the issue?</p>
<p>The STM32CubeProg comes in a 291M zip file, which gets installed as a 1.5G
program. We use it to copy a disk image to the SD card. See the problem yet?
Or let’s consider the on-board procedure: TF-A (4,212 files and 506,952 lines of
code according to <a href="https://github.com/AlDanial/cloc">cloc</a>) is used to run
U-Boot (21,632 files and 3,419,116 lines of code), just so that a semi-standard
USB DFU protocol can expose the SD card to write the image.</p>
<p>But why??? ChatGPT explains:</p>
<blockquote>
<p>U-Boot became the standard since vendors upstreamed support there, and it
offers cross-platform flashing via DFU/fastboot for factories and Windows
users who can’t <code>dd</code> raw disks. It also doubles as the hook for A/B updates,
rollback, and secure boot. In practice, this forces developers into a complex
boot stack, even though most boards could just boot Linux directly from
SD/eMMC and use a tiny DFU mass-storage tool for recovery.</p>
</blockquote>
<p>A more likely explanation is that the boot process has acquired an unnecessary
reputation for being difficult, so that few want to mess with it. If there is a
working solution, it will get incorporated into the software stack, no matter
how baroque. The warning has been around for a long time:</p>
<blockquote>
<p>Big building-blocks […] can lead to more compact code and shorter
development time. […] Less clear, however, is how to assess the loss of
control and insight when the pile of system-supplied code gets so big that one
no longer knows what’s going on underneath.</p>
<p>[… As] libraries, interfaces, and tools become more complicated, they become
less understood and less controllable. When everything works, rich programming
environments can be very productive, but when they fail, there is little
recourse.<sup class="footnote-ref"><a href="#805e1fa9-fn1" id="805e1fa9-fnref1">[1]</a></sup></p>
</blockquote>
<p>All these tool are intended to make our work easier, but as they are piled on
without any reasonable limit, the resulting mess is ironically far more
complicated than the problem they are solving. If the task at hand is to flash
an SD card image, why doesn’t the firmware expose the medium as a USB mass
storage device, so that standard tools like <code>dd</code> could be used to work with it?
The cynical answer suggests itself … They didn’t know better.</p>
<blockquote>
<p>Those who do not understand Unix are condemned to reinvent it, poorly.<sup class="footnote-ref"><a href="#805e1fa9-fn2" id="805e1fa9-fnref2">[2]</a></sup></p>
</blockquote>
<p>Surely it cannot be too difficult to write a simple “bare-metal” program, which
we could load to the board using the simple and well-documented UART protocol
implemented in the ROM of the STM32MP1. The program would be very small and
quick to load. The program would expose the available media as mass storage
devices, and that’s it.</p>
<p>But … You may object, we need U-Boot anyways, otherwise how are we to load
Linux? As we will explain in a future article, that is not so. U-Boot is
entirely unnecessary for a large class of embedded Unix applications.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><em>2. This article</em></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="805e1fa9-fn1"><p>B. Kernighan and R. Pike Overview: The Practice of Programming.
Addison-Wesley, 1999. <a class="footnote-backref" href="#805e1fa9-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="805e1fa9-fn2"><p>Attributed to Henry Spencer as his November 1987 Usenet signature in E.
S.  Raymond: The Art of Unix Programming. Addison-Wesley, 2004. <a class="footnote-backref" href="#805e1fa9-fnref2">↩︎</a></p>
</li>
</ol>
</section>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page6.html">← Older articles</a></div>
        <div><a class="newer" href="page4.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
