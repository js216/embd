<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-without-optee">STM32MP135 Without OP-TEE</a></h2>
<div class="article-meta">Published 26 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1120.jpg"/></p>
<p><em>This is Part 5 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>Arm chips, such as the STM32MP135, implementing the TrustZone extension divide
the execution into two worlds: a normal, non-secure world inhabited by the
application operating system, and a secure world serviced by a secure OS such as
OP-TEE. The ST wiki<sup class="footnote-ref"><a href="#fn-6666672e-wiki" id="fnref-6666672e-wiki">[1]</a></sup> assures us that OP-TEE is required on all STM32MP1
produces “due to the hardware architecture”. It is our purpose in this article
to show that that is not the case: <em>OP-TEE is in fact entirely optional</em>.</p>
<p>The only mechanism to enter the “secure world” is via the <code>SMC</code> instruction
(secure monitor call). This is analogous to how user-space applications invoke
kernel system calls via the <code>SVC</code> (supervisor call) instruction to enter
privileged mode. So long as the kernel does not issue the <code>SMC</code> instruction, the
secure world need never be entered. Thus, we can restate our purpose as removing
all secure monitor calls from the kernel configuration.</p>
<p>The present article is somewhat more involved than the preceding ones in the
series. For this reason I offer the <a href="#quick-start">“Quick Start”</a> version, where
the required modifications to kernel drivers are offered as patches to apply to
a particular version. For those interested, the <a href="#theory">“Theory”</a> section fill
in the details. As in other articles, we conclude with a brief discussion.</p>
<h3 id="quick-start">Quick Start</h3>
<p>Start by cloning Buildroot as above. However, this time we check out a different
sequence of patches and board files:</p>
<div class="codehilite"><pre><code class="language-text">$ git clone https://gitlab.com/buildroot.org/buildroot.git
$ git clone git@github.com:js216/stm32mp135_simple.git

$ cd buildroot
$ git checkout 3645e3b781be5cedbb0e667caa70455444ce4552

$ git apply ../stm32mp135_simple/patches/add_falcon.patch
$ cp ../stm32mp135_simple/configs/stm32mp135f_dk_nonsecure_defconfig configs
$ cp -r ../stm32mp135_simple/board/stm32mp135f-dk-nonsecure board/stmicroelectronics</code></pre></div>
<p>Now build:</p>
<div class="codehilite"><pre><code class="language-text">$ make stm32mp135f_dk_nonsecure_defconfig
$ make</code></pre></div>
<p>Write the generated image to the SD card (either directly with a tool such as
<code>dd</code>, or using the STM32CubeProg as explained
<a href="stm32mp135-linux-cubeprog">here</a>). Watch it boot up without U-Boot, and without
OP-TEE.</p>
<h3 id="theory">Theory</h3>
<p>To understand the modifications we are about to do in the next section, we need
to take a closer look at the boot process from TF-A to OP-TEE to Linux. In
particular, we need to explain how secure monitor calls (SMC) calls work; the
use of secure interrupts (<code>FIQ</code>) in OP-TEE; and explain how SCMI clocks work</p>
<h4 id="boot-process-from-tf-a-to-op-tee-to-linux">Boot process from TF-A to OP-TEE to Linux</h4>
<p>When Arm Trusted Firmware (TF-A) is done with its own initialization, it loads
several images into memory. In the STM32MP1 case, these are defined in the
array <code>bl2_mem_params_desc</code> in file
<code>plat/st/stm32mp1/plat_bl2_mem_params_desc.c</code>, and include the following:</p>
<ul>
<li>
<p><code>FW_CONFIG_ID</code>: firmware config, which is mostly just the information on</p>
</li>
</ul>
<p>TrustZone memory regions that is used by TF-A itself</p>
<ul>
<li>
<p><code>BL32_IMAGE_ID</code>: the OP-TEE executable</p>
</li>
</ul>
<ul>
<li>
<p><code>BL32_EXTRA1_IMAGE_ID</code>, <code>BL32_EXTRA2_IMAGE_ID</code>, and <code>TOS_FW_CONFIG_ID</code>: some
stuff needed by OP-TEE</p>
</li>
</ul>
<ul>
<li>
<p><code>BL33_IMAGE_ID</code>: the non-trusted bootloader (U-Boot) or directly Linux itself,
if operating in the “falcon mode”</p>
</li>
</ul>
<ul>
<li>
<p><code>HW_CONFIG_ID</code>: the Device Tree Blob (DTB) used by U-Boot or Linux, whichever
is run as “BL33”</p>
</li>
</ul>
<p>Just before passing control to OP-TEE, the TF-A prints a couple messages in the
<code>bl2_main()</code> function (<code>bl2/bl2_main.c</code>), and then runs <code>bl2_run_next_image</code>
(<code>bl2/aarch32/bl2_run_next_image.S</code>). There, we disable MMU, put the OP-TEE
entry address into the link register (either <code>lr</code> or <code>lr_svc</code>), load the <code>SPSR</code>
register, and then do an “exception return” to atomically change the program
counter to the link register value, and restore the Current Program Status
Register (<code>CPSR</code>) from the Saved Program Status Register (<code>SPSR</code>).</p>
<h4 id="how-do-secure-monitor-calls-smc-work">How do secure monitor calls (SMC) work?</h4>
<p>The ARMv7-A architecture provides optional TrustZone extension, which are
implemented on the STM32MP135 chips (as well as the virtualisation
extension). In this scheme, the processor is at all times executing in one of
two “worlds”, either the secure or the non-secure one.</p>
<p>The <code>NS</code> bit of the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/SCR--Secure-Configuration-Register--Security-Extensions?lang=en"><code>SCR</code></a>
register defines which world we’re currently in. If <code>NS=1</code>, we are in non-secure
world, otherwise we’re in the secure world. The one exception to this is that
when the processor is running in
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/The-System-Level-Programmers--Model/ARM-processor-modes-and-ARM-core-registers/ARM-processor-modes?lang=en#CIHGHDGI">Monitor mode</a>;
in that case, the code is executing the secure world and <code>SCR.NS</code> merely
indicates which world the processor was in before entering the Monitor mode.
(The current processor mode is given by the <code>M</code> bits of the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/The-System-Level-Programmers--Model/ARM-processor-modes-and-ARM-core-registers/Program-Status-Registers--PSRs-?lang=en#CIHBFGJG"><code>CPSR</code></a>
register.)</p>
<p>The processor starts execution in the secure world. How do we transition to the
non-secure world? Outside of Monitor mode, Arm does not recommend direct
manipulation of the <code>SCR.NS</code> bit to change from the secure world to the
non-secure world or vice versa. Instead, the right way is to first change into
Monitor mode, flip the <code>SCR.NS</code> bit, and leave monitor mode. To enter Monitor
mode, execute the <code>SMC</code> instruction. This triggers the SMC exception, and the
processor begins executing the SMC handler.</p>
<p>The location of the SMC handler has to be previously stored in the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions--in-register-order/MVBAR--Monitor-Vector-Base-Address-Register--Security-Extensions"><code>MVBAR</code> register</a>.
The initial setup required is as follows:</p>
<ol>
<li>
<p>Write a SMC handler. As an example, consult OP-TEE source code, which
provides the handler <code>sm_smc_entry</code>, defined in <code>core/arch/arm/sm/sm_a32.S</code>.</p>
</li>
</ol>
<ol>
<li>
<p>Create a vector table for monitor mode. As specified in the
<a href="https://developer.arm.com/documentation/ddi0406/b/System-Level-Architecture/The-System-Level-Programmers--Model/Exceptions/Exception-vectors-and-the-exception-base-address?lang=en">Arm architecture</a>
manual, the monitor vector table has eight entries:</p>
<ol>
<li>
<p>Unused</p>
</li>
<li>
<p>Unused</p>
</li>
<li>
<p>Secure Monitor Call (SMC) handler</p>
</li>
<li>
<p>Prefetch Abort handler</p>
</li>
<li>
<p>Data Abort handler</p>
</li>
<li>
<p>Unused</p>
</li>
<li>
<p><code>IRQ</code> interrupt handler</p>
</li>
<li>
<p><code>FIQ</code> interrupt handler</p>
</li>
</ol>
<p>Obviously entry number 3 has to point to the SMC handler defined previously.
For example, OP-TEE defines the following vector table in
<code>core/arch/arm/sm/sm_a32.S</code>:</p>
<pre><code>LOCAL_FUNC sm_vect_table , :, align=32
UNWIND(	.cantunwind)
<pre><code>b	.		/* Reset			*/
b	.		/* Undefined instruction	*/
b	sm_smc_entry	/* Secure monitor call		*/
b	.		/* Prefetch abort		*/
b	.		/* Data abort			*/
b	.		/* Reserved			*/
b	.		/* IRQ				*/
b	sm_fiq_entry	/* FIQ				*/</code></pre>
<p>END<em>FUNC sm</em>vect_table</p></code></pre>
<p>We see only the SMC and <code>FIQ</code> handlers are installed, since OP-TEE setup
disables all other Monitor-mode interrupts and exceptions.</p>
</li>
</ol>
<ol>
<li>
<p>Install the vector table to the <code>MVBAR</code> register. The OP-TEE source code
defines the following macros in <code>out/core/include/generated/arm32_sysreg.h</code>:</p>
<pre><code>/* Monitor Vector Base Address Register */
static inline __noprof uint32_t read_mvbar(void)
{
<pre><code>uint32_t v;&lt;/code&gt;&lt;/pre&gt;</code></pre>
<pre><code>	asm volatile ("mrc p15, 0, %0, c12, c0, 1" : "=r"  (v));</code></pre>
<pre><code>	return v;
}</code></pre>
<pre><code>/* Monitor Vector Base Address Register */
static inline __noprof void write_mvbar(uint32_t v)
{
<pre><code>asm volatile (&amp;quot;mcr p15, 0, %0, c12, c0, 1&amp;quot; : : &amp;quot;r&amp;quot;  (v));</code></pre>
<p>}</p></code></pre>
<p>This merely follows the Arm manual on how to access the
<a href="https://developer.arm.com/documentation/ddi0406/c/System-Level-Architecture/System-Control-Registers-in-a-VMSA-implementation/VMSA-System-control-registers-descriptions–in-register-order/MVBAR–Monitor-Vector-Base-Address-Register–Security-Extensions"><code>MVBAR</code> register</a>.</p>
</code></pre></li>
</ol>
<p>With this setup in place, to transition from the secure world to the non-secure
world, the steps are as follows:</p>
<ol>
<li>
<p>Place the arguments to the SMC handler into registers <code>r0</code> through <code>r4</code> (or
as many as are needed by the handler), and execute the SMC instruction. For
example, just before passing control to the non-secure world, OP-TEE
<code>reset_primary</code> function (called from the <code>_start</code> function) does the
following:</p>
<pre><code>mov	r4, #0
mov	r3, r6
mov	r2, r7
mov	r1, #0
mov	r0, #TEESMC_OPTEED_RETURN_ENTRY_DONE
smc	#0</code></pre>
</li>
</ol>
<ol>
<li>
<p>This puts the processor into Monitor mode, and it begins execution at the
previously-installed SMC handler. The handler stores secure-mode registers
into some memory location for future use, then sets the <code>SCR.NS</code> bit:</p>
<pre><code>read_scr r0
orr	r0, r0, #(SCR_NS | SCR_FIQ) /* Set NS and FIQ bit in SCR */
write_scr r0</code></pre>
<p>This also sets the <code>SCR.FIQ</code> bit, which means that <code>FIQ</code> interrupts are also
taken to Monitor mode. In this way, OP-TEE assigns <code>IRQ</code> interrupts to the
non-secure world, and <code>FIQ</code> interrupts to the secure-world. Of course, this
means that the Monitor-mode vector table needs a <code>FIQ</code> handler (as mentioned
in passing above), and the system interrupt handler (GIC on STM32MP135) needs
to be configured to pass “secure” interrupts as <code>FIQ</code>.</p>
</li>
</ol>
<ol>
<li>
<p>After adjusting the stack pointer and restoring the non-secure register
values from the stack, the SMC handler returns:</p>
<pre><code>add	sp, sp, #(SM_CTX_NSEC + SM_NSEC_CTX_R0)
pop	{r0-r7}
rfefd	sp!</code></pre>
<p>The return location and processor mode is stored on the stack and
automatically retrieved by the <code>rfefd sp!</code> instruction. Of course this means
they have to be previously stored in the right place on the stack; see
<code>sm_smc_entry</code> source code for details.</p>
</li>
</ol>
<h4 id="secure-interrupts-in-op-tee">Secure interrupts in OP-TEE</h4>
<p>As mentioned above, OP-TEE code, before returning to non-secure mode, enables
the <code>SCR.FIQ</code> bit, which means that <code>FIQ</code> interrupts get taken to Monitor mode,
serviced by the <code>FIQ</code> handler that is installed in the Monitor-mode vector table
(the table address is stored in the <code>MVBAR</code> register).</p>
<p>As mentioned above, an arbitrary number of system interrupts may be passed as a
<code>FIQ</code> to the processor core. OP-TEE handles these interrupts in <code>itr_handle()</code>
(defined in <code>core/kernel/interrupt.c</code>). The individual interrupt handlers are
stored in a linked list, which <code>itr_handle()</code> traverses until it finds a handler
whose interrupt number (<code>h-&gt;it</code>) matches the given interrupt.</p>
<p>For example, the handler for the <code>TZC</code> interrupt (TrustZone memory protection)
is defined in <code>core/arch/arm/plat-stm32mp1/plat_tzc400.c</code>, as the
<code>tzc_it_handler()</code> function.</p>
<h4 id="how-do-scmi-clocks-work">How do SCMI clocks work?</h4>
<p>In general, to configure clocks, Linux uses the
<a href="https://www.kernel.org/doc/Documentation/clk.txt">Common Clock Framework</a>. Each
clock needs to define some common operations, such as <code>enable()</code>, <code>disable()</code>,
<code>set_rate()</code>, and so on, as relevant to each particular clock.</p>
<p>Since in the ST-recommended scheme the clock configuration is done entirely in
the secure world, the STM32MP135 clock drivers
(<code>drivers/clk/stm32/clk-strm32mp13.c</code>) make use of the SCMI clock driver
(<code>drivers/clk/clk/scmi.c</code>). The latter provides a translation from the common
clock functions to SCMI functions. For example, <code>enable()</code> is implemented as
follows:</p>
<pre><code>static int scmi_clk_enable(struct clk_hw *hw)
{
	struct scmi_clk *clk = to_scmi_clk(hw);
	return scmi_proto_clk_ops-&gt;enable(clk-&gt;ph, clk-&gt;id);
}</code></pre>
<p>This is just a wrapper around the SCMI clock enable function, as found in the
<code>scmi_proto_clk_ops</code> structure (which contains all the SCMI-protocol clock
operations).</p>
<p>At Linux boot, when the SCMI clock driver is being “probed”, it asks OP-TEE
about the number of supported clocks, and then retrieves information about each
one in sequence. Thus it acquires a list of clocks, with a header file defining
the sequential ID numbers (<code>include/dt-bindings/clock/stm32mp13-clks.h</code>):</p>
<pre><code>/* SCMI clock identifiers */
#define CK_SCMI_HSE		0
#define CK_SCMI_HSI		1
#define CK_SCMI_CSI		2
#define CK_SCMI_LSE		3
#define CK_SCMI_LSI		4
#define CK_SCMI_HSE_DIV2	5
#define CK_SCMI_PLL2_Q		6
#define CK_SCMI_PLL2_R		7
#define CK_SCMI_PLL3_P		8
#define CK_SCMI_PLL3_Q		9
#define CK_SCMI_PLL3_R		10
#define CK_SCMI_PLL4_P		11
#define CK_SCMI_PLL4_Q		12
#define CK_SCMI_PLL4_R		13
#define CK_SCMI_MPU		14
#define CK_SCMI_AXI		15
#define CK_SCMI_MLAHB		16
#define CK_SCMI_CKPER		17
#define CK_SCMI_PCLK1		18
#define CK_SCMI_PCLK2		19
#define CK_SCMI_PCLK3		20
#define CK_SCMI_PCLK4		21
#define CK_SCMI_PCLK5		22
#define CK_SCMI_PCLK6		23
#define CK_SCMI_CKTIMG1		24
#define CK_SCMI_CKTIMG2		25
#define CK_SCMI_CKTIMG3		26
#define CK_SCMI_RTC		27
#define CK_SCMI_RTCAPB		28</code></pre>
<p>(There must be some way to ensure that the same sequential number is used in
 Linux as in OP-TEE, or else the clocks would get confused. Presumably the same
 header file is used in Linux as in OP-TEE.)</p>
<p>The SCMI clock numbers are then used in device trees. For example, in
<code>core/arch/arm/dts/stm32mp131.dtsi</code>, we see some of these constants being used:</p>
<pre><code>rcc: rcc@50000000 {
	compatible = "st,stm32mp13-rcc", "syscon";
	reg = &lt;0x50000000 0x1000&gt;;
	#clock-cells = &lt;1&gt;;
	#reset-cells = &lt;1&gt;;
	clock-names = "hse", "hsi", "csi", "lse", "lsi";
	clocks = &lt;&amp;scmi_clk CK_SCMI_HSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_HSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_CSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSI&gt;;
};</code></pre>
<p>Thus, when the driver compatible with <code>"st,stm32mp13-rcc"</code> (implemented in
<code>drivers/clk/stm32/clk-stm32mp13.c</code>) needs to refer to its <code>"hse"</code> clock, it
calls the <code>scmi_clk</code> and gives it the <code>CK_SCMI_HSE</code> parameter. Recall that
<code>scmi_clk</code> is defined in the same <code>DTSI</code> file, under <code>firmware</code> / <code>scmi</code>:</p>
<pre><code>scmi_clk: protocol@14 {
	reg = &lt;0x14&gt;;
	#clock-cells = &lt;1&gt;;
};</code></pre>
<p>There are some SCMI clocks, however, which are used by the <code>"st,stm32mp13-rcc"</code>
driver, which are not listed in the device tree. For example, in
<code>drivers/clk/stm32/clk-stm32mp13.c</code> we find many definitions such as the
following:</p>
<pre><code>static const char * const sdmmc12_src[] = {
	"ck_axi", "pll3_r", "pll4_p", "ck_hsi"
};</code></pre>
<p>Here <code>ck_axi</code>, <code>pll3_r</code>, etc., refer to SCMI clocks, but these are not mentioned
in the device tree. How can the kernel find them? The way it works is that
during SCMI clock driver initialization, the driver registers these clocks (and
others as per the listing from the <code>stm32mp13-clks.h</code> header file above). When,
later, the <code>"st,stm32mp13-rcc"</code> driver is being initialized, it is able to refer
to these clocks simply by their name.</p>
<p>This means that the SCMI driver needs to be probed before the <code>RCC</code> driver. To
ensure this, note the following part of the device tree:</p>
<pre><code>rcc: rcc@50000000 {
    ...
	clocks = &lt;&amp;scmi_clk CK_SCMI_HSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_HSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_CSI&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSE&gt;,
		 &lt;&amp;scmi_clk CK_SCMI_LSI&gt;;
};</code></pre>
<p>The reference to SCMI clocks here does not mean that these particular clocks
(<code>HSE,</code> <code>HSI,</code> <code>CSI,</code> <code>LSE,</code> <code>LSI)</code> are used by the <code>RCC</code> driver. Rather, it
ensures that the SCMI clock driver is a dependency of the <code>RCC</code> driver, and gets
initialized first. It would have been much nicer if the device tree <code>RCC</code> node
listed all the clocks that are used by <code>RCC</code> rather than just referring to them
by their name string (such as <code>"pll3_r"</code>), but that’s the way ST implemented
things. In particular, this means that if we unset the <code>CONFIG_COMMON_CLK_SCMI</code>
entry in the kernel configuration, the kernel will no longer boot, without
printing any error message at all; the <code>RCC</code> driver will fail to work properly
since it can no longer refer to many of the clocks it needs by their name
string.</p>
<p>There is no need to understand SCMI clocks further, so long as we can replace
them all with “real” clocks, with registers under direct control of the <code>RCC</code>
driver from the Linux kernel.</p>
<h3 id="discussion">Discussion</h3>
<p>STM32MP135 presents an SDK that is, to my mind, overly complicated. To port the
setup from the evaluation board to a new board requires the understanding of
three bootloaders (ROM, TF-A, U-Boot), two operating systems (Linux, OP-TEE),
and a stack of other software. Most of this arose out of a desire to simplify
the process; for example, U-Boot aims to be the one universal bootloader in
embedded systems, so as to not have to learn a new one for each platform. But
the ironic end result is that after piling on so many “simplifications”, the net
result is more complicated than having none of them.</p>
<p>The claim that OP-TEE is mandatory probably arises out of a desire to avoid
having to maintain two separate development branches, a secure and a non-secure
one. This must be even more so considering the need to support the GUI-based
configuration utilities (STM32Cube), or the Yocto-based distributions.</p>
<p>However, as a developer I would prefer to be offered a minimal working
configuration where OP-TEE would be an “opt-in” configuration, rather than
tightly bundling it in with the kernel. Many (most?) applications do not call
for secure-world services; these get included only due to the large cost of
<em>removing</em> it from the provided SDKs.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>09/26/2025: I have made the modifications available in the repository
<a href="https://github.com/js216/stm32mp135_simple"><code>stm32mp135_simple</code></a>, as mentioned
in the quick tutorial above. I do not at present have the intention of
upstreaming it, since it would involve a lot of effort updating it to the latest
version of Buildroot (or TF-A and Linux), only to watch it become obsolete again
during the upstreaming process.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><em>5. This article</em></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
<hr/><section class="footnotes"><ol><li id="fn-6666672e-wiki" value="1">ST wiki: <a href="https://wiki.st.com/stm32mpu/wiki/How_to_disable_OP-TEE_secure_services">How to disable OP-TEE secure services</a> <a href="#fnref-6666672e-wiki">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Incoherent Thoughts</div>
<h2><a href="action-without-clinging">Action Without Clinging</a></h2>
<div class="article-meta">Published 21 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/blue.jpg"/></p>
<p>Decisions are illusions, especially difficult decisions. In reality, the only
choice available is to sit back and watch events unfold; there is only one way
in which they will unfold (at least in this universe), and that’s the way things
are going to be.</p>
<p>Action must flow out of detachment from the “human” world of “I” and “mine”; it
must be free from thoughts of control, achievement, and getting things done.
Instead, the mind must be free to operate on the level of the mind, free to go
where mind goes. There is no thought of goal as effect; the mind knows what it
is doing when allowed so.</p>
<p>This is not passivity but a kind of wu wei—acting without forcing.</p>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="linux-tfa-bl33-qemu">Linux as TF-A BL33 on Qemu (No U-Boot)</a></h2>
<div class="article-meta">Published 15 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1.jpg"/></p>
<p><em>This is Part 4 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>With Qemu, anyone can customize the Linux boot process and run it without the
need for custom hardware. In this article, we will adapt a Buildroot defconfig
to make TF-A boot Linux and OP-TEE directly without U-Boot.</p>
<p>This approach was suggested by A. Vandecappelle on the Buildroot mailing
list<sup class="footnote-ref"><a href="#fn-388eb7d9-list" id="fnref-388eb7d9-list">[1]</a></sup>. He was correct to point out that it would be
interesting to see a Qemu simulation of the “Falcon mode” boot process:</p>
<blockquote>
<p>Perhaps it would also be a good idea to add a variant of the qemu defconfigs
that tests this option. We can use the <code>qemu_arm_vexpress_tz_defconfig</code>, drop
U-Boot from it, and switch to booting to Linux directly from TF-A.</p>
</blockquote>
<p>First, we will look at the “normal” boot process with U-Boot to understand how
to remove it. Then, we will provide tutorial-style steps to remove U-Boot from
the boot process. Then, we suggest with how to integrate this into Buildroot. We
conclude with a discussion of alternative approaches.</p>
<h3 id="normal-boot-process">“Normal” boot process</h3>
<p>In the <code>qemu_arm_vexpress_tz_defconfig</code> defconfig, Qemu is instructed to load
Arm Trusted Firmware (TF-A) as “<code>bios</code>“. Qemu auto-generates a Device Tree Blob
(DTB) and loads it in memory at the start of RAM. As the Qemu
documentation<sup class="footnote-ref"><a href="#fn-388eb7d9-qemu" id="fnref-388eb7d9-qemu">[2]</a></sup> explains:</p>
<blockquote>
<ul>
<li>
<p>For guests using the Linux kernel boot protocol (this means any non-ELF file
passed to the QEMU <code>-kernel</code> option) the address of the DTB is passed in a
register (<code>r2</code> for 32-bit guests, or <code>x0</code> for 64-bit guests)</p>
</li>
</ul>
<ul>
<li>
<p>For guests booting as “bare-metal” (any other kind of boot), the DTB is at
the start of RAM (<code>0x4000_0000</code>)</p>
</li>
</ul>
</blockquote>
<p>In our case, TF-A is booted in the “bare-metal” mode. We can see in file
<code>plat/qemu/qemu/include/platform_def.h</code> that this is so:</p>
<div class="codehilite"><pre><code class="language-text">#define PLAT_QEMU_DT_BASE           NS_DRAM0_BASE</code></pre></div>
<p>TF-A patches the Qemu-provided DTB by inserting the information about the
reserved memory addresses used by the secure OS (OP-TEE), as well as the
protocol (PSCI) that Linux is to use to communicate with OP-TEE. Then, it passes
control to U-Boot.</p>
<p>U-Boot only task in this configuration, as far as I can tell, is to load the
initial compressed filesystem image into some range of memory addresses, then
patch the DTB with these addresses. Then, it passes control to the Linux kernel.</p>
<p>Linux reads the DTB, either from the address given in register r2 or perhaps
from the pre-defined memory location (not sure). Then, it reads the
<code>initrd-start</code> location from the <code>chosen</code> node, decompresses the filesystem,
locates the init process, and runs it.</p>
<p>Thus to remove U-Boot, we just have to load the initramfs ourselves, and add its
address to the DTB. Of course, we must also tell TF-A to not load the U-Boot and
instead run Linux directly. In the following section, we explain how to do that.</p>
<h3 id="falcon-mode-tutorial">Falcon-mode tutorial</h3>
<ol>
<li>
<p>Obtain Buildroot and check out and build the defconfig that we’re starting
from:</p>
<div class="codehilite"><pre><code class="language-text">    $ git clone https://gitlab.com/buildroot.org/buildroot.git --depth=1
    $ make qemu_arm_vexpress_tz_defconfig
    $ make</code></pre></div>
<p>This builds everything and gives the script <code>start_qemu.sh</code> (under
<code>output/images</code>) with the suggested Qemu command line.</p>
</li>
</ol>
<ol>
<li>
<p>Extract the DTB by modifying the Qemu command as follows (note the
<code>dumpdtb=qemu.dtb</code>):</p>
<div class="codehilite"><pre><code class="language-text">   $ qemu-system-arm -machine virt,dumpdtb=qemu.dtb -cpu cortex-a15</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Uncompile the DTB into the source format so we can edit it:</p>
<div class="codehilite"><pre><code class="language-text">   $ dtc -I dtb -O dts qemu.dtb &gt; new.dts</code></pre></div>
<p>Open <code>new.dts</code> in a text editor and modify the <code>chosen</code> node as follows,
adding the location of the initramfs (initrd):</p>
<div class="codehilite"><pre><code class="language-text">   chosen {
   	linux,initrd-end = &lt;0x00 0x7666e09d&gt;;
   	linux,initrd-start = &lt;0x00 0x76000040&gt;;
   	bootargs = "test console=ttyAMA0,115200 earlyprintk=serial,ttyAMA0,115200";
   	stdout-path = "/pl011@9000000";
   };</code></pre></div>
<p>Compile it back into the DTB format:</p>
<div class="codehilite"><pre><code class="language-text">   dtc -I dts -O dtb new.dts &gt; new.dtb</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Open <code>make menuconfig</code> and navigate to <code>Bootloaders ---&gt; Arm Trusted Firmware
(ATF)</code>. Switch the BL33 to <code>None</code>, and add the following Additional ATF build
variables:</p>
<div class="codehilite"><pre><code class="language-text">   BL33=$(BINARIES_DIR)/zImage</code></pre></div>
<p>Exit and save new configuration and rebuild:</p>
<div class="codehilite"><pre><code class="language-text">   $ make arm-trusted-firmware-rebuild
   $ make</code></pre></div>
<p>Check that <code>output/images</code> contains updated <code>fip.bin</code>, which should be about
5 or 6M in size since it contains the whole kernel rather than just U-Boot.</p>
</li>
</ol>
<ol>
<li>
<p>Run Qemu with the following commands:</p>
<div class="codehilite"><pre><code class="language-text">   $ cd output/images
   $ exec qemu-system-arm -machine virt -dtb art.dtb -device \
        loader,file=rootfs.cpio.gz,addr=0x76000040 -machine secure=on -cpu \
        cortex-a15 -smp 1 -s -m 1024 -d unimp -netdev user,id=vmnic -device \
        virtio-net-device,netdev=vmnic -nographic \
        -semihosting-config enable=on,target=native -bios flash.bin</code></pre></div>
<p>This is of course just the old command from <code>start-qemu.sh</code>, with the DTB and
initramfs added. With some luck, you should see messages from TF-A directly
transitioning into the ones from the kernel, with no U-Boot in between:</p>
<div class="codehilite"><pre><code class="language-text">   NOTICE:  Booting Trusted Firmware
   NOTICE:  BL1: v2.7(release):v2.7
   NOTICE:  BL1: Built : 20:55:52, Sep 12 2025
   NOTICE:  BL1: Booting BL2
   NOTICE:  BL2: v2.7(release):v2.7
   NOTICE:  BL2: Built : 20:55:52, Sep 12 2025
   NOTICE:  BL1: Booting BL32
   Booting Linux on physical CPU 0x0
   Linux version 6.12.27 (jk@Lutien) (arm-buildroot-linux-gnueabihf-gcc.br_real (Buildroot -g5b6b80bf) 14.3.0, GNU ld (GNU Binutils) 2.43.1) #2 SMP Fri Sep 12 20:03:32 PDT 2025
   CPU: ARMv7 Processor [414fc0f0] revision 0 (ARMv7), cr=10c5387d
   CPU: div instructions available: patching division code
   CPU: PIPT / VIPT nonaliasing data cache, PIPT instruction cache
   OF: fdt: Machine model: linux,dummy-virt
   OF: fdt: Ignoring memory range 0x40000000 - 0x60000000</code></pre></div>
</li>
</ol>
<h3 id="tf-a-support-for-linux-as-bl33">TF-A support for Linux as BL33</h3>
<p>We saw above that TF-A is happy to boot Linux directly so long as we just point
it to a kernel image for the BL33 executable. It turns out that there we can
find limited support for this use case already in the TF-A source tree via the
<code>ARM_LINUX_KERNEL_AS_BL33</code> flag.</p>
<p>The flag is specific to a few platforms. For AArch64 on Qemu, the documentation
(<code>docs/plat/qemu.rst</code>, as well as <code>docs/plat/arm/arm-build-options.rst</code>)
explains that the flag makes TF-A pass the Qemu-generated DTB to the kernel via
the <code>x0</code> register. We see the implementation of it in
<code>plat/qemu/common/qemu_bl2_setup.c</code> (and very similar lines in
<code>plat/arm/common/arm_bl31_setup.c</code>):</p>
<div class="codehilite"><pre><code class="language-c"><span class="cp">#if</span> ARM_LINUX_KERNEL_AS_BL33
		<span class="cm">/*
		 * According to the file ``Documentation/arm64/booting.txt`` of
		 * the Linux kernel tree, Linux expects the physical address of
		 * the device tree blob (DTB) in x0, while x1-x3 are reserved
		 * for future use and must be 0.
		 */</span>
		bl_mem_params<span class="o">-</span><span class="o">&gt;</span>ep_info.args.arg0 <span class="o">=</span>
			(u_register_t)ARM_PRELOADED_DTB_BASE;
		bl_mem_params<span class="o">-</span><span class="o">&gt;</span>ep_info.args.arg1 <span class="o">=</span> 0U;
		bl_mem_params<span class="o">-</span><span class="o">&gt;</span>ep_info.args.arg2 <span class="o">=</span> 0U;
		bl_mem_params<span class="o">-</span><span class="o">&gt;</span>ep_info.args.arg3 <span class="o">=</span> 0U;</code></pre></div>
<p>On AArch32, the flag as currently implemented is intended for operation with
<code>SP_MIN</code>. This is clear from the documentation: “for AArch32 `<code>RESET_TO_SP_MIN</code><code>
must be 1 when using" the </code>ARM<em>LINUX</em>KERNEL<em>AS</em>BL33<code> flag
(</code>docs/plat/arm/arm-build-options.rst<code>). The </code>plat/arm/common/arm_common.mk`
Makefile enforces this.</p>
<p>Unfortunately this limits the potential use cases of <code>ARM_LINUX_KERNEL_AS_BL33</code>
to AArch64, or else to AArch32 with <code>SP_MIN</code> enabled. The Buildroot defconfig we
have adapted in the previous section uses OP-TEE instead of <code>SP_MIN</code>, and it is
also possible to use no BL32 at all.</p>
<h3 id="patching-initramfs-address">Patching initramfs address</h3>
<p>In the tutorial above, we dumped the Qemu DTB and modified it just to add two
lines into the <code>chosen</code> node. The same can be done by TF-A.</p>
<p>The file <code>plat/qemu/common/qemu_bl2_setup.c</code> defines the function <code>update_dt()</code>
which is used for precisely this purpose, updating the DTB with some extra
board-specific details. (In the defconfig, it inserts PSCI nodes.)</p>
<p>We can insert the two <code>chosen</code> lines in the middle of <code>update_dt()</code>:</p>
<div class="codehilite"><pre><code class="language-c"><span class="nf">fdt_setprop_u64</span>(fdt, <span class="nf">fdt_path_offset</span>(fdt, <span class="s">"/chosen"</span>),
        <span class="s">"linux,initrd-start"</span>, <span class="m">0x76000040</span>);
<span class="nf">fdt_setprop_u64</span>(fdt, <span class="nf">fdt_path_offset</span>(fdt, <span class="s">"/chosen"</span>),
        <span class="s">"linux,initrd-end"</span>,   <span class="m">0x7666e09d</span>);</code></pre></div>
<p>On recompile, there is no need to manually modify the DTB anymore.</p>
<p>The disadvantage of this approach is that we have to patch TF-A, making our
defconfig fragile against future changes in TF-A. It would be better to include
that DTB compilation as a post-build script in Buildroot.</p>
<h3 id="discussion">Discussion</h3>
<p>Is it practical to assume that the initramfs will be loaded in memory before
TF-A even starts executing? Of course not. But on a real embedded platform, such
as the setup from the <a href="stm32mp135-without-u-boot">previous article</a>, the root
filesystem is the SD card or some other non-volatile storage. There appears to
be no good reason to use U-Boot since TF-A can read from these just fine. If, on
the other hand, your setup requires some complicated configuration of the root
filesystem, possibly involving Ethernet, then U-Boot may well be a good choice.
Still, I believe that the best tool for the job is the simplest one that works
reliably.</p>
<p>It is also not reasonable to assume that the DTB would be loaded in memory
before TF-A even begins execution. After all, as the only bootloader, it is its
job to load it and point the kernel to where it loaded it. As P. Maydell
explains on the qemu-discuss mailing list<sup class="footnote-ref"><a href="#fn-388eb7d9-disc" id="fnref-388eb7d9-disc">[3]</a></sup>, providing the <code>-dtb</code> option to
Qemu “overrides the autogenerated file. But generally you shouldn’t do that.”
Instead, the Qemu user should provide the DTB, if emulating real hardware, or
else to have the Qemu</p>
<blockquote>
<p>autogenerate the DTB matching whatever it does, like the virt board. This is
the unusual case – virt only does this because it is a purely “virtual” board
that doesn’t match any real physical hardware and which changes depending on
what the user asked for.</p>
</blockquote>
<p>For example, on STM32MP1, the TF-A <code>fiptool</code> is used to package the DTB in a
form that TF-A is able to load it in memory using the <code>BL33_CFG</code> flag, as we
have used in <a href="stm32mp135-without-u-boot">previous article</a>.</p>
<p>There may be other ways to load the DTB and initramfs in Qemu, but the one
presented in our tutorial above appears to be the easiest. We could, for
example, modify Qemu to allow using the <code>-initrd</code> command line flag without the
<code>-kernel</code> flag, and emit the DTB with the appropriate address. Or, we could
teach TF-A how to read the initramfs file via the semihosting or virtio
protocols, load it into memory, and modify the DTB accordingly.</p>
<p>However, the tutorial method above works without modifying Qemu or TF-A code. It
uses an explicit DTB, as one is likely to do on a physical embedded target.
Since it passes the initramfs using an explicit command line option, it avoids
hard-coding it into any compiled code.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>17/9/2025: first submission of the Qemu defconfig
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786597.html">(link)</a></p>
<p>02/03/2026: response by Thomas Petazzoni
<a href="https://lists.buildroot.org/pipermail/buildroot/2026-February/796037.html">(link)</a></p>
<p>02/04/2026: amended submission as a runtime test
<a href="https://lists.buildroot.org/pipermail/buildroot/2026-February/796454.html">(link)</a></p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><em>4. This article</em></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
<hr/><section class="footnotes"><ol><li id="fn-388eb7d9-list" value="1">Buildroot mailing list, Fri May 16 2025 message: <a href="https://lists.buildroot.org/pipermail/buildroot/2025-May/778563.html">boot/arm-trusted-firmware: optional Linux as BL33</a> (cited on 09/15/2025)  <a href="#fnref-388eb7d9-list">↩</a></li><li id="fn-388eb7d9-qemu" value="2"> Qemu: <a href="https://www.qemu.org/docs/master/system/arm/virt.html#hardware-configuration-information-for-bare-metal-programming">‘virt’ generic virtual platform</a> (cited 09/15/2025).  <a href="#fnref-388eb7d9-qemu">↩</a></li><li id="fn-388eb7d9-disc" value="3">qemu-discuss mailing list, Thu 4 Aug 2022 message: <a href="https://lists.gnu.org/archive/html/qemu-discuss/2022-08/msg00007.html">Re: how to prevent automatic dtb load?</a> (cited 09/15/2025) <a href="#fnref-388eb7d9-disc">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="false-promise-of-dead-code-elimination">Dead Code Elimination is a False Promise</a></h2>
<div class="article-meta">Published 14 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/sq.jpg"/></p>
<p>Go through the source of any nontrivial program and chances are, most of the
code in there is used very rarely, and a lot if it may never be used. This is
the more so if a program is supposed to be very portable, such as in the Linux
kernel. Of course, compilers will eliminate it, so there’s no problem?</p>
<h3 id="the-problem">The Problem</h3>
<p>Compilers are supposed to detect what’s not being used, and remove the code.
They don’t do that. For example, processing one “compilation unit” at a time, a
C compiler has no idea which functions will be referenced to from other units
and which are entirely dead. (If the function is declared static, this <em>does</em>
work, so declare as many of them static.)</p>
<p>Surely by the time the linker is invoked, all the function calls are clear and
the rest can be stripped away? Also not likely. For example, the function calls
could be computed during runtime as casts of integers into function pointers. If
the linker were to remove them, this mechanism would fail. So long as several
functions are compiled into the same section, the linker will always include all
of them so long as at least one of them is used.</p>
<p>What if we instead explicitly mark which things we would like excluded?</p>
<h3 id="conditional-compilation">Conditional Compilation</h3>
<p>With conditional compilation, you can include/exclude whatever you want. When a
program has these conditional compilation switches, dead code <em>does</em> get
entirely deleted before the compiler even sees it. Most often, the result is a
myriad of poorly-documented (more likely: entirely undocumented) switches that
you don’t know what you’re allowed to disable.</p>
<p>For example, the Linux kernel provides the amazing menuconfig tool to manage
these inclusions and exclusions. Still, it can take days of work trying out
disabling and re-enabling things, till you give up and wisely conclude that this
“premature optimization” is not worth your time and leave everything turned on
as it is by default.</p>
<h3 id="packages">“Packages”</h3>
<p>The sad reality of modern scripting languages, and even compiled ones like Rust,
is that their robust ecosystems of packages and libraries encourage wholesale
inclusion of code whose size is entirely out of proportion to the task they
perform. (Don’t even mention <a href="https://harmful.cat-v.org/software/dynamic-linking/">shared
libraries</a>.)</p>
<p>As an example, let’s try out the popular Rust GUI library
<a href="https://github.com/emilk/egui">egui</a>. According to its Readme, it is modular,
so you can use small parts of egui as needed, and comes with “minimal
dependencies”. Just what we need to make a tiny app! Okay, first we need Rust
itself:</p>
<div class="codehilite"><pre><code class="language-text">$ curl --proto ‘=https’ --tlsv1.2 -sSf https://sh.rustup.rs | sh
$ du -hs .rustup .cargo
1.3G    .rustup
20M     .cargo</code></pre></div>
<p>So far so good—the entire compiler and toolchain fits inside 1.3G, and we
start with 20M of packages. Now let’s clone the GUI library and compile its
simple example with a couple really simple widgets:</p>
<div class="codehilite"><pre><code class="language-text">$ git clone git@github.com:emilk/egui.git
$ cd egui/examples/hello_world_simple
$ cargo run -p hello_world_simple
$ cd &amp;&amp; du -hs .rustup .cargo
2.6G    .rustup
210M    .cargo</code></pre></div>
<p>Oops! How many gigabytes of code does it take to show a couple characters and
rectangles on the screen? Besides, the above took more than 20 min to complete
on a machine vastly superior to the Cray-2 supercomputer. The compiled program
was 236M in size, or 16M after stripping. Everyday We Stray Further ...</p>
<p>This is far from being a “freak” example; even the simplest tasks in Rust and
Python and pretty much anything else considered “modern” will pull in gigabytes
of “essential” packages.</p>
<p>Packages get inextricably linked with the main program, resulting in an
exponential explosion of complexity (besides the linear growth in size). Once
linked, the program and its libraries/packages are no longer separate modules;
you cannot simply replace a library for a different one, despite the host of
false promises from the OOP crowd.</p>
<p>This is because the interfaces between these modules are very complex: hundreds
or thousands of function calls, complex object operations, &amp;c.</p>
<h3 id="the-solution">The Solution</h3>
<p>The only way I know of that works is to not have dead code to begin with.
Extra features should be strictly opt-in, not opt-out. These should be
implemented with separate compilation <em>and</em> linking; in other words, each
feature is a new program, not a library.</p>
<p>The objection may be raised that we’re advocating an extremely inefficient
paradigm, increasing the already significant overhead of function calls with the
much greater one of executing new programs. As an “extreme” example, a typical
Unix shell will parse each command (with few exceptions) as the name of a new
program to execute. How inefficient!?</p>
<p>Maintainable, replaceable code reuse can only happen when the interfaces are
well specified and minimal, such as obtain between cooperating independent
programs in a Unix pipeline.</p>
<blockquote>
<p>The key to problem-solving on the UNIX system is to identify the right
primitive operations and to put them at the right place. UNIX programs tend to
solve general problems rather than special cases. In a very loose sense, the
programs are orthogonal, spanning the space of jobs to be done (although with
a fair amount of overlap for reasons of history, convenience or efficiency).
Functions are placed where they will do the most good: there shouldn’t be a
pager in every program that produces output any more than there should be
filename pattern matching in every program that uses filenames.</p>
<p>One thing that UNIX does not need is more features. It is successful in part
because it has a small number of good ideas that work well together. Merely
adding features does not make it easier for users to do things — it just
makes the manual thicker.<sup class="footnote-ref"><a href="#fn-7aee199b-design" id="fnref-7aee199b-design">[1]</a></sup></p>
</blockquote>
<hr/><section class="footnotes"><ol><li id="fn-7aee199b-design" value="1">Pike, Rob, and Brian Kernighan. “Program design in the UNIX environment.” AT&amp;T Bell Laboratories Technical Journal 63.8 (1984): 1595-1605. See also <a href="https://harmful.cat-v.org/cat-v/">UNIX Style, or cat -v Considered Harmful</a>. <a href="#fnref-7aee199b-design">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-without-u-boot">STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></h2>
<div class="article-meta">Published 11 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/red.jpg"/></p>
<p><em>This is Part 3 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In this article, we use Arm Trusted Firmware (TF-A) to load the Linux kernel
directly, without using U-Boot.<sup class="footnote-ref"><a href="#fn-e89b24ec-st" id="fnref-e89b24ec-st">[1]</a></sup> I have seen the idea of omitting the
Secondary Program Loader (SPL) referred to as “falcon mode”, since it makes the
boot process (slightly) faster. However, I am primarily interested in it as a
way of reducing overall complexity of the software stack.</p>
<p>In this article, we will implement this in two ways. First, we modify the files
as needed manually. At the end of the article, we provide an alternative method:
directly integrate the changes into Buildroot.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>To get started, make sure to have built the default configuration as per the
<a href="stm32mp135-linux-default-buildroot">first article</a> of this series. Very
briefly, this entails cloning the official Buildroot repository, selecting a
defconfig, and compiling:</p>
<div class="codehilite"><pre><code class="language-text">$ git clone https://gitlab.com/buildroot.org/buildroot.git --depth=1
$ cd buildroot
$ make stm32mp135f_dk_defconfig
$ make menuconfig # add the STM32MP_USB_PROGRAMMER=1 flag to TF-A build
$ make</code></pre></div>
<p>It is also recommended to learn how to flash the SD card without removing it via
a USB connection, as explained in the <a href="stm32mp135-linux-cubeprog">second
article</a>.</p>
<h3 id="tutorial">Tutorial</h3>
<p>The procedure is pretty simple. All we need to do is to modify some files,
adjust some build parameters, recompile, and the new SD card image is ready to
test.</p>
<ol>
<li>
<p>Before making any modifications, make a backup of the file containing U-Boot.</p>
<div class="codehilite"><pre><code class="language-text">   $ cd output/images
   $ cp fip.bin fip_uboot.bin</code></pre></div>
<p>Double check that the above <code>fip.bin</code> was built using the additional ATF
build variable <code>STM32MP_USB_PROGRAMMER=1</code>, otherwise USB flashing will not
work!</p>
<p>Open <code>flash.tsv</code>, and update the <code>fip.bin</code> to <code>fip_uboot.bin</code> there as well.</p>
<p>(Despite removing U-Boot from the boot process, we are still going to use it
to flash the SD card image via USB using the STM32CubeProg.)</p>
</li>
</ol>
<ol>
<li>
<p>Two TF-A files need to be modified, so navigate to the TF-A build directory:</p>
<div class="codehilite"><pre><code class="language-text">   $ cd ../build/arm-trusted-firmware-lts-v2.10.5</code></pre></div>
<p>Since the kernel is much bigger than U-Boot, it takes longer to load. We need
to adjust the SD card reading timeout. In <code>drivers/st/mmc/stm32_sdmmc2.c</code>,
find the line</p>
<div class="codehilite"><pre><code class="language-text">   timeout = timeout_init_us(TIMEOUT_US_1_S);</code></pre></div>
<p>and replace it with</p>
<div class="codehilite"><pre><code class="language-text">   timeout = timeout_init_us(TIMEOUT_US_1_S * 5);</code></pre></div>
<p>Next, we would like to load the kernel deep enough into the memory space so
that relocation of the compressed image is not necessary. In file
<code>plat/st/stm32mp1/stm32mp1_def.h</code>, find the line</p>
<div class="codehilite"><pre><code class="language-text">   #define STM32MP_BL33_BASE              STM32MP_DDR_BASE</code></pre></div>
<p>and replace it with</p>
<div class="codehilite"><pre><code class="language-text">   #define STM32MP_BL33_BASE              (STM32MP_DDR_BASE + U(0x2008000))</code></pre></div>
<p>Finally, in order to allow loading such a big <code>BL33</code> as the kernel image, we
adjust the max size. In the same file, find the line</p>
<div class="codehilite"><pre><code class="language-text">   #define STM32MP_BL33_MAX_SIZE          U(0x400000)</code></pre></div>
<p>and replace it with</p>
<div class="codehilite"><pre><code class="language-text">   #define STM32MP_BL33_MAX_SIZE          U(0x3FF8000)</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Next, we need to modify a couple build parameters. Open the <code>make menuconfig</code>
and navigate to <code>Bootloaders ---&gt; ARM Trusted Firmware (ATF)</code>.</p>
<ul>
<li>
<p>Under <code>BL33</code>, change from U-Boot to None.</p>
</li>
</ul>
<ul>
<li>
<p>Under <code>Additional ATF build variables</code>, make sure that U-Boot is not
present and add the following key-value pairs:</p>
<div class="codehilite"><pre><code class="language-text">     BL33=$(BINARIES_DIR)/zImage BL33_CFG=$(BINARIES_DIR)/stm32mp135f-dk.dtb</code></pre></div>
</li>
</ul>
<p>Select “Ok” and “Esc” out of the menus, making sure to save the new
configuration.</p>
<p>Next, open the file
<code>board/stmicroelectronics/common/stm32mp1xx/genimage.cfg.template</code> and
increase the size of the <code>fip</code> partition, for example:</p>
<div class="codehilite"><pre><code class="language-text">   partition fip {
   	image = "fip.bin"
   	size = 8M
   }</code></pre></div>
<p>Finally, since U-Boot will no longer be around to pass the Linux command line
arguments, we can instead pass them through the device tree source. Open the
file <code>output/build/linux-6.12.22/arch/arm/boot/dts/st/stm32mp135f-dk.dts</code>
(you may have a different Linux version, just modify the path as appropriate)
and add the <code>bootargs</code> into the <code>chosen</code> section, as follows:</p>
<div class="codehilite"><pre><code class="language-text">   chosen {
   	stdout-path = "serial0:115200n8";
   	bootargs = "root=/dev/mmcblk0p4 rootwait";
   };</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Now we can rebuild the TF-A, the device tree blob, and regenerate the SD card
image. Thanks to the magic of Buildroot, all it takes is:</p>
<div class="codehilite"><pre><code class="language-text">   $ make linux-rebuild
   $ make arm-trusted-firmware-rebuild
   $ make</code></pre></div>
<p>Keep in mind that rebuilding TF-A is needed any time the Linux kernel or DTS
or TF-A sources change, since the kernel gets packaged into the <code>fip</code> by the
TF-A build process. In this case, the first <code>make</code> rebuilds the DTB, the
second packages it in the <code>fip</code>, and the third makes sure it gets into the SD
card.</p>
</li>
</ol>
<ol>
<li>
<p>Set DIP switch to serial boot (press in the upper all of all rockers) and
flash to SD card:</p>
<div class="codehilite"><pre><code class="language-text">   $ sudo ~/cube/bin/STM32_Programmer_CLI -c port=usb1 -w output/images/flash.tsv</code></pre></div>
<p>Then reconfigure the DIP switches for SD card boot (press the bottom side of
the second rocker switch from the left), and press the black reboot button.</p>
</li>
</ol>
<p>If you watch the serial monitor carefully, you will notice that we transition
from TF-A directly to OP-TEE and Linux. Success! No U-Boot in the boot process:</p>
<div class="codehilite"><pre><code class="language-text">NOTICE:  Model: STMicroelectronics STM32MP135F-DK Discovery Board
NOTICE:  Board: MB1635 Var1.0 Rev.E-02
NOTICE:  BL2: v2.10.5(release):lts-v2.10.5
NOTICE:  BL2: Built : 20:58:52, Sep 10 2025
NOTICE:  BL2: Booting BL32
I/TC: Early console on UART#4
I/TC: 
I/TC: Embedded DTB found
I/TC: OP-TEE version: Unknown_4.3 (gcc version 14.3.0 (Buildroot 2025.08-rc3-87-gbbb0164de0)) #1 Thu Sep  4 03:06:46 UTC 2025 arm
...
(more OP-TEE messages here)
...
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 6.12.22 (jk@Lutien) (arm-buildroot-linux-gnueabihf-gcc.br_real (Buildroot 2025.08-rc3-87-gbbb0164de0) 14.3.0, GNU ld (GNU Binutils) 2.43.1) #1 SMP PREEMPT Wed Sep  3 20:23:46 PDT 2025
[    0.000000] CPU: ARMv7 Processor [410fc075] revision 5 (ARMv7), cr=10c5387d</code></pre></div>
<h3 id="buildroot-integration">Buildroot integration</h3>
<p>Instead of following the above instructions, we can automate the build process
by integrating it into Buildroot. To this end, I provide the GitHub repository
<a href="https://github.com/js216/stm32mp135_simple"><code>stm32mp135_simple</code></a> that can be
used as follows.</p>
<p>Clone the Buildroot repository. To make the procedure reproducible, let’s start
from a fixed commit (latest at the time of this writing):</p>
<div class="codehilite"><pre><code class="language-text">$ git clone https://gitlab.com/buildroot.org/buildroot.git
$ cd buildroot
$ git checkout 5b6b80bfc5237ab4f4e35c081fdac1376efdd396</code></pre></div>
<p>Obtain this repository with the patches we need. Copy the defconfig and the
board-specific files into the Buildroot tree.</p>
<div class="codehilite"><pre><code class="language-text">$ git clone git@github.com:js216/stm32mp135_simple.git
$ cd buildroot # NOT stm32mp135_simple
$ git apply ../stm32mp135_simple/patches/add_falcon.patch
$ git apply ../stm32mp135_simple/patches/increase_fip.patch
$ cp ../configs/stm32mp135_simple/stm32mp135f_dk_falcon_defconfig configs
$ cp -r ../board/stm32mp135_simple/stm32mp135f-dk-falcon board/stmicroelectronics</code></pre></div>
<p>Build as usual, but using the new defconfig:</p>
<div class="codehilite"><pre><code class="language-text">$ make stm32mp135f_dk_falcon_defconfig
$ make</code></pre></div>
<p>Flash to the SD card and boot into the new system. You should reach the login
prompt exactly as in the default configuration—but without involving U-Boot</p>
<h3 id="discussion">Discussion</h3>
<p>To port the “default” STM32MP135 setup<sup class="footnote-ref"><a href="#fn-e89b24ec-def" id="fnref-e89b24ec-def">[2]</a></sup> to a new board design, one is
expected to be comfortable writing and modifying the drivers and device tree
sources that work with</p>
<ul>
<li>
<p>Arm Trusted Firmware (Primary Program Loader)</p>
</li>
<li>
<p>OP-TEE (Trusted Execution Environment)</p>
</li>
<li>
<p>U-Boot (Secondary Program Loader)</p>
</li>
<li>
<p>Linux kernel</p>
</li>
<li>
<p>Buildroot, or, worse, Yocto</p>
</li>
</ul>
<p>That is a tall order for a new embedded developer trying to get started
integrating Linux in their products. To make things worse, there is at present
almost no literature to be found suggesting that a simpler, saner method exists.
Certainly the chip vendors themselves do not encourage it.<sup class="footnote-ref"><a href="#fn-e89b24ec-no" id="fnref-e89b24ec-no">[3]</a></sup></p>
<p>With this article, we have began chipping away at the unnecessary complexity. We
have removed U-Boot from the boot chain. (We still use it for copying the SD
card image via USB. One thing at a time!) Since our goal is to <em>run Linux</em>, the
list above gives us a blueprint for the work that remains to be done: get rid of
everything that is <em>not Linux</em>.</p>
<p>The software that you do not run is software you do not have to understand,
test, debug, maintain, and be responsible for when it breaks down ten years down
the line in some deeply embedded application, perhaps in outer space.</p>
<h3 id="upstreaming-status">Upstreaming Status</h3>
<p>19/12/2024: original Buildroot mailing list submission <a href="https://lists.buildroot.org/pipermail/buildroot/2024-December/769250.html">(1/1)</a></p>
<p>16/12/2025: response by Arnout Vandecappelle <a href="https://lists.buildroot.org/pipermail/buildroot/2025-May/778563.html">(link)</a></p>
<p>17/9/2025: amended submission <a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786595.html">(v2 0/2, </a>
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786596.html">1/2, </a>
<a href="https://lists.buildroot.org/pipermail/buildroot/2025-September/786597.html">2/2)</a></p>
<p>02/04/2026: merged by Thomas Petazzoni as Buildroot commit
<a href="https://gitlab.com/buildroot.org/buildroot/-/commit/8e4c663529d135088c78a9c7f4b59354f19d6580"><code>8e4c663529d135088c78a9c7f4b59354f19d6580</code></a></p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><em>3. This article</em></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
<hr/><section class="footnotes"><ol><li id="fn-e89b24ec-st" value="1">This approach is inspired by the ST wiki article <a href="https://wiki.st.com/stm32mpu/wiki/How_to_optimize_the_boot_time">How to optimize the boot time</a>, under “Optimizing boot-time by removing U-Boot”. (cited 09/11/2025)  <a href="#fnref-e89b24ec-st">↩</a></li><li id="fn-e89b24ec-def" value="2">See the ST Wiki, <a href="https://wiki.st.com/stm32mpu/wiki/OpenSTLinux_distribution">OpenSTLinux distribution</a> (cited 09/11/2025)  <a href="#fnref-e89b24ec-def">↩</a></li><li id="fn-e89b24ec-no" value="3">As per the <a href="https://community.st.com/t5/stm32-mpus-embedded-software-and/start-linux-kernel-from-tf-a/td-p/91321">ST forum,</a> (cited 09/11/2025) the approach outlined in the present article is officially <em>not</em> supported by ST. <a href="#fnref-e89b24ec-no">↩</a></li></ol></section>
</div>

    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page6.html">← Older articles</a></div>
        <div><a class="newer" href="page4.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
