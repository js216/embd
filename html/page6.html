<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="unix-contributions">What Unix Contributed</a></h2>
<div class="article-meta">Published 6 Sep 2025. Written by GPT-5 from notes by Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1170.jpg"/></p>
<p>Unix was built on a handful of ideas that turned out to be both powerful and
practical. The following discussion blends established Unix facts with
interpretive commentary; it does not claim to describe any single historical
Unix precisely.</p>
<h3 id="programs-and-the-shell">Programs and the Shell</h3>
<p>The shell runs commands as programs. There’s no special class of built-ins; if
you want a new command, you write a program. By default, programs read from
standard input and write to standard output, unless redirected.</p>
<p>Most commands are small filters for text streams. They do one job, and they work
together naturally. Connecting them with pipes lets you build bigger tools out
of simpler ones.</p>
<h3 id="the-file-system-abstraction">The File System Abstraction</h3>
<p>Everything is a file: user data, programs, directories, and even devices.
Directories form a tree; each entry points to an inode, which knows where the
data blocks live. Devices show up as files too.</p>
<p>This means that I/O and storage use the same calls: open, close, read, write.
That’s the interface for everything. Executables and data files are stored in
the same way, reinforcing the idea that a single abstraction suffices.</p>
<h3 id="processes-and-the-kernel">Processes and the Kernel</h3>
<p>The kernel is deliberately small. It multiplexes I/O and leaves the rest to user
programs. Even init, the first process, is just a program: it opens terminals,
prints the login message, and starts shells in a loop.</p>
<p>Processes come from the fork/exec pair. One process copies itself, then overlays
the copy with another program. The idea is simple, and it works.</p>
<p>System calls are invoked by a trap instruction, wrapped in library functions so
programs don’t depend directly on kernel details. Programs stay independent, and
the operating system can change underneath.</p>
<h3 id="small-understandable-portable">Small, Understandable, Portable</h3>
<p>Unix was small enough that one person could understand the whole thing. That
made it easier to modify, port, and teach. The manuals were short, consistent,
and focused on usage, not internals. A second volume provided tutorials and
background for those who wanted more.</p>
<p>The guiding principle was: be general, but not too general; portable, but not
too portable. If you try to solve every problem in advance, you get bloat. By
keeping it modest, Unix was more useful—and paradoxically more general and
portable—than larger systems.</p>
<h3 id="the-8020-rule">The 80/20 Rule</h3>
<p>Some parts were machine-specific, usually device drivers or bits of assembly.
But not many. Most code was reusable, and the exceptions were small. An array of
function pointers mapped device numbers to driver routines; that was about as
complex as it got. For example, a character device<sup class="footnote-ref"><a href="#f17e21ef-fn1" id="f17e21ef-fnref1">[1]</a></sup> driver needs to
expose the following functions:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cdevsw</span>
<span class="p">{</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_open</span><span class="p">)();</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_close</span><span class="p">)();</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_read</span><span class="p">)();</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_write</span><span class="p">)();</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_ioctl</span><span class="p">)();</span>
<span class="w">	</span><span class="kt">int</span><span class="w">	</span><span class="p">(</span><span class="o">*</span><span class="n">d_stop</span><span class="p">)();</span>
<span class="w">	</span><span class="k">struct</span><span class="w"> </span><span class="nc">tty</span><span class="w"> </span><span class="o">*</span><span class="n">d_ttys</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">cdevsw</span><span class="p">[];</span>
</pre></div>
</code></pre>
<p>The 80/20 rule applied everywhere: make most of the system simple and portable,
accept a little complexity when it really pays off. Code was meant to be 80%
reusable, not 100%, which avoided the kind of rigidity seen in later systems.</p>
<h3 id="self-hosting-and-accessible">Self-Hosting and Accessible</h3>
<p>Unix came with all its own sources and tools. It was self-hosting, and people
could read, study, and change the code. The system included what you needed, and
nothing more. No useless programs, no dead code, and very little irrelevant
platform-specific clutter.</p>
<p>The philosophy was to write programs you would actually use, not ones meant to
satisfy a standard or some hypothetical future need.</p>
<h3 id="simplicity-above-all">Simplicity Above All</h3>
<p>The enduring lesson of Unix is that simplicity beats complexity. Interfaces were
orthogonal, text was the universal medium, and programs were small and
self-contained. Each one did one thing, and did it well.</p>
<p>That philosophy proved more important than any single feature. It made Unix
portable, teachable, and durable. It showed that you don’t need a committee or a
grand design to build something powerful. You need clarity, restraint, and the
discipline to write only what you need.</p>
<h3 id="reflections-and-extensions">Reflections and Extensions</h3>
<p>Unix also suggests how to go further. Small, portable, self-contained programs
can approach the kind of stability that TeX achieved—systems so refined that
they don’t need to change.</p>
<p>Portability itself can be modular. The Wollongong group<sup class="footnote-ref"><a href="#f17e21ef-fn2" id="f17e21ef-fnref2">[2]</a></sup> showed this by first
porting Unix piece by piece to an Interdata 7/32, running it alongside the host
system, and then replacing the host functions with assembly routines. That
approach points toward kernels that are more modular, where pieces like fork and
exec could be reused without bringing along a whole scheduler.</p>
<p>Device drivers can also be simplified. One idea is to treat them as user
processes whose IDs match their device numbers. They would implement the usual
open, read, and write interfaces, but otherwise behave like ordinary programs:
start and stop freely, hold their own memory, receive signals. The kernel would
not “manage” them, yet the familiar Unix file interface would still apply.</p>
<p>The same lesson holds today. Artificial intelligence can sometimes repair or
adapt programs automatically, but only if the systems are small and
self-contained. Large, tangled software offers no foothold. Unix worked because
it avoided dead code, avoided over-abstraction, and made each interface simple
enough to understand and replace.</p>
<p>Finally, Unix showed that the way forward can’t be too innovative. <em>If “the way”
is too radical, no one will follow it.</em><sup class="footnote-ref"><a href="#f17e21ef-fn3" id="f17e21ef-fnref3">[3]</a></sup> The genius of Unix was that it was
just radical enough.</p>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="f17e21ef-fn1"><p>From version 7 Unix, found in
<a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V7/usr/sys/h/conf.h"><code>/usr/sys/h/conf.h</code></a>. <a class="footnote-backref" href="#f17e21ef-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="f17e21ef-fn2"><p>Juris Reinfelds: <a href="https://www.tuhs.org/Archive/Distributions/Other/Interdata/uow103747.pdf"><em>The First Port of
Unix.</em></a>
Department of Computing Science, The University of Wollongong. See also
Richard Miller: <a href="http://bitsavers.informatik.uni-stuttgart.de/bits/Interdata/32bit/unix/univWollongong_v6/miller.pdf"><em>The First Unix
Port.</em></a>
Miller Research Ltd. (Both documents undated. Why don’t people date all
their documents!?) <a class="footnote-backref" href="#f17e21ef-fnref2">↩︎</a></p>
</li>
<li class="footnote-item" id="f17e21ef-fn3"><p>Still looking for the source of this quote … <a class="footnote-backref" href="#f17e21ef-fnref3">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-linux-default-buildroot">STM32MP135 Default Buildroot Configuration</a></h2>
<div class="article-meta">Published 3 Sep 2025, modified 10 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/vax.jpg"/></p>
<p><em>This is Part 1 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>Wouldn’t it be great to have a single board computer that runs <em>just Linux</em>?
That is, no external libraries, tools, driver modules—just the kernel binary,
and whichever programs you <em>choose</em> to run under it. After all, Linux is just a
C program, so how hard can it be to compile and run it? Read on to get started
exploring the wild world of embedded Linux.</p>
<h3 id="tutorial">Tutorial</h3>
<p>In this tutorial, we show how to get a basic “minimal” Linux installed on the
<a href="https://www.st.com/en/evaluation-tools/stm32mp135f-dk.html">STM32MP135 evaluation
board</a> with a
minimum of steps or obscure scripts. For detailed explanations, refer to the
excellent writeup from <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-basic-system/">Bootlin.</a></p>
<ol>
<li>
<p>Get a copy of Buildroot:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://gitlab.com/buildroot.org/buildroot.git
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>buildroot
</pre></div>
</code></pre>
<p>As of this writing, the latest commit in this repository is</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>rev-parse<span class="w"> </span>HEAD
bbb0164de08f761a3399c961700db44befff5c70
</pre></div>
</code></pre>
</li>
<li>
<p>Find the default configuration appropriate for this board:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>list-defconfigs<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>stm32mp135
</pre></div>
</code></pre>
<p>This shows that <code>stm32mp135f_dk_defconfig</code> is available. Install it by calling
make on it:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>stm32mp135f_dk_defconfig
</pre></div>
</code></pre>
<p>Let’s enable the USB mode for Arm Trusted Firmware (TF-A) so that we will be
able to use USB flashing in the future. Open</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>menuconfig
</pre></div>
</code></pre>
<p>Navigate under <code>Bootloaders ---&gt;  ARM Trusted Firmware (ATF)</code> and add the
following at the end of the “Additional ATF build variables” string:</p>
<pre><code><div class="codehilite"><pre><span></span>STM32MP_USB_PROGRAMMER=1
</pre></div>
</code></pre>
<p>Then select “OK”, and “Esc” your way out of the menuconfig. Make sure to say
“Yes” when asked whether to save the new configuration.</p>
</li>
<li>
<p>Run the build, and collect logs into a file:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span><span class="nb">time</span><span class="w"> </span>make<span class="w"> </span>&gt;log.txt<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>
</code></pre>
<p>On my dual-core i5-7300U laptop, this took about an hour and a half.</p>
<p>Watch the build from another terminal:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>tail<span class="w"> </span>-f<span class="w"> </span>log.txt
</pre></div>
</code></pre>
</li>
<li>
<p>Copy the generated image to an SD card (assumed to be at <code>/dev/sdb</code>):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>output/images/sdcard.img<span class="w"> </span><span class="nv">of</span><span class="o">=</span>dev/sdb<span class="w"> </span><span class="nv">bs</span><span class="o">=</span>1M
</pre></div>
</code></pre>
</li>
<li>
<p>Time to run it on the evaluation board! Set it up as follows:</p>
<ul>
<li>Insert the SD card into the slot</li>
<li>Connect the USB-C port to the right of the screen (<code>CN12</code>, labelled <code>PWR_IN</code>)
to a powered USB hub</li>
<li>Connect the Micro USB (<code>CN10</code>, left of the screen) to a desktop computer,
which will enumerate as a serial port (<code>/dev/ttyACM0</code> on my computer).</li>
<li>Open a serial console (115200 baud, no parity) to listen</li>
</ul>
<p><img alt="" src="../images/board.jpg"/></p>
<p>Set the DIP switches to boot from the SD card as shown in the image below. In
this orientation, press in on the upper side of the rockers of <code>BOOT0</code> and
<code>BOOT2</code>, and on the lower side for <code>BOOT1</code>.</p>
<p><img alt="" src="../images/buttons.jpg"/></p>
<p>Press the black reset button and if everything went right, you should see the
kernel boot messages displayed on the serial monitor, until the login prompt
gets displayed. Done!</p>
<pre><code><div class="codehilite"><pre><span></span>Welcome to Buildroot
buildroot login: root
# uname -a
Linux buildroot 6.12.22 #1 SMP PREEMPT Wed Sep  3 20:23:46 PDT 2025 armv7l GNU/Linux
</pre></div>
</code></pre>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>This is, to my knowledge, the fastest way to get started with embedded Linux on
“real” hardware in terms of number of steps. However, it does not result in the
most minimal distribution. Besides the Linux kernel, the default configuration
pulls in a number of large programs, such as U-Boot, ATF, OP-TEE, and more.
(Examine <code>buildroot/dl</code>) after building to see all the stuff that got downloaded
in the build process.)</p>
<p>For someone used to bare-metal embedded work, the size and complexity of this
auxiliary software is utterly baffling. A bootloader with more lines of code
than my whole project? Several different compilers and interpreters (C, Rust,
Perl, Python) needed for a “Hello, world!?”</p>
<p>In my mind I hold an ideal of the “pure” essence of Unix: there is one kernel,
which at the end of its boot process invokes one user-space program (<code>init</code>),
which then does anything it wants to. I believe in the simplicity of the Linux
boot process, as outlined by Russell King in the 2002 masterpiece, <a href="https://www.kernel.org/doc/Documentation/arm/Booting">“Booting ARM
Linux”</a>:</p>
<ol>
<li>Initialize RAM and copy the kernel into it</li>
<li>Initialise one serial port</li>
<li>Load the device tree blob (DTB) into RAM, and place its address in <code>r2</code></li>
<li>Pass control to Linux and watch it boot like magic!</li>
</ol>
<p>It is time we regain the pristine uncomplicated state that used to exist before
everything became bundled and containerized and wrapped inside countless layers
of abstraction that are supposed to make things simpler, but in the end serve
only to confuse everyone.</p>
<p>In the next articles, we will take this “primordial mess” and cut it down to
size. Stay tuned!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><em>1. This article</em></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="circ_uart_dma_k64">UART DMA with a Circular Buffer on K64</a></h2>
<div class="article-meta">Published 2 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/circ.jpg"/></p>
<p>Working on a FreeRTOS-based project running on the NXP Kinetis K64, I wanted to
read data from several UART interfaces. The default “easy” method using
interrupts is easy to set up via the NXP MCUXpresso Config Tools; the problem is
that the UART peripheral only has a few bytes of built-in buffer. If the data is
arriving at the interfaces faster than the firmware can read it, the tiny buffer
immediately overflows and part of the data is lost.</p>
<p>This is obviously a task for Direct Memory Access (DMA): let the data arrive
into a much larger buffer, from where the software can take characters at its
leisure. In this article, we will briefly contrast three ways of receiving data
from UART: interrupt-based, simple DMA, and DMA with a circular buffer (aka ring
buffer).</p>
<h3 id="uart-with-interrupts">UART with Interrupts</h3>
<p>The “point-and-click” method works out of the box with the Config tools. Leave
things at their default values, or change whatever is necessary. In my setup, I
had the values shown in the image below.</p>
<p><img alt="Config Tools: UART Interrupt Configuration" src="../images/inter.jpg"/></p>
<p>Even the interrupt handler is provided by the tool. Click on “Copy to
clipboard”, and adapt as necessary. All that is needed is to read the status
flags and read a byte of data, and push it to a FreeRTOS queue that we set up
previously:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">UART0_SERIAL_RX_TX_IRQHANDLER</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">intStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_GetStatusFlags</span><span class="p">(</span><span class="n">UART0</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">kUART_RxDataRegFullFlag</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">kUART_RxOverrunFlag</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">intStatus</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_ReadByte</span><span class="p">(</span><span class="n">UART0</span><span class="p">);</span>
<span class="w">      </span><span class="n">xQueueSendToBackFromISR</span><span class="p">(</span><span class="n">rx_queue</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>This seems like it couldn’t be simpler, and it just <em>should</em> work. Indeed, for
baud rates at or below about 9600, it does work almost reliably. And yet
sometimes, for no good reason, a byte gets dropped. Is that possible?</p>
<p>Let’s see. At 115,200 baud, we get a character every 8.7 μs. It’s entirely
possible that some other interrupt or critical section takes priority over this
one for much longer than that, especially looking at some of the rather long
Ethernet ISRs supplied with the NXP SDK. If we have less than 10 microseconds to
process a character before it goes away, we’ll probably miss many of them!
Onwards to DMA.</p>
<h3 id="uart-with-edma">UART with eDMA</h3>
<p>With direct memory access, the UART peripheral should be able to place the bytes
directly in a software buffer, without having to go through an RTOS queue.
Besides being much faster, we can also make the queue almost arbitrarily large,
ensuring that we’ll be able to get to the data eventually and process it.</p>
<p>Thanks to the Config Tools, setting this up is again very straightforward. Just
enable some checkboxes and set up DMA channels, as I did in the image below.</p>
<p><img alt="Config Tools: UART eDMA Configuration" src="../images/edma.jpg"/></p>
<p>This time, we do not have a handy “Click to get code” button. Instead, ChatGPT
or Gemini or Claude are happy to write something that nearly works. In a
dedicated FreeRTOS task, let’s poll for characters as they arrive into the
buffer:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bytesWritten</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UART_TransferGetReceiveCountEDMA</span><span class="p">(</span><span class="n">UART0_PERIPHERAL</span><span class="p">,</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">UART0_UART_eDMA_Handle</span><span class="p">,</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">bytesWritten</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">kStatus_Success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">vTaskDelay</span><span class="p">(</span><span class="n">pdMS_TO_TICKS</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">readIndex</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">bytesWritten</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">DMA_BUF_SIZE</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uartRxBuf</span><span class="p">[</span><span class="n">readIndex</span><span class="p">];</span>
<span class="w">      </span><span class="n">readIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">readIndex</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">DMA_BUF_SIZE</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// now do what you want with the received character</span>
<span class="w">   </span><span class="p">}</span>

<span class="w">   </span><span class="n">vTaskDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>Note the <code>vTaskDelay(1)</code> calls which ensure that this task does not starve
lower-priority tasks of processor time.</p>
<p>In the above, the chatbot made use of the function
<code>UART_TransferGetReceiveCountEDMA()</code> from the NXP SDK and implemented the ring
buffer wraparound with some modulo operation that’s probably about correct. But
what happens when the buffer gets filled up? In that case, an interrupt triggers
the DMA callback, which simply restarts the DMA to receive data back into the
beginning of the buffer:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">uart0_callback</span><span class="p">(</span><span class="n">UART_Type</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">uart_edma_handle_t</span><span class="w"> </span><span class="o">*</span><span class="n">handle</span><span class="p">,</span>
<span class="w">                           </span><span class="n">status_t</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">userData</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">uart_transfer_t</span><span class="w"> </span><span class="n">rxXfer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uartRxBuf</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">dataSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DMA_BUF_SIZE</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">UART_ReceiveEDMA</span><span class="p">(</span><span class="n">UART0_PERIPHERAL</span><span class="p">,</span><span class="w"> </span><span class="n">handle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rxXfer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>This works great, but has an unfortunate limitation. When the buffer is at the
end of its capacity, characters must arrive slowly enough so we have time to
re-start the DMA. In other words, we have not solved anything! Data will
occasionally get lost when the callback is executing.</p>
<p>Naturally, the DMA should be writing continuously without us having to restart
it. Much back and forth with AI achieved nothing. The version of the NXP SDK
that I’m using, while full of intricate code covering what appears to be almost
every possible use case, somehow does not cover the most elementary DMA
operation: continuous data reception.</p>
<h3 id="true-continuous-dma-ring-buffer">True continuous DMA ring buffer</h3>
<p>This brings us to the final section: how to make the ring buffer work without
stopping? By my count, the SDK takes 4517 lines of C to implement the
“simplified” DMA configuration code, and yet there’s no easy
<code>UART_MakeMeARingBuffer()</code>. There are 80 pages in the K64 Sub-Family Reference
Manual about the DMA, and 85 about UART, with lots of tables of registers, flow
charts, diagrams. Enough to leave one entirely mystified.</p>
<p>The key revelation here is that the <em>DMA peripheral is not nearly as complicated
as NXP would have us believe.</em> As it turns out, there are only a couple fields
one has to fill out in the “transfer control descriptor” (TCD): source and
address of the data, the size of each logical word (for UART: one byte), how
many bytes to write altogether, and what to do after writing them.</p>
<p>To integrate it with the code generated by the Config Tools above, we need the
handles to the UART and eDMA controls, and a buffer to place the data in:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">UART_Type</span><span class="w"> </span><span class="o">*</span><span class="n">uart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART0_PERIPHERAL</span><span class="p">;</span>
<span class="n">edma_handle_t</span><span class="w"> </span><span class="o">*</span><span class="n">dma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UART1_RX_Handle</span><span class="p">;</span>

<span class="cp">#define BUF_SIZE 256</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
</pre></div>
</code></pre>
<p>Next, we define the source (UART buffer) and destination for the data:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">edma_tcd_t</span><span class="w"> </span><span class="o">*</span><span class="n">tcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">edma_tcd_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">TCD</span><span class="p">[</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">];</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">SADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UART_GetDataRegisterAddress</span><span class="p">(</span><span class="n">uart</span><span class="p">);</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">DADDR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Fill in the source and destination offset, number of bytes to transfer at once
(just one byte), and number of bytes to transfer in a so-called “major loop”
(equal to the size of the ring buffer):</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">tcd</span><span class="o">-&gt;</span><span class="n">SOFF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">DOFF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">NBYTES</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">ATTR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DMA_ATTR_SSIZE</span><span class="p">(</span><span class="n">kEDMA_TransferSize1Bytes</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">DMA_ATTR_DSIZE</span><span class="p">(</span><span class="n">kEDMA_TransferSize1Bytes</span><span class="p">);</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">CITER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">;</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">BITER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BUF_SIZE</span><span class="p">;</span>
<span class="n">tcd</span><span class="o">-&gt;</span><span class="n">DLAST_SGA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">BUF_SIZE</span><span class="p">;</span>
</pre></div>
</code></pre>
<p>Note the <code>DLAST_SGA</code> field: it causes the write address to be rewound back to
the start of the data buffer upon completing the major loop. This is really all
that’s needed to create a true circular ring buffer that runs without stopping.</p>
<p>Finally, to make it run, we need to enable the DMA service request from both the
eDMA and UART sides:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">SERQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DMA_SERQ_SERQ</span><span class="p">(</span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
<span class="n">uart</span><span class="o">-&gt;</span><span class="n">C5</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">UART_C5_RDMAS_MASK</span><span class="p">;</span>
<span class="n">uart</span><span class="o">-&gt;</span><span class="n">C2</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">UART_C2_RIE_MASK</span><span class="p">;</span>
</pre></div>
</code></pre>
<p><em>Beware:</em> If making use of any NXP-provided functions, know that several of them
implicitly set the <code>DREQ</code> bit (“Disable Request”) which will stop DMA once a
single major loop is complete. As the Reference Manual puts it,</p>
<blockquote>
<p><code>DREQ</code> (Disable Request) If this flag is set, the eDMA hardware automatically
clears the corresponding <code>ERQ</code> bit when the current major iteration count
reaches zero.</p>
</blockquote>
<h3 id="readout-from-the-buffer">Readout from the buffer</h3>
<p>Once the DMA is happily streaming UART bytes into the buffer, we would like to
get it out.  The simplest way to do so would be a character at a time,
<code>getc</code>-style.</p>
<p><em>Step One:</em> consult the DMA registers about the current iteration inside a major
loop:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ch</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">biter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">TCD</span><span class="p">[</span><span class="n">ch</span><span class="p">].</span><span class="n">BITER_ELINKNO</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">citer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">TCD</span><span class="p">[</span><span class="n">ch</span><span class="p">].</span><span class="n">CITER_ELINKNO</span><span class="p">;</span>
</pre></div>
</code></pre>
<p><em>Step Two:</em> compute the number of bytes available in the buffer.</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">write_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">biter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">citer</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">UART_DMA_BUF_SIZE</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">write_index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">avail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">UART_DMA_BUF_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">write_index</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><em>Step Three:</em> If any bytes are available for readout, let’s read it out (into
the variable <code>c</code>), then advance the queue pointer:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">*</span><span class="n">head</span><span class="p">];</span>
<span class="w">   </span><span class="o">*</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">UART_DMA_BUF_SIZE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>That’s it!</p>
<h3 id="conclusion">Conclusion</h3>
<p>My intention with this writeup was to show that DMA configuration on the Kinetis
K64 is very simple once one learns to let go of the tools that are supposed to
make it easier: the NXP SDK, the Config Tools GUI, the Reference Manual. 17
lines of code is all it takes to configure a UART ring buffer with DMA!</p>
<p>Direct manipulation of system registers may appear confusing. After all, where
is one supposed to learn which are all the registers that must be set? The SDK
is often the only entry point, but it’s discouraging: confusing,
over-engineered, and ironically missing the simplest features.</p>
<p>It’s an amusing experience to take the “official” code examples and manually
inline all the functions, unfolding the complex call chain into hundreds of
lines of code. Once all the unnecessary conditional compilation and inapplicable
conditions are removed, you can often be left with just a handful of lines of
simple code which, with the help of the reference manual, is pretty readable.
Certainly more than the mostly undocumented, partially implemented SDK morass of
functions, drivers, modules, what have you!</p>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="programming-values-checklist">A Checklist of Values for Programming</a></h2>
<div class="article-meta">Published 31 Aug 2025, modified 12 Sep 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/sub.jpg"/></p>
<h3 id="1-simplicity-and-minimalism">1. Simplicity and minimalism</h3>
<p>Each program does <em>one</em> thing only.</p>
<blockquote>
<p>Do not put code in your program that might be used. Do not leave hooks on
which you can hang extensions. The things you might want to do are infinite;
that means that each one has 0 probability of realization. If you need an
extension later, you can code it later - and probably do a better job than if
you did it now. And if someone else adds the extension, will they notice the
hooks you left?<sup class="footnote-ref"><a href="#dd56e97d-fn1" id="dd56e97d-fnref1">[1]</a></sup></p>
</blockquote>
<p>Do not be tempted to use all the features provided by the language, operating
system, or hardware.</p>
<p>While making full use of the hardware is a nice thing, DO NOT fill up the
available program or data memory more than about 75%, or else future
modifications (or even extra features!) will become <em>really</em> difficult to
implement. When the entire system capacity is used up, every functions and
feature becomes entangled with every other one: if you want an extra variable
here, you need to make some other part smaller, etc.</p>
<h3 id="2-portability">2. Portability</h3>
<p>Be very strict to only use those of the language features that are guaranteed by
the standard.</p>
<p>Use a simple compile/build process that works on all relevant operating systems
and none, on all relevant combinations of hardware, and with all compilers for
the same language that you have available.</p>
<p>The inevitable non-portable stuff (think the likes of DMA configuration) is to
be minimized, isolated, and documented. The goal of the minimization is not to
make it more “performant”, whatever that means, but to make it possible for
someone new to the project or platform to understand.</p>
<p>If the non-portable parts are more than usually obscure, document them in a
literate style.</p>
<h3 id="3-error-handling">3. Error handling</h3>
<p>All functions should return 0 on success and -1 on error. In languages like C
where a function can only return one value, this unfortunately implies that the
data is to be returned via function pointers; these should be the first (few)
arguments of the function.</p>
<p>The error handling should be implemented in multiple levels. At least two are
mandatory:</p>
<ul>
<li>
<p>Assertions are errors that “cannot happen”, which indicate programming errors
which are to be discovered during testing. Also known as <code>ERROR</code>, or <code>fail</code>.</p>
</li>
<li>
<p>User errors, such as invalid input, which can be recovered from. The error
codes should be collected all in one place and be associated with
understandable error messages, which are to be communicated to the user in
some way.</p>
</li>
</ul>
<p>Both of these should be present from the very beginning of a project. If the
infrastructure is not in place yet, simply make a file like <code>errors.c</code> with
empty implementations:</p>
<pre><code class="language-c"><div class="codehilite"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">fail</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="n">err_code</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</code></pre>
<p>Most likely it will be appropriate to include a way to print the error messages,
or to report them to the user, or trigger a debugger breakpoint when they
happen, etc. That can all easily be added later. What’s important is that the
functions be present and used from the very start.</p>
<p>Additional error levels can be added, such as warnings (valid, but unusual and
probably unexpected conditions) and debug information (explaining what the
program is doing at a particular point, to enable crash reconstruction from
these logs).</p>
<h3 id="4-readability">4. Readability</h3>
<p>Functions must be very short (ideally less than 25 lines or so).</p>
<p>Use simple control flow. No deeply nested loops and conditional, three
indentation levels inside a function are quite enough.</p>
<p>No multi-cycle recursion, where <code>f1()</code> calls <code>f2()</code> which calls <code>f3()</code> which
calls <code>f1()</code> again.</p>
<p>Header inclusions, or the use of modules in general must be a directed acyclic
graph. In particular, two or three modules are not allowed to call each other’s
functions, or else these functions should probably be located inside the same
module.</p>
<p>Modules need to be short with the minimal number of functions and data
structures necessary to accomplish their goal.</p>
<p>No function or operator overloading besides what’s already provided by the
language. To be very emphatic about it: different functions should not have same
names! (Sorry C++, go away.)</p>
<h3 id="5-no-side-effects">5. No side effects</h3>
<p>Except in the dream world of functional people, a rule like this is only viable
when its exception is clearly spelled out: the functions with side effects are
to be confined to a small, clearly marked and isolated section of code. Again
like the non-portable code, the amount of code with side effects must be small
in proportion to the main program, perhaps no more than 10% of the entire source
code.</p>
<h3 id="6-tests-and-tests">6. Tests and tests</h3>
<p>There should be an extensive set of tests corresponding to all anticipated use
cases of the program. When new use cases are discovered, more tests are to be
added.</p>
<p>At a minimum, the tests need to cover the “trivial” edge or boundary cases where
most of the bugs hide anyway.</p>
<p>As with the error handling, the testing infrastructure must be present in the
code base from the very beginning, ideally before <em>any</em> of the actual
application-specific code is added. Again, this does not need to be complicated.
It is enough to create a directory called “tests” and add a target “test” to the
build system, which compiles and runs a test program. The test program in turn
can be quite minimal, just a list of test functions (function pointer array in
C, or an actual list in Python), and a main function that runs each of these in
turn, checking whether the test function returned 0 (success) or -1 (failure).</p>
<p>As the program grows, if and only if it becomes necessary, more sophisticated
test frameworks can be substituted. But for a small program this may be all that
is needed.</p>
<h3 id="7-reusability">7. Reusability</h3>
<p>No inheritance! (Sorry C++.)</p>
<blockquote>
<p>I think the lack of reusability comes in object-oriented languages, not
functional languages. Because the problem with object-oriented languages is
they’ve got all this implicit environment that they carry around with them.
You wanted a banana but what you got was a gorilla holding the banana and the
entire jungle.</p>
<p>If you have referentially transparent code, if you have pure functions—all
the data comes in its input arguments and everything goes out and leave no
state behind—it’s incredibly reusable.<sup class="footnote-ref"><a href="#dd56e97d-fn2" id="dd56e97d-fnref2">[2]</a></sup></p>
</blockquote>
<p>Functions and modules are to be so reusable that you can copy-paste them from
one program to another without <em>any</em> modifications. Inheritance-based programs
require a difficult process to extricate an inherited class, requiring one to
manually resolve the dependencies. (And all functions have the same name, which
does not help.)</p>
<p>Ensure short, simple, minimal dependency chains: short function call chains,
short chains of module inclusions. (It would be nice if there was a tool to
check this mechanically.)</p>
<p>Avoiding side effects in all functions except for a small, isolated set almost
ensures reusability, since one does not have to worry about the changes to the
global state.</p>
<p>In general, when writing functions, modules, and programs, think <em>tools</em> rather
than complete systems. General purpose blocks are automatically more reusable
than any specialized system.</p>
<h3 id="8-robustness">8. Robustness</h3>
<p>The functions, and the completed program, are to handle all corner cases in a
sensible manner. All possible argument values need to be accepted without
crashing the program or causing any other unexpected behavior.</p>
<p>The code should do extensive validation of pre-conditions and post-conditions.
These checks should be added to the code with reckless abandon and disregard for
performance implications, since their performance impact can be easily undone by
toggling a single “debug-mode” switch.</p>
<p>In theory, a program can be proven correct if each module, considered as a black
box, or a box in a flowchart, is ensured to have its pre-conditions met, and if
it makes sure to leave the post-conditions as expected by the modules that come
after.</p>
<blockquote>
<p>if any one of the assertions on the arrows leading into the box is true before
the operation in that box is performed, then all of the assertions on the
arrows leading away from the box are true after the operation.</p>
<p>Once [this] has been proved for each box, it follows that all assertions are
true during any execution of the algorithm.<sup class="footnote-ref"><a href="#dd56e97d-fn3" id="dd56e97d-fnref3">[3]</a></sup></p>
</blockquote>
<p>In practice, such checks are easy to add, most of the time don’t catch major
bugs, but when they do, they are invaluable. The real payoff is that it forces
one to think about all the possible cases the function or program may encounter
during its life.  (This knowledge is also useful when writing tests.)</p>
<p>A function should not knowingly trigger any exceptions, interrupts, traps, what
have you. (Probably does not apply in OS design.)</p>
<p>Aim to write complete, finished programs. Do not design products and teams with
the expectation to ship half-broken stuff, and then break it further with
continual “safety” improvement updates which annoy users. A suggestion: do it
right the first time around. If in a rush, get a new job.</p>
<h3 id="9-clean-source-code-organization">9. Clean source code organization.</h3>
<p>Shallow directory structure: it’s enough to have <code>src</code>, <code>tests</code>, and, for a
library, <code>include</code>. In a small C project, there should be a single Makefile, of
no more than 100 lines, covering the entire build process including building and
running tests, and static code analysis.</p>
<p>The buildchain should be standard as much as possible. Do not use special
compiler features. Do not use fancy GUI build tools which generate a deeply
nested directory structure full of entirely illegible garbage code.</p>
<p>The build tools themselves should have a simple build process. Do not torture
future developers with a need to spend two weeks setting up the toolchain,
installing just the right version of each tool that happens to work with the
other tools and your code, etc.</p>
<h3 id="10-clean-interfaces">10. Clean interfaces</h3>
<p>Functions should have a small number of arguments and returned values, certainly
no more than about five.</p>
<p>Modules should expose a small, mostly orthogonal set of public functions.</p>
<p>Ideally, programs should be small, cooperative, and produce their output if
possible in the form of human and machine readable text:</p>
<blockquote>
<p>Write programs to work together. Write programs that handle text streams,
because that is a universal interface.<sup class="footnote-ref"><a href="#dd56e97d-fn4" id="dd56e97d-fnref4">[4]</a></sup></p>
</blockquote>
<p>In particular, there should be no unnecessary output, only what is required for
the communicating processes to talk to each other, or upon explicit user
request.</p>
<blockquote>
<p>Generally a program should say nothing unless and until it has something to
say.<sup class="footnote-ref"><a href="#dd56e97d-fn5" id="dd56e97d-fnref5">[5]</a></sup></p>
</blockquote>
<hr class="footnotes-sep"/>
<section class="footnotes">
<ol class="footnotes-list">
<li class="footnote-item" id="dd56e97d-fn1"><p>C. Moore: Programming a Problem-Oriented-Language, ca. 1970. <a class="footnote-backref" href="#dd56e97d-fnref1">↩︎</a></p>
</li>
<li class="footnote-item" id="dd56e97d-fn2"><p>J. Armstrong, quoted in P. Seibel: Coders at Work, 2009. <a class="footnote-backref" href="#dd56e97d-fnref2">↩︎</a></p>
</li>
<li class="footnote-item" id="dd56e97d-fn3"><p>D. Knuth: The Art of Computer Programming. Volume 1: Fundamental
Algorithms. <a class="footnote-backref" href="#dd56e97d-fnref3">↩︎</a></p>
</li>
<li class="footnote-item" id="dd56e97d-fn4"><p>D. McIlroy, quoted in P. Salus: A Quarter Century Of UNIX, 1994. <a class="footnote-backref" href="#dd56e97d-fnref4">↩︎</a></p>
</li>
<li class="footnote-item" id="dd56e97d-fn5"><p>B. W. Kernighan and P. J. Plauger: Software Tools, Addison-Wesley,
Reading, Mass., 1976. <a class="footnote-backref" href="#dd56e97d-fnref5">↩︎</a></p>
</li>
</ol>
</section>
</div>


<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Productivity</div>
<h2><a href="yes-no-productivity">Yes/No Productivity</a></h2>
<div class="article-meta">Published 24 Aug 2025. Written by Jakob Kastelic.</div>
<p><img alt="" src="../images/avant.jpg"/></p>
<p>Many systems have been devised to organize work into several priority queues,
calendars, etc., with sophisticated tracking tools and graphics. Here’s instead
the simplest possible effective way to get things done.</p>
<p>Write down every idea, thought, request, wish to do something, all in one place.
This avoids getting yourself overwhelmed by too many sets of things to do.</p>
<p>Then, go over the list and split it into two lists, titled “Yes” and “No”,
according to the answer to the following question:</p>
<blockquote>
<p>Is doing this absolutely indispensable in order to finish this project?</p>
</blockquote>
<p>The Yes list will contain tasks crucial to the purpose of what you’re doing,
while the No list will be full of “nice to haves” and interesting ideas. You can
do this either all at once, or in batches of 10 items, or even for each item
separately, when you start working on it.</p>
<p>Until the project is complete and delivered to where is has to go, only work on
the things from the Yes list. If anyone asks about their request that you’re put
on the No list, tell them you’ll get to it later.</p>
<p>You cannot focus on more than one thing at a time, although you can [try], at a
great cost to your sanity and productivity. The Yes list enforces your unity of
purpose.</p>
<p>Then, hopefully, the project is out: paper published, product shipping to
customers, system running and being useful. Do not discard the No list just yet!
It’s full of potentially good ideas which you have subconsciously been working
on (in [true parallelism] with the main project) for many weeks, months, even
years. Scan it for these ideas, form new projects out of them, present or assign
them to others to work on. Of course, many of these will be obsolete by now, or
simply not good. Graciously let go of them — throw them away.</p>
</div>


    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div></div>
        <div><a class="newer" href="page5.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
