<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Articles on embedded Linux, STM32 development, low-level programming, and practical approaches to software productivity. Tutorials, experiments, and reflections on simplicity in computing.">
<link rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<link rel="stylesheet" href="style.css">
<link rel="icon" href="favicon.ico">
<title>embd.cc</title>
</head>
<body>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="bugs-in-nxp-kinetis-ethernet-driver">Bugs in NXP Kinetis Ethernet Driver</a></h2>
<div class="article-meta">Published 10 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/lev63.jpg"/></p>
<p>The SDK<sup class="footnote-ref"><a href="#fn-cdc89f27-sdk" id="fnref-cdc89f27-sdk">[1]</a></sup> drivers provided by NXP for use on the Kinetis K64 platform are
extensive, well-tested and ... not perfect. This article shows three bugs found
in the ethernet driver. Note that none of this is original content; I merely put
it together here for my future reference.</p>
<h3 id="forgetting-to-check-for-zero-length-buffers">Forgetting to check for zero-length buffers</h3>
<p>I have only seen this bug happen once in two years and have not found a way to
reproduce it at will. So the analysis below may or may not be correct.</p>
<p>The symptom was that the firmware froze upon triggering the assertion in
<code>lwip/port/enet_ethernetif_kinetis.c</code>:</p>
<blockquote>
<p>”Buffer returned by <code>ENET_GetRxFrame()</code> doesn’t match any RX buffer descriptor”</p>
</blockquote>
<p>After some Googling I found <a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">this forum
thread,</a>
which suggests, in a roundabout way, that there is a missing check in
<code>fsl_enet.c</code>. We have to add following to <code>ENET_GetRxFrame()</code>:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">if</span> (curBuffDescrip<span class="o">-</span><span class="o">&gt;</span>length <span class="o">=</span><span class="o">=</span> 0U)
{
    <span class="cm">/* Set LAST bit manually to let following drop error frame
       operation drop this abnormal BD.
    */</span>
    curBuffDescrip<span class="o">-</span><span class="o">&gt;</span>control <span class="o">|</span><span class="o">=</span> ENET_BUFFDESCRIPTOR_RX_LAST_MASK;
    result <span class="o">=</span> kStatus_ENET_RxFrameError;
    <span class="k">break</span>;
}</code></pre></div>
<p>The NXP engineer on the forum explains: “I didn’t use this logic because I never
meet this corner case and consider it a redundant operation.” I was curious if
this “corner case” every happens, so I added a breakpoint, which got triggered
after about two days of constant testing.</p>
<p>ChatGPT seems to think this check is necessary (but then again, I seem to be
able to convince it of just about anything I do or do not believe in):</p>
<blockquote>
<p>If you omit the check and DMA ever delivers a BD with <code>length == 0</code>: Your code
will think it’s still in the middle of assembling a frame. It will not see the
<code>LAST</code> bit yet, so it will happily advance to the next BD. That means the
logic walks into an inconsistent state: <code>rxBuffer</code> may point to nothing, your
<code>rxFrame</code> bookkeeping goes out of sync, and later you’ll crash on a buffer
underrun, invalid pointer, or corrupted frame queue.</p>
</blockquote>
<p>It remains to be seen if this check was behind my original crash, and if the
body of the if statement is appropriate to handle the condition of unexpected
zero-length buffer descriptor.</p>
<p><em>Credit: User pjanco first reported the error, while AbnerWang posted the
solution.</em>
<a href="https://community.nxp.com/t5/i-MX-RT-Crossover-MCUs/Ethernet-RX-assertion/m-p/1625123">[source]</a></p>
<h3 id="incorrect-memory-deallocation">Incorrect memory deallocation</h3>
<p>In <code>fsl_enet.c</code>, the function <code>ENET_GetRxFrame()</code> tries to deallocate the
pointer of the receive buffer:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">while</span> (index<span class="o">-</span><span class="o">-</span> <span class="o">!</span><span class="o">=</span> 0U)
{
    handle<span class="o">-</span><span class="o">&gt;</span><span class="nf">rxBuffFree</span>(base, <span class="o">&amp;</span>rxFrame<span class="o">-</span><span class="o">&gt;</span>rxBuffArray[index].buffer,
        handle<span class="o">-</span><span class="o">&gt;</span>userData, ringId);
}</code></pre></div>
<p>First need to unpack some definitions to understand what the above means.</p>
<ol>
<li>
<p>If we dig into the <code>rxBuffFree()</code> function, we discover it in the file
<code>lwip/port/enet_ethernetif_kinetis.c</code>. The buffer to be deallocated is passed
as a pointer <code>void * buffer</code>, and freed</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">int</span> idx <span class="o">=</span> ((rx_buffer_t <span class="o">*</span>)buffer) <span class="o">-</span> ethernetif<span class="o">-</span><span class="o">&gt;</span>RxDataBuff;
   ethernetif<span class="o">-</span><span class="o">&gt;</span>RxPbufs[idx].buffer_used <span class="o">=</span> false;</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Next, what are <code>rxFrame</code> and <code>rxBuffArray</code>? The first one is of type
<code>enet_rx_frame_struct_t</code>, which is defined in <code>fsl_enet.h</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> <span class="k">struct</span> _enet_rx_frame_struct
   {
       enet_buffer_struct_t <span class="o">*</span>rxBuffArray;
       ...
   } enet_rx_frame_struct_t;</code></pre></div>
<p>This allows us to see what is the type of <code>rxBuffArray</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> <span class="k">struct</span> _enet_buffer_struct
   {
       <span class="k">void</span> <span class="o">*</span>buffer;
       uint16_t length;
   } enet_buffer_struct_t;</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Finally, what is <code>ethernetif-&gt;RxDataBuff</code>? We find it declared in
<code>lwip/port/enet_ethernetif_kinetis.c</code> as the static array in the function
<code>ethernetif0_init()</code>:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="nf">SDK_ALIGN</span>(<span class="k">static</span> rx_buffer_t rxDataBuff_0[ENET_RXBUFF_NUM],
       FSL_ENET_BUFF_ALIGNMENT);
   ethernetif_0.RxDataBuff <span class="o">=</span> <span class="o">&amp;</span>(rxDataBuff_0[<span class="m">0</span>]);</code></pre></div>
<p>More precisely, <code>RxDataBuff</code> is a pointer to the first element of this array.
This pointer therefore has the type <code>rx_buffer_t*</code>.</p>
<p>That type itself is declared at the top of the same file as an aligned
version of a <code>uint8_t</code> buffer:</p>
<div class="codehilite"><pre><code class="language-c">   <span class="k">typedef</span> uint8_t rx_buffer_t[<span class="nf">SDK_SIZEALIGN</span>(ENET_RXBUFF_SIZE,
       FSL_ENET_BUFF_ALIGNMENT)];</code></pre></div>
</li>
</ol>
<p>Now we can take a step back and think whether the <code>idx</code> calculation would be
best done with the buffer itself, or a pointer to it. The calculation subtracts
the following:</p>
<ul>
<li>
<p><code>rxFrame-&gt;rxBuffArray[index].buffer</code>, of type <code>void*</code>, is a pointer to the
memory location that stores the ethernet frame.</p>
</li>
</ul>
<ul>
<li>
<p><code>ethernetif-&gt;RxDataBuff</code>, of type <code>rx_buffer_t*</code></p>
</li>
</ul>
<p>The corrected code should pass the buffer pointer stored in .buffer, not the
address of the .buffer field (omit the <code>&amp;</code>):</p>
<div class="codehilite"><pre><code class="language-c">handle<span class="o">-</span><span class="o">&gt;</span><span class="nf">rxBuffFree</span>(base, rxFrame<span class="o">-</span><span class="o">&gt;</span>rxBuffArray[index].buffer,
    handle<span class="o">-</span><span class="o">&gt;</span>userData, ringId);</code></pre></div>
<p><em>Credit: This bug was found by KC on 7/31/2024.</em></p>
<h3 id="buffers-not-zero-initialized">Buffers not zero-initialized</h3>
<p>Another bug in <code>ethernetif0_init()</code> in <code>enet_ethernetif_kinetis.c</code>: the ethernet
buffer descriptor structs are declared static:</p>
<div class="codehilite"><pre><code class="language-c"><span class="nf">AT_NONCACHEABLE_SECTION_ALIGN</span>(
    <span class="k">static</span> enet_rx_bd_struct_t rxBuffDescrip_0[ENET_RXBD_NUM],
    FSL_ENET_BUFF_ALIGNMENT);
<span class="nf">AT_NONCACHEABLE_SECTION_ALIGN</span>(
    <span class="k">static</span> enet_tx_bd_struct_t txBuffDescrip_0[ENET_TXBD_NUM],
    FSL_ENET_BUFF_ALIGNMENT);</code></pre></div>
<p>The assumption is that since they are declared <code>static</code>, the descriptors will be
zero-initialized at system startup. However, the macro
<code>AT_NONCACHEABLE_SECTION_ALIGN</code> potentially places these descriptor in a special
section that can bypass the zero-initialization, depending on the startup code
and linker script.</p>
<p>In that case, we need to manually zero out these buffers. I put the following at
the top of <code>ethernetif_enet_init()</code> in <code>enet_ethernetif_kinetis.c</code>:</p>
<div class="codehilite"><pre><code class="language-c"><span class="c1">// Buffer descriptors must be initialized to zero</span>
<span class="nf">memset</span>(<span class="o">&amp;</span>ethernetif<span class="o">-</span><span class="o">&gt;</span>RxBuffDescrip[<span class="m">0</span>], <span class="m">0x00</span>, ENET_RXBD_NUM<span class="o">*</span><span class="nf">sizeof</span>(ethernetif<span class="o">-</span><span class="o">&gt;</span>RxBuffDescrip[<span class="m">0</span>]));
<span class="nf">memset</span>(<span class="o">&amp;</span>ethernetif<span class="o">-</span><span class="o">&gt;</span>TxBuffDescrip[<span class="m">0</span>], <span class="m">0x00</span>, ENET_TXBD_NUM<span class="o">*</span><span class="nf">sizeof</span>(ethernetif<span class="o">-</span><span class="o">&gt;</span>TxBuffDescrip[<span class="m">0</span>]));</code></pre></div>
<p><em>Credit: This bug was also found by KC.</em></p>
<hr/><section class="footnotes"><ol><li id="fn-cdc89f27-sdk" value="1">I am using SDK version 2.11.0 for the MK64FN1M0xxx12. <a href="#fnref-cdc89f27-sdk">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-linux-cubeprog">STM32MP135 Flashing via USB with STM32CubeProg</a></h2>
<div class="article-meta">Published 7 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/cal.jpg"/></p>
<p><em>This is Part 2 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In the <a href="stm32mp135-linux-default-buildroot">previous article</a>, we built a Linux
kernel and manually copied it to an SD card. This works for a first test, but
quickly becomes annoying. Here, we show how to use the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg</a>
to flash the SD card without removing it from the evaluation board.</p>
<h3 id="tutorial">Tutorial</h3>
<p>Note: You may find the extensive explanations in the <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-implementing-factory-flashing/">Bootlin article about
flashing a similar
chip</a>
helpful.</p>
<ol>
<li>
<p>Finish the build process as per the <a href="stm32mp135-linux-default-buildroot">previous
article</a>, so as to have at least the
following files under <code>buildroot/output/images/</code>:</p>
<ul>
<li>
<p><code>tf-a-stm32mp135f-dk.stm32</code></p>
</li>
<li>
<p><code>fip.bin</code></p>
</li>
<li>
<p><code>u-boot-nodtb.bin</code></p>
</li>
<li>
<p><code>sdcard.img</code></p>
</li>
</ul>
</li>
</ol>
<ol>
<li>
<p>Go to the ST website to download the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg.</a>
This unfortunately requires a registration and sign-up.</p>
<p>Get the Linux version, unpack in a new directory, and run the installer (just
follow its verbose prompts):</p>
<div class="codehilite"><pre><code class="language-sh">   $ cd cubeprog
   $ unzip ../stm32cubeprg-lin-v2-20-0.zip
   $ ./SetupSTM32CubeProgrammer-2.20.0.linux</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Now plug in all three USB cables for the board. Set the DIP boot switches for
serial boot (press in all the upper parts of the white rocker switches).
Press the black reset button. If everything worked, you should be able to see
the board under your USB devices:</p>
<div class="codehilite"><pre><code class="language-sh">   jk@Lutien:/var/www/articles$ lsusb
   ...
   Bus 001 Device 114: ID 0483:3753 STMicroelectronics STLINK-V3
   Bus 001 Device 012: ID 0483:df11 STMicroelectronics STM Device in DFU Mode
   ...</code></pre></div>
<p>The <code>STLINK-V3</code> is what you can use to monitor the flashing progress via UART.
Simply open a serial monitor:</p>
<div class="codehilite"><pre><code class="language-sh">   sudo picocom -b 115200 /dev/ttyACM0</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Run the STM32CubeProg from the location that you installed it in to check
that it is able to detect the board:</p>
<div class="codehilite"><pre><code class="language-sh">   $ sudo ~/cube/bin/STM32_Programmer_CLI -l usb
         -------------------------------------------------------------------
                           STM32CubeProgrammer v2.20.0
         -------------------------------------------------------------------
   
   =====  DFU Interface   =====
   
   Total number of available STM32 device in DFU mode: 1
   
     Device Index           : USB1
     USB Bus Number         : 001
     USB Address Number     : 002
     Product ID             : USB download gadget@Device ID /0x501, @Revision ID /0x1003, @Name /STM32MP135F Rev.Y,
     Serial number          : 002800423232511538303631
     Firmware version       : 0x0110
     Device ID              : 0x0501</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>If that worked, it’s time to prepare the images for flashing. Go to
<code>buildroot/output/images</code> and create a file <code>flash.tsv</code> with the following
contents:</p>
<div class="codehilite"><pre><code class="language-sh">   #Opt	Id	Name	Type	IP	Offset	Binary
   -	0x01	fsbl1-boot	Binary	none	0x0	tf-a-stm32mp135f-dk.stm32
   -	0x03	fip_boot	Binary		none	0x0		fip.bin
   -	0x03	ssbl-boot	Binary	none	0x0	u-boot-nodtb.bin
   P	0x10	sdcard	RawImage	mmc0		0x0	sdcard.img</code></pre></div>
<p>Finally, run the flashing command itself:</p>
<div class="codehilite"><pre><code class="language-sh">   sudo ~/cube/bin/STM32_Programmer_CLI -c port=usb1 -w flash.tsv</code></pre></div>
<p>The STM32CubeProg will go through the sequence of files you wrote into
<code>flash.tsv</code>. First, the Arm Trusted Firmware (TF-A) gets written to the
memory and executed. It then does some secure magic behind the scenes and
accepts the next payload via the DFU protocol, the U-Boot. At last, U-Boot
itself is executed and it in turn accepts the last payload: the SD card
itself. Which was, after all, the only thing you wanted to transfer anyway
...</p>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>The tutorial above again presents the simplest method I have found so far, with
a minimum of steps and prerequisites, to flash the SD card of the eval board
without taking the card in and out. What’s the issue?</p>
<p>The STM32CubeProg comes in a 291M zip file, which gets installed as a 1.5G
program. We use it to copy a disk image to the SD card. See the problem yet?
Or let’s consider the on-board procedure: TF-A (4,212 files and 506,952 lines of
code according to <a href="https://github.com/AlDanial/cloc">cloc</a>) is used to run
U-Boot (21,632 files and 3,419,116 lines of code), just so that a semi-standard
USB DFU protocol can expose the SD card to write the image.</p>
<p>But why??? ChatGPT explains:</p>
<blockquote>
<p>U-Boot became the standard since vendors upstreamed support there, and it
offers cross-platform flashing via DFU/fastboot for factories and Windows
users who can’t <code>dd</code> raw disks. It also doubles as the hook for A/B updates,
rollback, and secure boot. In practice, this forces developers into a complex
boot stack, even though most boards could just boot Linux directly from
SD/eMMC and use a tiny DFU mass-storage tool for recovery.</p>
</blockquote>
<p>A more likely explanation is that the boot process has acquired an unnecessary
reputation for being difficult, so that few want to mess with it. If there is a
working solution, it will get incorporated into the software stack, no matter
how baroque. The warning has been around for a long time:</p>
<blockquote>
<p>Big building-blocks [...] can lead to more compact code and shorter
development time. [...] Less clear, however, is how to assess the loss of
control and insight when the pile of system-supplied code gets so big that one
no longer knows what’s going on underneath.</p>
<p>[... As] libraries, interfaces, and tools become more complicated, they become
less understood and less controllable. When everything works, rich programming
environments can be very productive, but when they fail, there is little
recourse.<sup class="footnote-ref"><a href="#fn-3c3aabac-pract" id="fnref-3c3aabac-pract">[1]</a></sup></p>
</blockquote>
<p>All these tool are intended to make our work easier, but as they are piled on
without any reasonable limit, the resulting mess is ironically far more
complicated than the problem they are solving. If the task at hand is to flash
an SD card image, why doesn’t the firmware expose the medium as a USB mass
storage device, so that standard tools like <code>dd</code> could be used to work with it?
The cynical answer suggests itself ... They didn’t know better.</p>
<blockquote>
<p>Those who do not understand Unix are condemned to reinvent it, poorly.<sup class="footnote-ref"><a href="#fn-3c3aabac-ray" id="fnref-3c3aabac-ray">[2]</a></sup></p>
</blockquote>
<p>Surely it cannot be too difficult to write a simple “bare-metal” program, which
we could load to the board using the simple and well-documented UART protocol
implemented in the ROM of the STM32MP1. The program would be very small and
quick to load. The program would expose the available media as mass storage
devices, and that’s it.</p>
<p>But ... You may object, we need U-Boot anyways, otherwise how are we to load
Linux? As we will explain in a future article, that is not so. U-Boot is
entirely unnecessary for a large class of embedded Unix applications.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
<li><em>2. This article</em></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
<hr/><section class="footnotes"><ol><li id="fn-3c3aabac-pract" value="1">B. Kernighan and R. Pike Overview: The Practice of Programming. Addison-Wesley, 1999.  <a href="#fnref-3c3aabac-pract">↩</a></li><li id="fn-3c3aabac-ray" value="2">Attributed to Henry Spencer as his November 1987 Usenet signature in E. S.  Raymond: The Art of Unix Programming. Addison-Wesley, 2004. <a href="#fnref-3c3aabac-ray">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Philosophy</div>
<h2><a href="unix-contributions">What Unix Contributed</a></h2>
<div class="article-meta">Published 6 Sep 2025. By GPT-5 from notes by Jakob Kastelic.</div>
<p><img alt="" src="../images/pdp1170.jpg"/></p>
<p>Unix was built on a handful of ideas that turned out to be both powerful and
practical. The following discussion blends established Unix facts with
interpretive commentary; it does not claim to describe any single historical
Unix precisely.</p>
<h3 id="programs-and-the-shell">Programs and the Shell</h3>
<p>The shell runs commands as programs. There’s no special class of built-ins; if
you want a new command, you write a program. By default, programs read from
standard input and write to standard output, unless redirected.</p>
<p>Most commands are small filters for text streams. They do one job, and they work
together naturally. Connecting them with pipes lets you build bigger tools out
of simpler ones.</p>
<h3 id="the-file-system-abstraction">The File System Abstraction</h3>
<p>Everything is a file: user data, programs, directories, and even devices.
Directories form a tree; each entry points to an inode, which knows where the
data blocks live. Devices show up as files too.</p>
<p>This means that I/O and storage use the same calls: open, close, read, write.
That’s the interface for everything. Executables and data files are stored in
the same way, reinforcing the idea that a single abstraction suffices.</p>
<h3 id="processes-and-the-kernel">Processes and the Kernel</h3>
<p>The kernel is deliberately small. It multiplexes I/O and leaves the rest to user
programs. Even init, the first process, is just a program: it opens terminals,
prints the login message, and starts shells in a loop.</p>
<p>Processes come from the fork/exec pair. One process copies itself, then overlays
the copy with another program. The idea is simple, and it works.</p>
<p>System calls are invoked by a trap instruction, wrapped in library functions so
programs don’t depend directly on kernel details. Programs stay independent, and
the operating system can change underneath.</p>
<h3 id="small-understandable-portable">Small, Understandable, Portable</h3>
<p>Unix was small enough that one person could understand the whole thing. That
made it easier to modify, port, and teach. The manuals were short, consistent,
and focused on usage, not internals. A second volume provided tutorials and
background for those who wanted more.</p>
<p>The guiding principle was: be general, but not too general; portable, but not
too portable. If you try to solve every problem in advance, you get bloat. By
keeping it modest, Unix was more useful—and paradoxically more general and
portable—than larger systems.</p>
<h3 id="the-8020-rule">The 80/20 Rule</h3>
<p>Some parts were machine-specific, usually device drivers or bits of assembly.
But not many. Most code was reusable, and the exceptions were small. An array of
function pointers mapped device numbers to driver routines; that was about as
complex as it got. For example, a character device<sup class="footnote-ref"><a href="#fn-109c760d-devsw" id="fnref-109c760d-devsw">[1]</a></sup> driver needs to
expose the following functions:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">extern</span> <span class="k">struct</span> cdevsw
{
	<span class="k">int</span>	(<span class="o">*</span>d_open)();
	<span class="k">int</span>	(<span class="o">*</span>d_close)();
	<span class="k">int</span>	(<span class="o">*</span>d_read)();
	<span class="k">int</span>	(<span class="o">*</span>d_write)();
	<span class="k">int</span>	(<span class="o">*</span>d_ioctl)();
	<span class="k">int</span>	(<span class="o">*</span>d_stop)();
	<span class="k">struct</span> tty <span class="o">*</span>d_ttys;
} cdevsw[];</code></pre></div>
<p>The 80/20 rule applied everywhere: make most of the system simple and portable,
accept a little complexity when it really pays off. Code was meant to be 80%
reusable, not 100%, which avoided the kind of rigidity seen in later systems.</p>
<h3 id="self-hosting-and-accessible">Self-Hosting and Accessible</h3>
<p>Unix came with all its own sources and tools. It was self-hosting, and people
could read, study, and change the code. The system included what you needed, and
nothing more. No useless programs, no dead code, and very little irrelevant
platform-specific clutter.</p>
<p>The philosophy was to write programs you would actually use, not ones meant to
satisfy a standard or some hypothetical future need.</p>
<h3 id="simplicity-above-all">Simplicity Above All</h3>
<p>The enduring lesson of Unix is that simplicity beats complexity. Interfaces were
orthogonal, text was the universal medium, and programs were small and
self-contained. Each one did one thing, and did it well.</p>
<p>That philosophy proved more important than any single feature. It made Unix
portable, teachable, and durable. It showed that you don’t need a committee or a
grand design to build something powerful. You need clarity, restraint, and the
discipline to write only what you need.</p>
<h3 id="reflections-and-extensions">Reflections and Extensions</h3>
<p>Unix also suggests how to go further. Small, portable, self-contained programs
can approach the kind of stability that TeX achieved—systems so refined that
they don’t need to change.</p>
<p>Portability itself can be modular. The Wollongong group<sup class="footnote-ref"><a href="#fn-109c760d-wol" id="fnref-109c760d-wol">[2]</a></sup> showed this by first
porting Unix piece by piece to an Interdata 7/32, running it alongside the host
system, and then replacing the host functions with assembly routines. That
approach points toward kernels that are more modular, where pieces like fork and
exec could be reused without bringing along a whole scheduler.</p>
<p>Device drivers can also be simplified. One idea is to treat them as user
processes whose IDs match their device numbers. They would implement the usual
open, read, and write interfaces, but otherwise behave like ordinary programs:
start and stop freely, hold their own memory, receive signals. The kernel would
not “manage” them, yet the familiar Unix file interface would still apply.</p>
<p>The same lesson holds today. Artificial intelligence can sometimes repair or
adapt programs automatically, but only if the systems are small and
self-contained. Large, tangled software offers no foothold. Unix worked because
it avoided dead code, avoided over-abstraction, and made each interface simple
enough to understand and replace.</p>
<p>Finally, Unix showed that the way forward can’t be too innovative. <em>If “the way”
is too radical, no one will follow it.</em><sup class="footnote-ref"><a href="#fn-109c760d-rad" id="fnref-109c760d-rad">[3]</a></sup> The genius of Unix was that it was
just radical enough.</p>
<hr/><section class="footnotes"><ol><li id="fn-109c760d-devsw" value="1">From version 7 Unix, found in <a href="https://www.tuhs.org/cgi-bin/utree.pl?file=V7/usr/sys/h/conf.h"><code>/usr/sys/h/conf.h</code></a>. <a href="#fnref-109c760d-devsw">↩</a></li><li id="fn-109c760d-wol" value="2">Juris Reinfelds: <a href="https://www.tuhs.org/Archive/Distributions/Other/Interdata/uow103747.pdf"><em>The First Port of Unix.</em></a> Department of Computing Science, The University of Wollongong. See also Richard Miller: <a href="http://bitsavers.informatik.uni-stuttgart.de/bits/Interdata/32bit/unix/univWollongong_v6/miller.pdf"><em>The First Unix Port.</em></a> Miller Research Ltd. (Both documents undated. Why don’t people date all their documents!?)  <a href="#fnref-109c760d-wol">↩</a></li><li id="fn-109c760d-rad" value="3">Still looking for the source of this quote ...  <a href="#fnref-109c760d-rad">↩</a></li></ol></section>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Linux</div>
<h2><a href="stm32mp135-linux-default-buildroot">STM32MP135 Default Buildroot Configuration</a></h2>
<div class="article-meta">Published 3 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/vax.jpg"/></p>
<p><em>This is Part 1 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>Wouldn’t it be great to have a single board computer that runs <em>just Linux</em>?
That is, no external libraries, tools, driver modules—just the kernel binary,
and whichever programs you <em>choose</em> to run under it. After all, Linux is just a
C program, so how hard can it be to compile and run it? Read on to get started
exploring the wild world of embedded Linux.</p>
<h3 id="tutorial">Tutorial</h3>
<p>In this tutorial, we show how to get a basic “minimal” Linux installed on the
<a href="https://www.st.com/en/evaluation-tools/stm32mp135f-dk.html">STM32MP135 evaluation
board</a> with a
minimum of steps or obscure scripts. For detailed explanations, refer to the
excellent writeup from <a href="
https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-basic-system/">Bootlin.</a></p>
<ol>
<li>
<p>Get a copy of Buildroot:</p>
<div class="codehilite"><pre><code class="language-sh">   $ git clone https://gitlab.com/buildroot.org/buildroot.git
   $ cd buildroot</code></pre></div>
<p>As of this writing, the latest commit in this repository is</p>
<div class="codehilite"><pre><code class="language-sh">   $ git rev-parse HEAD
   bbb0164de08f761a3399c961700db44befff5c70</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Find the default configuration appropriate for this board:</p>
<div class="codehilite"><pre><code class="language-sh">   $ make list-defconfigs | grep stm32mp135</code></pre></div>
<p>This shows that <code>stm32mp135f_dk_defconfig</code> is available. Install it by calling
make on it:</p>
<div class="codehilite"><pre><code class="language-sh">   $ make stm32mp135f_dk_defconfig</code></pre></div>
<p>Let’s enable the USB mode for Arm Trusted Firmware (TF-A) so that we will be
able to use USB flashing in the future. Open</p>
<div class="codehilite"><pre><code class="language-sh">   $ make menuconfig</code></pre></div>
<p>Navigate under <code>Bootloaders ---&gt;  ARM Trusted Firmware (ATF)</code> and add the
following at the end of the “Additional ATF build variables” string:</p>
<div class="codehilite"><pre><code class="language-text">   STM32MP_USB_PROGRAMMER=1</code></pre></div>
<p>Then select “OK”, and “Esc” your way out of the menuconfig. Make sure to say
“Yes” when asked whether to save the new configuration.</p>
</li>
</ol>
<ol>
<li>
<p>Run the build, and collect logs into a file:</p>
<div class="codehilite"><pre><code class="language-sh">   $ time make &gt;log.txt 2&gt;&amp;1</code></pre></div>
<p>On my dual-core i5-7300U laptop, this took about an hour and a half.</p>
<p>Watch the build from another terminal:</p>
<div class="codehilite"><pre><code class="language-sh">   $ tail -f log.txt</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Copy the generated image to an SD card (assumed to be at <code>/dev/sdb</code>):</p>
<div class="codehilite"><pre><code class="language-sh">   $ sudo dd if=output/images/sdcard.img of=dev/sdb bs=1M</code></pre></div>
</li>
</ol>
<ol>
<li>
<p>Time to run it on the evaluation board! Set it up as follows:</p>
<ul>
<li>
<p>Insert the SD card into the slot</p>
</li>
<li>
<p>Connect the USB-C port to the right of the screen (<code>CN12</code>, labelled <code>PWR_IN</code>)
to a powered USB hub</p>
</li>
<li>
<p>Connect the Micro USB (<code>CN10</code>, left of the screen) to a desktop computer,
which will enumerate as a serial port (<code>/dev/ttyACM0</code> on my computer).</p>
</li>
<li>
<p>Open a serial console (115200 baud, no parity) to listen</p>
</li>
</ul>
<p><img alt="" src="../images/board.jpg"/></p>
<p>Set the DIP switches to boot from the SD card as shown in the image below. In
this orientation, press in on the upper side of the rockers of <code>BOOT0</code> and
<code>BOOT2</code>, and on the lower side for <code>BOOT1</code>.</p>
<p><img alt="" src="../images/buttons.jpg"/></p>
<p>Press the black reset button and if everything went right, you should see the
kernel boot messages displayed on the serial monitor, until the login prompt
gets displayed. Done!</p>
<div class="codehilite"><pre><code class="language-text">   Welcome to Buildroot
   buildroot login: root
   # uname -a
   Linux buildroot 6.12.22 #1 SMP PREEMPT Wed Sep  3 20:23:46 PDT 2025 armv7l GNU/Linux</code></pre></div>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>This is, to my knowledge, the fastest way to get started with embedded Linux on
“real” hardware in terms of number of steps. However, it does not result in the
most minimal distribution. Besides the Linux kernel, the default configuration
pulls in a number of large programs, such as U-Boot, ATF, OP-TEE, and more.
(Examine <code>buildroot/dl</code>) after building to see all the stuff that got downloaded
in the build process.)</p>
<p>For someone used to bare-metal embedded work, the size and complexity of this
auxiliary software is utterly baffling. A bootloader with more lines of code
than my whole project? Several different compilers and interpreters (C, Rust,
Perl, Python) needed for a “Hello, world!?”</p>
<p>In my mind I hold an ideal of the “pure” essence of Unix: there is one kernel,
which at the end of its boot process invokes one user-space program (<code>init</code>),
which then does anything it wants to. I believe in the simplicity of the Linux
boot process, as outlined by Russell King in the 2002 masterpiece, <a href="https://www.kernel.org/doc/Documentation/arm/Booting">”Booting ARM
Linux”</a>:</p>
<ol>
<li>
<p>Initialize RAM and copy the kernel into it</p>
</li>
<li>
<p>Initialise one serial port</p>
</li>
<li>
<p>Load the device tree blob (DTB) into RAM, and place its address in <code>r2</code></p>
</li>
<li>
<p>Pass control to Linux and watch it boot like magic!</p>
</li>
</ol>
<p>It is time we regain the pristine uncomplicated state that used to exist before
everything became bundled and containerized and wrapped inside countless layers
of abstraction that are supposed to make things simpler, but in the end serve
only to confuse everyone.</p>
<p>In the next articles, we will take this “primordial mess” and cut it down to
size. Stay tuned!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
<li><em>1. This article</em></li>
<li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
<li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
<li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
<li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
<li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
<li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
<li><a href="debugging-stm32mp135-kernel-decompression">8. Debugging STM32MP135 Kernel Decompression</a></li>
</ul>
</div>
</div>

<div class="article-sep"></div>

<div class="article">
<div class="article-topic">Embedded</div>
<h2><a href="circ_uart_dma_k64">UART DMA with a Circular Buffer on K64</a></h2>
<div class="article-meta">Published 2 Sep 2025. By Jakob Kastelic.</div>
<p><img alt="" src="../images/circ.jpg"/></p>
<p>Working on a FreeRTOS-based project running on the NXP Kinetis K64, I wanted to
read data from several UART interfaces. The default “easy” method using
interrupts is easy to set up via the NXP MCUXpresso Config Tools; the problem is
that the UART peripheral only has a few bytes of built-in buffer. If the data is
arriving at the interfaces faster than the firmware can read it, the tiny buffer
immediately overflows and part of the data is lost.</p>
<p>This is obviously a task for Direct Memory Access (DMA): let the data arrive
into a much larger buffer, from where the software can take characters at its
leisure. In this article, we will briefly contrast three ways of receiving data
from UART: interrupt-based, simple DMA, and DMA with a circular buffer (aka ring
buffer).</p>
<h3 id="uart-with-interrupts">UART with Interrupts</h3>
<p>The “point-and-click” method works out of the box with the Config tools. Leave
things at their default values, or change whatever is necessary. In my setup, I
had the values shown in the image below.</p>
<p><img alt="Config Tools: UART Interrupt Configuration" src="../images/inter.jpg"/></p>
<p>Even the interrupt handler is provided by the tool. Click on “Copy to
clipboard”, and adapt as necessary. All that is needed is to read the status
flags and read a byte of data, and push it to a FreeRTOS queue that we set up
previously:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">void</span> <span class="nf">UART0_SERIAL_RX_TX_IRQHANDLER</span>(<span class="k">void</span>)
{
   uint32_t intStatus <span class="o">=</span> <span class="nf">UART_GetStatusFlags</span>(UART0);
   <span class="k">if</span> ((kUART_RxDataRegFullFlag <span class="o">|</span> kUART_RxOverrunFlag) <span class="o">&amp;</span> intStatus) {
      <span class="k">const</span> uint8_t data <span class="o">=</span> <span class="nf">UART_ReadByte</span>(UART0);
      <span class="nf">xQueueSendToBackFromISR</span>(rx_queue, <span class="o">&amp;</span>data, NULL);
   }
}</code></pre></div>
<p>This seems like it couldn’t be simpler, and it just <em>should</em> work. Indeed, for
baud rates at or below about 9600, it does work almost reliably. And yet
sometimes, for no good reason, a byte gets dropped. Is that possible?</p>
<p>Let’s see. At 115,200 baud, we get a character every 8.7 μs. It’s entirely
possible that some other interrupt or critical section takes priority over this
one for much longer than that, especially looking at some of the rather long
Ethernet ISRs supplied with the NXP SDK. If we have less than 10 microseconds to
process a character before it goes away, we’ll probably miss many of them!
Onwards to DMA.</p>
<h3 id="uart-with-edma">UART with eDMA</h3>
<p>With direct memory access, the UART peripheral should be able to place the bytes
directly in a software buffer, without having to go through an RTOS queue.
Besides being much faster, we can also make the queue almost arbitrarily large,
ensuring that we’ll be able to get to the data eventually and process it.</p>
<p>Thanks to the Config Tools, setting this up is again very straightforward. Just
enable some checkboxes and set up DMA channels, as I did in the image below.</p>
<p><img alt="Config Tools: UART eDMA Configuration" src="../images/edma.jpg"/></p>
<p>This time, we do not have a handy “Click to get code” button. Instead, ChatGPT
or Gemini or Claude are happy to write something that nearly works. In a
dedicated FreeRTOS task, let’s poll for characters as they arrive into the
buffer:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">for</span> (;;) {
   uint32_t bytesWritten;
   <span class="k">if</span> (<span class="nf">UART_TransferGetReceiveCountEDMA</span>(UART0_PERIPHERAL,
            <span class="o">&amp;</span>UART0_UART_eDMA_Handle,
            <span class="o">&amp;</span>bytesWritten) <span class="o">!</span><span class="o">=</span> kStatus_Success) {
      <span class="nf">vTaskDelay</span>(<span class="nf">pdMS_TO_TICKS</span>(<span class="m">1</span>));
      <span class="k">continue</span>;
   }

   <span class="k">while</span> (readIndex <span class="o">!</span><span class="o">=</span> (bytesWritten <span class="o">%</span> DMA_BUF_SIZE)) {
      <span class="k">char</span> c <span class="o">=</span> uartRxBuf[readIndex];
      readIndex <span class="o">=</span> (readIndex <span class="o">+</span> <span class="m">1</span>) <span class="o">%</span> DMA_BUF_SIZE;
      <span class="c1">// now do what you want with the received character</span>
   }

   <span class="nf">vTaskDelay</span>(<span class="m">1</span>);
}</code></pre></div>
<p>Note the <code>vTaskDelay(1)</code> calls which ensure that this task does not starve
lower-priority tasks of processor time.</p>
<p>In the above, the chatbot made use of the function
<code>UART_TransferGetReceiveCountEDMA()</code> from the NXP SDK and implemented the ring
buffer wraparound with some modulo operation that’s probably about correct. But
what happens when the buffer gets filled up? In that case, an interrupt triggers
the DMA callback, which simply restarts the DMA to receive data back into the
beginning of the buffer:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">static</span> <span class="k">void</span> <span class="nf">uart0_callback</span>(UART_Type <span class="o">*</span>base, uart_edma_handle_t <span class="o">*</span>handle,
                           status_t status, <span class="k">void</span> <span class="o">*</span>userData)
{
    uart_transfer_t rxXfer <span class="o">=</span> {
        .data <span class="o">=</span> uartRxBuf,
        .dataSize <span class="o">=</span> DMA_BUF_SIZE
    };
    <span class="nf">UART_ReceiveEDMA</span>(UART0_PERIPHERAL, handle, <span class="o">&amp;</span>rxXfer);
}</code></pre></div>
<p>This works great, but has an unfortunate limitation. When the buffer is at the
end of its capacity, characters must arrive slowly enough so we have time to
re-start the DMA. In other words, we have not solved anything! Data will
occasionally get lost when the callback is executing.</p>
<p>Naturally, the DMA should be writing continuously without us having to restart
it. Much back and forth with AI achieved nothing. The version of the NXP SDK
that I’m using, while full of intricate code covering what appears to be almost
every possible use case, somehow does not cover the most elementary DMA
operation: continuous data reception.</p>
<h3 id="true-continuous-dma-ring-buffer">True continuous DMA ring buffer</h3>
<p>This brings us to the final section: how to make the ring buffer work without
stopping? By my count, the SDK takes 4517 lines of C to implement the
“simplified” DMA configuration code, and yet there’s no easy
<code>UART_MakeMeARingBuffer()</code>. There are 80 pages in the K64 Sub-Family Reference
Manual about the DMA, and 85 about UART, with lots of tables of registers, flow
charts, diagrams. Enough to leave one entirely mystified.</p>
<p>The key revelation here is that the <em>DMA peripheral is not nearly as complicated
as NXP would have us believe.</em> As it turns out, there are only a couple fields
one has to fill out in the “transfer control descriptor” (TCD): source and
address of the data, the size of each logical word (for UART: one byte), how
many bytes to write altogether, and what to do after writing them.</p>
<p>To integrate it with the code generated by the Config Tools above, we need the
handles to the UART and eDMA controls, and a buffer to place the data in:</p>
<div class="codehilite"><pre><code class="language-c">UART_Type <span class="o">*</span>uart <span class="o">=</span> UART0_PERIPHERAL;
edma_handle_t <span class="o">*</span>dma <span class="o">=</span> <span class="o">&amp;</span>UART1_RX_Handle;

<span class="cp">#define</span> BUF_SIZE <span class="m">256</span>
<span class="k">static</span> uint8_t buf[BUF_SIZE];</code></pre></div>
<p>Next, we define the source (UART buffer) and destination for the data:</p>
<div class="codehilite"><pre><code class="language-c">edma_tcd_t <span class="o">*</span>tcd <span class="o">=</span> (edma_tcd_t <span class="o">*</span>)<span class="o">&amp;</span>dma<span class="o">-</span><span class="o">&gt;</span>base<span class="o">-</span><span class="o">&gt;</span>TCD[dma<span class="o">-</span><span class="o">&gt;</span>channel];
tcd<span class="o">-</span><span class="o">&gt;</span>SADDR <span class="o">=</span> <span class="nf">UART_GetDataRegisterAddress</span>(uart);
tcd<span class="o">-</span><span class="o">&gt;</span>DADDR <span class="o">=</span> (uint32_t)buf;</code></pre></div>
<p>Fill in the source and destination offset, number of bytes to transfer at once
(just one byte), and number of bytes to transfer in a so-called “major loop”
(equal to the size of the ring buffer):</p>
<div class="codehilite"><pre><code class="language-c">tcd<span class="o">-</span><span class="o">&gt;</span>SOFF <span class="o">=</span> <span class="m">0</span>;
tcd<span class="o">-</span><span class="o">&gt;</span>DOFF <span class="o">=</span> <span class="m">1</span>;
tcd<span class="o">-</span><span class="o">&gt;</span>NBYTES <span class="o">=</span> <span class="m">1</span>;
tcd<span class="o">-</span><span class="o">&gt;</span>ATTR <span class="o">=</span> <span class="nf">DMA_ATTR_SSIZE</span>(kEDMA_TransferSize1Bytes) <span class="o">|</span> <span class="nf">DMA_ATTR_DSIZE</span>(kEDMA_TransferSize1Bytes);
tcd<span class="o">-</span><span class="o">&gt;</span>CITER <span class="o">=</span> BUF_SIZE;
tcd<span class="o">-</span><span class="o">&gt;</span>BITER <span class="o">=</span> BUF_SIZE;
tcd<span class="o">-</span><span class="o">&gt;</span>DLAST_SGA <span class="o">=</span> <span class="o">-</span>BUF_SIZE;</code></pre></div>
<p>Note the <code>DLAST_SGA</code> field: it causes the write address to be rewound back to
the start of the data buffer upon completing the major loop. This is really all
that’s needed to create a true circular ring buffer that runs without stopping.</p>
<p>Finally, to make it run, we need to enable the DMA service request from both the
eDMA and UART sides:</p>
<div class="codehilite"><pre><code class="language-c">dma<span class="o">-</span><span class="o">&gt;</span>base<span class="o">-</span><span class="o">&gt;</span>SERQ <span class="o">=</span> <span class="nf">DMA_SERQ_SERQ</span>(dma<span class="o">-</span><span class="o">&gt;</span>channel);
uart<span class="o">-</span><span class="o">&gt;</span>C5 <span class="o">|</span><span class="o">=</span> (uint8_t)UART_C5_RDMAS_MASK;
uart<span class="o">-</span><span class="o">&gt;</span>C2 <span class="o">|</span><span class="o">=</span> (uint8_t)UART_C2_RIE_MASK;</code></pre></div>
<p><em>Beware:</em> If making use of any NXP-provided functions, know that several of them
implicitly set the <code>DREQ</code> bit (“Disable Request”) which will stop DMA once a
single major loop is complete. As the Reference Manual puts it,</p>
<blockquote>
<p><code>DREQ</code> (Disable Request) If this flag is set, the eDMA hardware automatically
clears the corresponding <code>ERQ</code> bit when the current major iteration count
reaches zero.</p>
</blockquote>
<h3 id="readout-from-the-buffer">Readout from the buffer</h3>
<p>Once the DMA is happily streaming UART bytes into the buffer, we would like to
get it out.  The simplest way to do so would be a character at a time,
<code>getc</code>-style.</p>
<p><em>Step One:</em> consult the DMA registers about the current iteration inside a major
loop:</p>
<div class="codehilite"><pre><code class="language-c">uint32_t ch   <span class="o">=</span> dma<span class="o">-</span><span class="o">&gt;</span>channel;
<span class="k">const</span> uint16_t biter <span class="o">=</span> dma<span class="o">-</span><span class="o">&gt;</span>base<span class="o">-</span><span class="o">&gt;</span>TCD[ch].BITER_ELINKNO;
<span class="k">const</span> uint16_t citer <span class="o">=</span> dma<span class="o">-</span><span class="o">&gt;</span>base<span class="o">-</span><span class="o">&gt;</span>TCD[ch].CITER_ELINKNO;</code></pre></div>
<p><em>Step Two:</em> compute the number of bytes available in the buffer.</p>
<div class="codehilite"><pre><code class="language-c">size_t write_index <span class="o">=</span> (biter <span class="o">-</span> citer) <span class="o">%</span> UART_DMA_BUF_SIZE;
<span class="k">int</span> avail <span class="o">=</span> <span class="m">0</span>;
<span class="k">if</span> (write_index <span class="o">&gt;</span><span class="o">=</span> <span class="o">*</span>head) {
   avail <span class="o">=</span> write_index <span class="o">-</span> <span class="o">*</span>head;
} <span class="k">else</span> {
   avail <span class="o">=</span> (UART_DMA_BUF_SIZE <span class="o">-</span> <span class="o">*</span>head) <span class="o">+</span> write_index;
}</code></pre></div>
<p><em>Step Three:</em> If any bytes are available for readout, let’s read it out (into
the variable <code>c</code>), then advance the queue pointer:</p>
<div class="codehilite"><pre><code class="language-c"><span class="k">if</span> (avail) {
   uint8_t c <span class="o">=</span> buf[<span class="o">*</span>head];
   <span class="o">*</span>head <span class="o">=</span> (<span class="o">*</span>head <span class="o">+</span> <span class="m">1</span>) <span class="o">%</span> UART_DMA_BUF_SIZE;
}</code></pre></div>
<p>That’s it!</p>
<h3 id="conclusion">Conclusion</h3>
<p>My intention with this writeup was to show that DMA configuration on the Kinetis
K64 is very simple once one learns to let go of the tools that are supposed to
make it easier: the NXP SDK, the Config Tools GUI, the Reference Manual. 17
lines of code is all it takes to configure a UART ring buffer with DMA!</p>
<p>Direct manipulation of system registers may appear confusing. After all, where
is one supposed to learn which are all the registers that must be set? The SDK
is often the only entry point, but it’s discouraging: confusing,
over-engineered, and ironically missing the simplest features.</p>
<p>It’s an amusing experience to take the “official” code examples and manually
inline all the functions, unfolding the complex call chain into hundreds of
lines of code. Once all the unnecessary conditional compilation and inapplicable
conditions are removed, you can often be left with just a handful of lines of
simple code which, with the help of the reference manual, is pretty readable.
Certainly more than the mostly undocumented, partially implemented SDK morass of
functions, drivers, modules, what have you!</p>
</div>

    <div class="nav-links" style="display:flex; justify-content:space-between;">
        <div><a class="older" href="page7.html">← Older articles</a></div>
        <div><a class="newer" href="page5.html">Newer articles →</a></div>
    </div>
    
<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>
</body>
</html>
