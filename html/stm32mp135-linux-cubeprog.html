<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="7 Sep 2025">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Learn how to flash Linux to the STM32MP135 evaluation board over USB using STM32CubeProg, without removing the SD card. Step-by-step tutorial with commands, setup tips, and discussion of the complex STM32 boot stack.">
<link rel="stylesheet" href="style.css">
<title>STM32MP135 Flashing via USB with STM32CubeProg</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Linux</div>
<h2>STM32MP135 Flashing via USB with STM32CubeProg</h2>
<div class="article-meta">Published 7 Sep 2025. Written by Jakob Kastelic.</div>
<p><img src="../images/cal.jpg" alt="" /></p>
<p><em>This is Part 2 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>In the <a href="stm32mp135-linux-default-buildroot">previous article</a>, we built a Linux
kernel and manually copied it to an SD card. This works for a first test, but
quickly becomes annoying. Here, we show how to use the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg</a>
to flash the SD card without removing it from the evaluation board.</p>
<h3 id="tutorial">Tutorial</h3>
<p>Note: You may find the extensive explanations in the <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-implementing-factory-flashing/">Bootlin article about
flashing a similar
chip</a>
helpful.</p>
<ol>
<li>
<p>Finish the build process as per the <a href="stm32mp135-linux-default-buildroot">previous
article</a>, so as to have at least the
following files under <code>buildroot/output/images/</code>:</p>
<ul>
<li><code>tf-a-stm32mp135f-dk.stm32</code></li>
<li><code>fip.bin</code></li>
<li><code>u-boot-nodtb.bin</code></li>
<li><code>sdcard.img</code></li>
</ul>
</li>
<li>
<p>Go to the ST website to download the
<a href="https://www.st.com/en/development-tools/stm32cubeprog.html#get-software">STM32CubeProg.</a>
This unfortunately requires a registration and sign-up.</p>
<p>Get the Linux version, unpack in a new directory, and run the installer (just
follow its verbose prompts):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>cubeprog
$<span class="w"> </span>unzip<span class="w"> </span>../stm32cubeprg-lin-v2-20-0.zip
$<span class="w"> </span>./SetupSTM32CubeProgrammer-2.20.0.linux
</pre></div>
</code></pre>
</li>
<li>
<p>Now plug in all three USB cables for the board. Set the DIP boot switches for
serial boot (press in all the upper parts of the white rocker switches).
Press the black reset button. If everything worked, you should be able to see
the board under your USB devices:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>jk@Lutien:/var/www/articles$<span class="w"> </span>lsusb
...
Bus<span class="w"> </span><span class="m">001</span><span class="w"> </span>Device<span class="w"> </span><span class="m">114</span>:<span class="w"> </span>ID<span class="w"> </span><span class="m">0483</span>:3753<span class="w"> </span>STMicroelectronics<span class="w"> </span>STLINK-V3
Bus<span class="w"> </span><span class="m">001</span><span class="w"> </span>Device<span class="w"> </span><span class="m">012</span>:<span class="w"> </span>ID<span class="w"> </span><span class="m">0483</span>:df11<span class="w"> </span>STMicroelectronics<span class="w"> </span>STM<span class="w"> </span>Device<span class="w"> </span><span class="k">in</span><span class="w"> </span>DFU<span class="w"> </span>Mode
...
</pre></div>
</code></pre>
<p>The <code>STLINK-V3</code> is what you can use to monitor the flashing progress via UART.
Simply open a serial monitor:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>sudo<span class="w"> </span>picocom<span class="w"> </span>-b<span class="w"> </span><span class="m">115200</span><span class="w"> </span>/dev/ttyACM0
</pre></div>
</code></pre>
</li>
<li>
<p>Run the STM32CubeProg from the location that you installed it in to check
that it is able to detect the board:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>~/cube/bin/STM32_Programmer_CLI<span class="w"> </span>-l<span class="w"> </span>usb
<span class="w">      </span>-------------------------------------------------------------------
<span class="w">                        </span>STM32CubeProgrammer<span class="w"> </span>v2.20.0
<span class="w">      </span>-------------------------------------------------------------------

<span class="o">=====</span><span class="w">  </span>DFU<span class="w"> </span><span class="nv">Interface</span><span class="w">   </span><span class="o">=====</span>

Total<span class="w"> </span>number<span class="w"> </span>of<span class="w"> </span>available<span class="w"> </span>STM32<span class="w"> </span>device<span class="w"> </span><span class="k">in</span><span class="w"> </span>DFU<span class="w"> </span>mode:<span class="w"> </span><span class="m">1</span>

<span class="w">  </span>Device<span class="w"> </span>Index<span class="w">           </span>:<span class="w"> </span>USB1
<span class="w">  </span>USB<span class="w"> </span>Bus<span class="w"> </span>Number<span class="w">         </span>:<span class="w"> </span><span class="m">001</span>
<span class="w">  </span>USB<span class="w"> </span>Address<span class="w"> </span>Number<span class="w">     </span>:<span class="w"> </span><span class="m">002</span>
<span class="w">  </span>Product<span class="w"> </span>ID<span class="w">             </span>:<span class="w"> </span>USB<span class="w"> </span>download<span class="w"> </span>gadget@Device<span class="w"> </span>ID<span class="w"> </span>/0x501,<span class="w"> </span>@Revision<span class="w"> </span>ID<span class="w"> </span>/0x1003,<span class="w"> </span>@Name<span class="w"> </span>/STM32MP135F<span class="w"> </span>Rev.Y,
<span class="w">  </span>Serial<span class="w"> </span>number<span class="w">          </span>:<span class="w"> </span><span class="m">002800423232511538303631</span>
<span class="w">  </span>Firmware<span class="w"> </span>version<span class="w">       </span>:<span class="w"> </span>0x0110
<span class="w">  </span>Device<span class="w"> </span>ID<span class="w">              </span>:<span class="w"> </span>0x0501
</pre></div>
</code></pre>
</li>
<li>
<p>If that worked, it’s time to prepare the images for flashing. Go to
<code>buildroot/output/images</code> and create a file <code>flash.tsv</code> with the following
contents:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span><span class="c1">#Opt	Id	Name	Type	IP	Offset	Binary</span>
-<span class="w">	</span>0x01<span class="w">	</span>fsbl1-boot<span class="w">	</span>Binary<span class="w">	</span>none<span class="w">	</span>0x0<span class="w">	</span>tf-a-stm32mp135f-dk.stm32
-<span class="w">	</span>0x03<span class="w">	</span>fip_boot<span class="w">	</span>Binary<span class="w">		</span>none<span class="w">	</span>0x0<span class="w">		</span>fip.bin
-<span class="w">	</span>0x03<span class="w">	</span>ssbl-boot<span class="w">	</span>Binary<span class="w">	</span>none<span class="w">	</span>0x0<span class="w">	</span>u-boot-nodtb.bin
P<span class="w">	</span>0x10<span class="w">	</span>sdcard<span class="w">	</span>RawImage<span class="w">	</span>mmc0<span class="w">		</span>0x0<span class="w">	</span>sdcard.img
</pre></div>
</code></pre>
<p>Finally, run the flashing command itself:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>sudo<span class="w"> </span>~/cube/bin/STM32_Programmer_CLI<span class="w"> </span>-c<span class="w"> </span><span class="nv">port</span><span class="o">=</span>usb1<span class="w"> </span>-w<span class="w"> </span>flash.tsv
</pre></div>
</code></pre>
<p>The STM32CubeProg will go through the sequence of files you wrote into
<code>flash.tsv</code>. First, the Arm Trusted Firmware (TF-A) gets written to the
memory and executed. It then does some secure magic behind the scenes and
accepts the next payload via the DFU protocol, the U-Boot. At last, U-Boot
itself is executed and it in turn accepts the last payload: the SD card
itself. Which was, after all, the only thing you wanted to transfer anyway
…</p>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>The tutorial above again presents the simplest method I have found so far, with
a minimum of steps and prerequisites, to flash the SD card of the eval board
without taking the card in and out. What’s the issue?</p>
<p>The STM32CubeProg comes in a 291M zip file, which gets installed as a 1.5G
program. We use it to copy a disk image to the SD card. See the problem yet?
Or let’s consider the on-board procedure: TF-A (4,212 files and 506,952 lines of
code according to <a href="https://github.com/AlDanial/cloc">cloc</a>) is used to run
U-Boot (21,632 files and 3,419,116 lines of code), just so that a semi-standard
USB DFU protocol can expose the SD card to write the image.</p>
<p>But why??? ChatGPT explains:</p>
<blockquote>
<p>U-Boot became the standard since vendors upstreamed support there, and it
offers cross-platform flashing via DFU/fastboot for factories and Windows
users who can’t <code>dd</code> raw disks. It also doubles as the hook for A/B updates,
rollback, and secure boot. In practice, this forces developers into a complex
boot stack, even though most boards could just boot Linux directly from
SD/eMMC and use a tiny DFU mass-storage tool for recovery.</p>
</blockquote>
<p>A more likely explanation is that the boot process has acquired an unnecessary
reputation for being difficult, so that few want to mess with it. If there is a
working solution, it will get incorporated into the software stack, no matter
how baroque. The warning has been around for a long time:</p>
<blockquote>
<p>Big building-blocks […] can lead to more compact code and shorter
development time. […] Less clear, however, is how to assess the loss of
control and insight when the pile of system-supplied code gets so big that one
no longer knows what’s going on underneath.</p>
<p>[… As] libraries, interfaces, and tools become more complicated, they become
less understood and less controllable. When everything works, rich programming
environments can be very productive, but when they fail, there is little
recourse.<sup class="footnote-ref"><a href="#805e1fa9-fn1" id="805e1fa9-fnref1">[1]</a></sup></p>
</blockquote>
<p>All these tool are intended to make our work easier, but as they are piled on
without any reasonable limit, the resulting mess is ironically far more
complicated than the problem they are solving. If the task at hand is to flash
an SD card image, why doesn’t the firmware expose the medium as a USB mass
storage device, so that standard tools like <code>dd</code> could be used to work with it?
The cynical answer suggests itself … They didn’t know better.</p>
<blockquote>
<p>Those who do not understand Unix are condemned to reinvent it, poorly.<sup class="footnote-ref"><a href="#805e1fa9-fn2" id="805e1fa9-fnref2">[2]</a></sup></p>
</blockquote>
<p>Surely it cannot be too difficult to write a simple “bare-metal” program, which
we could load to the board using the simple and well-documented UART protocol
implemented in the ROM of the STM32MP1. The program would be very small and
quick to load. The program would expose the available media as mass storage
devices, and that’s it.</p>
<p>But … You may object, we need U-Boot anyways, otherwise how are we to load
Linux? As we will explain in a future article, that is not so. U-Boot is
entirely unnecessary for a large class of embedded Unix applications.</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
  <li><a href="stm32mp135-linux-default-buildroot">1. STM32MP135 Default Buildroot Configuration</a></li>
  <li><em>2. This article</em></li>
  <li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
  <li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
  <li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
  <li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
  <li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="805e1fa9-fn1" class="footnote-item"><p>B. Kernighan and R. Pike Overview: The Practice of Programming.
Addison-Wesley, 1999. <a href="#805e1fa9-fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="805e1fa9-fn2" class="footnote-item"><p>Attributed to Henry Spencer as his November 1987 Usenet signature in E.
S.  Raymond: The Art of Unix Programming. Addison-Wesley, 2004. <a href="#805e1fa9-fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</div>

<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>

</body>
</html>
