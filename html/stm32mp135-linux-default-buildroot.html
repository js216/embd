<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="author" content="Jakob Kastelic">
<meta name="date" content="3 Sep 2025">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Step-by-step tutorial for installing a minimal Linux system on the STM32MP135 evaluation board using Buildroot. Learn how to configure, build, and boot Linux from an SD card, with discussion of default components like U-Boot, ATF, and OP-TEE.">
<link rel="stylesheet" href="style.css">
<title>STM32MP135 Default Buildroot Configuration</title>
</head>
<header class="site-banner">
<div class="logo">
<a href="http://embd.cc"><img src="favicon.ico" alt="logo">embd.cc</a>
</div>
<nav class="site-nav">
<a href="archive">Archive</a>
<a href="about">About</a>
</nav>
</header>
<body>
<div class="article">
<div class="article-topic">Linux</div>
<h2>STM32MP135 Default Buildroot Configuration</h2>
<div class="article-meta">Published 3 Sep 2025, modified 10 Sep 2025. Written by Jakob Kastelic.</div>
<p><img src="../images/vax.jpg" alt="" /></p>
<p><em>This is Part 1 in the series: Linux on STM32MP135. <a href="#series-list">See other
articles.</a></em></p>
<p>Wouldn’t it be great to have a single board computer that runs <em>just Linux</em>?
That is, no external libraries, tools, driver modules—just the kernel binary,
and whichever programs you <em>choose</em> to run under it. After all, Linux is just a
C program, so how hard can it be to compile and run it? Read on to get started
exploring the wild world of embedded Linux.</p>
<h3 id="tutorial">Tutorial</h3>
<p>In this tutorial, we show how to get a basic “minimal” Linux installed on the
<a href="https://www.st.com/en/evaluation-tools/stm32mp135f-dk.html">STM32MP135 evaluation
board</a> with a
minimum of steps or obscure scripts. For detailed explanations, refer to the
excellent writeup from <a href="https://bootlin.com/blog/building-a-linux-system-for-the-stm32mp1-basic-system/">Bootlin.</a></p>
<ol>
<li>
<p>Get a copy of Buildroot:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://gitlab.com/buildroot.org/buildroot.git
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>buildroot
</pre></div>
</code></pre>
<p>As of this writing, the latest commit in this repository is</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>git<span class="w"> </span>rev-parse<span class="w"> </span>HEAD
bbb0164de08f761a3399c961700db44befff5c70
</pre></div>
</code></pre>
</li>
<li>
<p>Find the default configuration appropriate for this board:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>list-defconfigs<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>stm32mp135
</pre></div>
</code></pre>
<p>This shows that <code>stm32mp135f_dk_defconfig</code> is available. Install it by calling
make on it:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>stm32mp135f_dk_defconfig
</pre></div>
</code></pre>
<p>Let’s enable the USB mode for Arm Trusted Firmware (TF-A) so that we will be
able to use USB flashing in the future. Open</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>make<span class="w"> </span>menuconfig
</pre></div>
</code></pre>
<p>Navigate under <code>Bootloaders ---&gt;  ARM Trusted Firmware (ATF)</code> and add the
following at the end of the “Additional ATF build variables” string:</p>
<pre><code><div class="codehilite"><pre><span></span>STM32MP_USB_PROGRAMMER=1
</pre></div>
</code></pre>
<p>Then select “OK”, and “Esc” your way out of the menuconfig. Make sure to say
“Yes” when asked whether to save the new configuration.</p>
</li>
<li>
<p>Run the build, and collect logs into a file:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span><span class="nb">time</span><span class="w"> </span>make<span class="w"> </span>&gt;log.txt<span class="w"> </span><span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span>
</pre></div>
</code></pre>
<p>On my dual-core i5-7300U laptop, this took about an hour and a half.</p>
<p>Watch the build from another terminal:</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>tail<span class="w"> </span>-f<span class="w"> </span>log.txt
</pre></div>
</code></pre>
</li>
<li>
<p>Copy the generated image to an SD card (assumed to be at <code>/dev/sdb</code>):</p>
<pre><code class="language-sh"><div class="codehilite"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>output/images/sdcard.img<span class="w"> </span><span class="nv">of</span><span class="o">=</span>dev/sdb<span class="w"> </span><span class="nv">bs</span><span class="o">=</span>1M
</pre></div>
</code></pre>
</li>
<li>
<p>Time to run it on the evaluation board! Set it up as follows:</p>
<ul>
<li>Insert the SD card into the slot</li>
<li>Connect the USB-C port to the right of the screen (<code>CN12</code>, labelled <code>PWR_IN</code>)
to a powered USB hub</li>
<li>Connect the Micro USB (<code>CN10</code>, left of the screen) to a desktop computer,
which will enumerate as a serial port (<code>/dev/ttyACM0</code> on my computer).</li>
<li>Open a serial console (115200 baud, no parity) to listen</li>
</ul>
<p><img src="../images/board.jpg" alt="" /></p>
<p>Set the DIP switches to boot from the SD card as shown in the image below. In
this orientation, press in on the upper side of the rockers of <code>BOOT0</code> and
<code>BOOT2</code>, and on the lower side for <code>BOOT1</code>.</p>
<p><img src="../images/buttons.jpg" alt="" /></p>
<p>Press the black reset button and if everything went right, you should see the
kernel boot messages displayed on the serial monitor, until the login prompt
gets displayed. Done!</p>
<pre><code><div class="codehilite"><pre><span></span>Welcome to Buildroot
buildroot login: root
# uname -a
Linux buildroot 6.12.22 #1 SMP PREEMPT Wed Sep  3 20:23:46 PDT 2025 armv7l GNU/Linux
</pre></div>
</code></pre>
</li>
</ol>
<h3 id="discussion">Discussion</h3>
<p>This is, to my knowledge, the fastest way to get started with embedded Linux on
“real” hardware in terms of number of steps. However, it does not result in the
most minimal distribution. Besides the Linux kernel, the default configuration
pulls in a number of large programs, such as U-Boot, ATF, OP-TEE, and more.
(Examine <code>buildroot/dl</code>) after building to see all the stuff that got downloaded
in the build process.)</p>
<p>For someone used to bare-metal embedded work, the size and complexity of this
auxiliary software is utterly baffling. A bootloader with more lines of code
than my whole project? Several different compilers and interpreters (C, Rust,
Perl, Python) needed for a “Hello, world!?”</p>
<p>In my mind I hold an ideal of the “pure” essence of Unix: there is one kernel,
which at the end of its boot process invokes one user-space program (<code>init</code>),
which then does anything it wants to. I believe in the simplicity of the Linux
boot process, as outlined by Russell King in the 2002 masterpiece, <a href="https://www.kernel.org/doc/Documentation/arm/Booting">“Booting ARM
Linux”</a>:</p>
<ol>
<li>Initialize RAM and copy the kernel into it</li>
<li>Initialise one serial port</li>
<li>Load the device tree blob (DTB) into RAM, and place its address in <code>r2</code></li>
<li>Pass control to Linux and watch it boot like magic!</li>
</ol>
<p>It is time we regain the pristine uncomplicated state that used to exist before
everything became bundled and containerized and wrapped inside countless layers
of abstraction that are supposed to make things simpler, but in the end serve
only to confuse everyone.</p>
<p>In the next articles, we will take this “primordial mess” and cut it down to
size. Stay tuned!</p>
<div class="series-box">
<h3 id="series-list">All Articles in This Series</h3>
<ul>
  <li><em>1. This article</em></li>
  <li><a href="stm32mp135-linux-cubeprog">2. STM32MP135 Flashing via USB with STM32CubeProg</a></li>
  <li><a href="stm32mp135-without-u-boot">3. STM32MP135 Without U-Boot (TF-A Falcon Mode)</a></li>
  <li><a href="linux-tfa-bl33-qemu">4. Linux as TF-A BL33 on Qemu (No U-Boot)</a></li>
  <li><a href="stm32mp135-without-optee">5. STM32MP135 Without OP-TEE</a></li>
  <li><a href="linux-bringup-on-custom-stm32mp135-board">6. Linux Bring-Up on a Custom STM32MP135 Board</a></li>
  <li><a href="build-linux-for-stm32mp135-in-under-50-lines-of-makefile">7. Build Linux for STM32MP135 in under 50 Lines of Makefile</a></li>
</ul>
</div>

</div>

<footer class="license-footer">
<p>Content licensed under
<a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
</p>
</footer>

</body>
</html>
